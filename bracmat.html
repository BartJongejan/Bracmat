<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><style type="text/css"><!--span.courier {font-family: monospace;}-->span.arrow {line-height: 12pt}</style><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="robots" content="all, index" /><title>Bracmat Help</title></head><body><p><i>This HTML document is automatically generated from the Help file that
accompanies Bracmat, using Bracmat to do the conversion.</i></p><h1><a name="lusmenu">                       BRACMAT                       </a></h1><br ex="EX2" /><br ex="ENDEX2" /><dl><dt><a href="#aanbevelingen"> starting with Bracmat</a></dt><dt><a href="#patternm"> pattern matching</a></dt><dt><a href="#syntax"> grammar</a></dt><dt><a href="#binmenu"> binary operators</a></dt><dt><a href="#unopsmenu"> prefixes/unary operators</a></dt><dt><a href="#atotxt"> strings or atoms</a></dt><dt><a href="#varsmenu"> symbols</a></dt><dt><a href="#evaltxt"> the four evaluation contexts</a></dt><dt><a href="#progsmenu"> programming in Bracmat</a></dt><dt><a href="#funcmenu"> functions</a></dt><dt><a href="#contxt">data structures</a></dt><dt><a href="#objecttxt">objects</a></dt><dt><a href="#hashtxt">hash tables</a></dt><dt><a href="#filosofie">how Bracmat evolved</a></dt><dt><a href="#Bracmat-name">why the name 'Bracmat'?</a></dt><dt><a href="#colofon">how to obtain Bracmat</a></dt><dt><a href="#morexmlps">more example code</a></dt></dl><h1><a name="aanbevelingen">If you haven't seen Bracmat before ..</a></h1><br ex="EX2" />Bracmat is an interpreted programming language that will evaluate instructions
that you type at the keyboard. For example, Bracmat can<ul><li> handle big, irregular data structures,</li><li> let you delve into a data structure by means of pattern matching and</li><li> simplify an algebraic formula,</li><li> read a file with source text and execute this code in one go,</li><li> save neatly formatted source text in a file.</li></ul><br ex="ENDEX2" /><br /><br /><br ex="EX2" />In Bracmat, data and instructions have the same syntax: a mix of parentheses,
binary operators, operands and prefixes preceding those operands or
parentheses. In fact, in many cases you can't tell the difference between the
data and instructions. Bracmat has a REPL (Read Eval Print Loop), like Lisp
and many other programming languages. It offers a simple environment for input
of both data and code. After the prompt<code AAA="aaa"> {?} </code>you can write. When you hit Enter
Bracmat evaluates your input and writes the result to the screen following a<br ex="ENDEX2" /><br ex="EX" /><code AAA="aaa">{!} </code>sequence (unless there was no visible result). Under the result follows a<br ex="ENDEX" /><br ex="EX2" />line that tells whether the evaluation was successful (S) or not (F) (in rare
cases you may see a <code FFF="fff">I</code>, which, for the time being, you may interpret as
failure). In the same line the machine shows how much processor time it
needed. Intermediary results may also appear on the screen.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat and calculators have an important common feature: as long as the input
data are simple enough, the user need (and can) not specify how these data have
to be processed. Calculators handle basic calculations in a predictable,
unchangeable way, e.g. <code FFF="fff">4+7</code> will always result in <code FFF="fff">11</code>, and not in, say,
<code FFF="fff">10</code> or <code FFF="fff">23-12</code>. That is because the manufacturer had good reasons to think
that <code FFF="fff">11</code> is what the user expects and nothing else. In the same way, Bracmat
handles basic "calculations" with a much wider variety of data: rational
numbers, symbols, words and collections thereof. For example, <code FFF="fff">a+b+a</code> becomes
<code FFF="fff">2*a+b</code> and not, say, <code FFF="fff">x.a</code> or <code FFF="fff">b+2*a</code>. Again, Bracmat takes decisions
that you can't easily circumvent. However, the more complex the data are, the
better are the chances that not all results, although defendable, have an
appearance that suits you. It is here that programming comes in: Bracmat leaves
certain kinds of data unchanged, but opens the possibility to dissect data, to
perform calculations on the parts, and to assemble an answer from the resulting
sub-answers.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />First and foremost Bracmat was developed with symbolic algebra in mind. You may
add, multiply, take powers and logarithms and differentiate. Oddly enough,
Bracmat has no operators for subtraction and division. This reduces the amount
of arbitrariness in the presentation of formulae.<blockquote good="GOOD1"><pre>   a-b</pre></blockquote><dl DEF="def"><dt>must be written as</dt><dd>  <code AAA="aaa"> a+-1*b</code></dd><dt>and</dt><dd>   a/b</dd><dt>must be written as</dt><dd>
  <code AAA="aaa"> a*b^-1</code></dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Calculations are always exact. Number expressions for which no rational
representation exists are not further evaluated. Bracmat knows how to handle
the special symbols <code FFF="fff">i</code>, <code FFF="fff">e</code> and <code FFF="fff">pi</code>, but it offers no numerical representation for
<code FFF="fff">e</code> and <code FFF="fff">pi</code>.
Examples:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} a+b+-1*a                 { this is how you subtract in Bracmat }
{?} 1+(1+i)*(1+-1*i)+-1      { the leading and trailing terms force
                               Bracmat to expand the product }
{?} -12345/54321 ^ 1/2       { the square root of -12345/54321 }
{?} x^(a+x\L2*1000)
{?} 5/2 \L 987654
{?} y\D(x\D((x+y)^-2))</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat can only do arithmetic operations with integer and rational numbers.
There is virtually no limit to their size, but the program is not optimised
for number crunching.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat handles non-integer powers of positive rational numbers provided that
the number (if it is an integer) or the numerator and the denominator (if the
number is a fraction) are less than<code AAA="aaa"> 2^32 </code>or<code AAA="aaa"> 2^64 </code>respectively, depending on
whether Bracmat is compiled for a 32 or a 64 bit platform.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat happily adds and multiplies numbers of, say, a few hundred digits.
There is a pre-defined function,<code AAA="aaa"> flt$, </code>that represents rational numbers in
a "scientific" floating point notation, but Bracmat cannot do calculations
with these "reals", unless you write a function to convert them back to
rational numbers.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The binary operators have an ordering of precedence. Of the mathematical
operators,<code AAA="aaa"> + </code>has the lowest precedence and<code AAA="aaa"> \D </code>the highest<code AAA="aaa"> (+ </code><code AAA="aaa">* </code><code AAA="aaa">^ </code><code AAA="aaa">\L </code><code AAA="aaa">\D).</code>
You may use parentheses to overrule this ordering:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (a+b)*(a+c)+a^(-1*d^2+(d+1)*(d+-1))</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />When instructions are entered from the keyboard, the program waits until all
of the conditions below are fulfilled:<ul><li> <i>return</i> (or <i>enter</i>) is the last key that has been pressed</li><li> every opening parenthesis has a closing counterpart</li><li> every opening brace (start of comment) has a closing counterpart</li><li> every string has either two enclosing double quotes, or none.</li></ul><br ex="ENDEX2" /><br /><br /><br ex="EX2" />You can write a multiple-line instruction by putting the instruction inside
an extra pair of parentheses. After each non-terminating <i>return</i>, Bracmat
shows in the next line how many closing parentheses are needed for the
completion of the instruction. If you are in the middle of a string or a
comment when pressing <i>return</i>, the next line starts with<code AAA="aaa"> {str} </code>or<code AAA="aaa"> {com},</code>
respectively.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />If you want to enter several instructions on the same line, you should write
a semicolon <code FFF="fff">;</code> between the instructions. These instructions are executed
in the same order. If you do not want to see the result of a calculation, you
may write a semicolon after the last instruction. Instructions in a text file
must be separated by semicolons.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />You may freely surround binary operators with white-space characters (e.g.
space, tab, line feed). Take care not to put spaces between the characters
that make up a fraction or negative number, - 1234 / 5678 is not the same
as -1234/5678.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat can open and read a text file and execute the instructions as they are
read. After the last instruction has been executed, the file is closed. The
program that currently produces this information, is read from the file named
<code FFF="fff">help</code>. The instruction for reading a file <code FFF="fff">myprog</code> and executing the
instructions therein is <code FFF="fff">get$myprog</code>. The <code FFF="fff">$</code> is a binary operator that
has to do with function evaluation. <code FFF="fff">get</code> is the function name of one of
the few built-in functions.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The result of the last executed instruction in a file is written to the screen.
For better control over screen output one may use the built-in function <code FFF="fff">put</code>,
which writes from the current cursor position to the right, or the pre-defined
(but changeable) function <code FFF="fff">out</code>, which writes an extra line feed after its
argument has been written to the screen.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} put$(x*x);put$(y+y)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Often you will need the result of the last evaluated instruction in the
next one. You can use the exclamation mark <code FFF="fff">!</code> instead of re-entering
the result. (Because Bracmat is still evaluating the instruction <code FFF="fff">get$help</code>,
this trick is of no use in the context of this program.) Example (try later):<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 1+1
{?} !^!^!^!</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />When you write programs in the Bracmat language you will normally use an
external text editor. You can enter small programs directly at the Bracmat
prompt<code AAA="aaa"> {?}, </code>but a small change in an instruction can only be done by re-
entering the whole instruction. You may save instructions that are still
held in memory (which is only possible if they are bound to variables),
by the built-in <code FFF="fff">lst</code> function. This function takes a number of optional
parameters that tell the system whether the instruction has to be written in a
compact and barely readable form, or in a more pretty form, with lots of
indentations. Comments are never written, as they are ignored at input time.
As an example, you can write the definition of the pre-defined factorisation
function <code FFF="fff">fct</code> to a file <code FFF="fff">factorise</code> by entering the following instruction:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} lst$(fct,factorise,NEW) {NEW:replace old file with same name}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />At first sight, a Bracmat program doesn't look like programs written in other
languages. This may even become a permanent impression. So here are some
recommendations about programming habits:<ul><li> Experiment with the examples from this information program.</li><li> Use a modular and incremental style of programming: test every function
  before going on to the next one.</li><li> Keep functions small, to begin with. Error messages point to functions, not
  to line numbers.</li><li> Use meaningful names. There is no limit to their length and you may use the
  minus-sign as separator in multiple-word-names.</li><li> Write comments if variable names do not tell enough.</li><li> Feel free to write parentheses if that clarifies the program structure.</li><li> Write parentheses in a BEGIN-END-style, the closing parenthesis below the
  opening parenthesis.</li><li> Check whether Bracmat interprets your code in the way you intended by listing
  your functions without the <code FFF="fff">LIN</code> option.</li><li> Try to evade the "not" prefix<code AAA="aaa"> ~ </code>and the use of arrays.</li></ul><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="patternm">Pattern matching</a></h1><br ex="EX2" />The single most outstanding feature of Bracmat is how it can recognise patterns
in data. The data can be an algebraic expression, a directory listing in table
form, a thesaurus structured like a tree, a text or whatever data that can be
expressed as a string of characters or as a tree of such strings. Bracmat's
patterns are much more advanced than regular expressions. Regular expressions
are fixed patterns once the matching operation is started. Bracmat implements
not only propositional rules comparable to regular expressions, but also first
order predicate rules, backtracking to search the space of combinations of data
that make its predicates come true. In this way it is very easy to implement a
relational database. But it doesn't stop here, because Bracmat supports
recursive invocations of pattern matching and other operations. Examples:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} S=(|0 !S|1 !T);T=(0 !T|1 !S); { Regular grammar }
{?} 0 1 0 1 0:!S { Check whether subject contains an even number of 1's. }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} P=(|0 ?x 1 &amp; !x:!P); { context free grammar }
{?} 0 0 0 1 1 1:!P { Check whether subject consist of a row of 0's
                     followed by a row of 1's of the same length. }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} connected=("South America"."North America") (Africa.Asia) (Asia.Europe);
{?} (reachable = a b f
    .     !arg:(?a.?b.?f)
        &amp; !f:? ((!a.!b)|(!b.!a)) ?
      |   !f:?A ((!a.?c)|(?c.!a)) ?Z
        &amp; reachable$(!c.!b.!A !Z)
    ); {Remove used fact from fact base.}
{?} (   Antarctic Europe Australia Africa Asia "North America" "South America"
    :   ?
        %@?x  {Pick a continent.}
        ?
        ( %@?y {Pick another continent}
        &amp; reachable$(!x.!y.!connected) {Are they reachable?}
        &amp; out$(!x "is reachable from" !y)
        &amp; ~  {Force backtracking to collect all answers.}
        )
        ?
    );    { pattern using second order logic }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" />Europe is reachable from Africa
Europe is reachable from Asia
Africa is reachable from Asia
North America is reachable from South America<br ex="ENDEX2" /><dl><dt><a href="#pattxttxt">Pattern matching in character strings</a></dt><dt><a href="#pattxt">Pattern matching in tree structures</a></dt></dl><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="pattxttxt">Pattern matching in strings</a></h1><br ex="EX2" /><code AAA="aaa">@(<i>string</i> : <i>pattern</i>) </code>  "match <i>string</i> with <i>pattern</i>"<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Pattern matching in a string of characters (a single atom) is like pattern
matching in a string of atoms. Use the<code AAA="aaa"> '@' </code>to instruct the program to look
inside the atom and use space operators to combine subpatterns. The space
operator does not itself match any characters. To match a space in an atom,
use a space in an atom!<br ex="ENDEX2" /><br /><br /><br ex="EX2" />You cannot negate the result of string pattern matching by adding the<code AAA="aaa"> ~ </code>prefix,
unless there are other prefixes than<code AAA="aaa"> @ </code>and<code AAA="aaa"> ~ </code>present.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} a b:(~@(? b:a %)) {succeeds, ~@ means:'not an atom'}
{?} ~@(a b:a ?)       {succeeds, ~@ means: not a string match'}
{?} ~@(a:a)           {succeeds, same reason}
{?} 12/34:@(?x:#?a (~#%@:?y) #?b) {succeeds, ?x matches the atom 12/34,
                       while #?a (~#%@:?y) #?b matches 12/34 as a string.}
{?} 12:~/@(?x:#%?a #%?b) {succeeds, ~ negates /, not @, so we have a string
                       match.}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#patternm" style="line-height:12pt">Pattern matching</a><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇒</span><a href="#pattxt2" style="line-height:12pt">Matching a number in a string</a><br /><span class="arrow">⇐</span><a href="#pattxt" style="line-height:12pt">Binary operators in pattern matching</a><br /><h1><a name="pattxt2">Matching a number in a string</a></h1><br ex="EX2" />In a string match, the<code AAA="aaa"> % </code>can be used to force characterwise matching if the
subject is a number and the pattern otherwise would have been treated as a
number.
You have to take care with minuses: the patterns<code AAA="aaa"> %"-20/5" </code>and<code AAA="aaa"> %-20/5 </code>are
different. In<code AAA="aaa"> %"-20/5", </code>the<code AAA="aaa"> % </code>is superfluous and the pattern matches
characterwise. In<code AAA="aaa"> %-20/5, </code>the pattern matches 20/5 and the minus is ignored!<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} @(abcd40/10efgh:?a    20/5  ?z)    {succeeds, because 4 = 20/5 = 4}
{?} @(abcd52/13efgh:?a    20/5  ?z)    {succeeds, because 52/13 = 20/5 = 4}
{?} @(abcd40/10efgh:?a   %20/5  ?z)    {fails}
{?} @(abcd-20/5efgh:?a %"-20/5" ?z)    {succeeds}
{?} @(abcd-20/5efgh:?a  %-20/5  ?z)    {succeeds, a = abcd-}
{?} @(abcd-20/5efgh:?a   -20/5  ?z)    {succeeds, a = abcd }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#patternm" style="line-height:12pt">Pattern matching</a><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇐</span><a href="#pattxttxt" style="line-height:12pt">Pattern matching in strings</a><br /><span class="arrow">⇒</span><a href="#escappattxt" style="line-height:12pt">Escaping operator in patterns</a><br /><h1><a name="pattxt">Binary operators in pattern matching</a></h1><br ex="EX2" /><i>subject</i> : <i>pattern</i>   "match <i>subject</i> with <i>pattern</i>"<br ex="ENDEX2" /><br /><br /><br ex="EX2" />A match succeeds if <i>subject</i> succeeds and <i>pattern</i> is successfully matched
with <i>subject</i>. The returned value is the left operand, <i>subject</i>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Patterns may be built up from sub-patterns and may also include actions that
are triggered if a sub-pattern successfully matches (part of) the subject.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />As with the evaluation of other binary operators, the left operand of the ":"
operator is evaluated first. The other operand, <i>pattern</i>, is not evaluated,
but in the process of pattern matching (parts of) <i>pattern</i> may be evaluated
several times. This is the case with function calls, atoms with a "!" prefix
and all right hand sides of the<code AAA="aaa"> "&amp;" </code>operator. The use of the involved binary
operators<code AAA="aaa"> ($ </code>'<code AAA="aaa"> &amp;) </code>and prefixes (!<code BBB="bbb"> !!) </code>as "meta operators" does not restrict
the range of matchable expressions in a serious way, as these operators and
prefixes normally do not occur in evaluated subject expressions. The same is
true for some other operators (:<code AAA="aaa"> | </code>_ and<code AAA="aaa"> =). </code>These operators, too, have a
special meaning within patterns. All other binary operators occurring in a
pattern are searched for in the subject expression as part of the pattern
matching.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Especially the<code AAA="aaa"> &amp; </code><code AAA="aaa">| </code>and : operators are helpful in formulating complex
patterns with alternatives, conjunctions and side effects in the form of
actions. In the following examples,<code BBB="bbb"> !s </code>stands for the subject expression,
the expressions in parentheses are patterns and<code BBB="bbb"> !p, </code>!pa,<code BBB="bbb"> !pb, </code>etc. are
sub-patterns therein.<code BBB="bbb"> !a, </code>!aa, etc. stands for an action (a part of the
pattern that is conditionally evaluated).<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   !s:(!p&amp;!a)</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If<code BBB="bbb"> !p </code>matches successfully with<code BBB="bbb"> !s, </code>then<code BBB="bbb"> !a </code>is evaluated. If<code BBB="bbb"> !a</code>
fails, the whole match fails. In more complex patterns, only part
of the match might fail, resulting in backtracking and retry.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   !s:(!pa|!pb)</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If pattern<code BBB="bbb"> !pa </code>does not match with subject<code BBB="bbb"> !s, </code>then<code BBB="bbb"> !pb </code>is tried.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   !s:(!pa:!pb)</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If pattern<code BBB="bbb"> !pa </code>matches with<code BBB="bbb"> !s, </code>then pattern<code BBB="bbb"> !pb </code>is also tried.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The next example combines these operators in a grammar-like expression:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   !s:( !pa         &amp; !aa       If either !pa, or !pb or both of !pc1 and !pc2</pre></blockquote><blockquote good="GOOD1"><pre>      | !pb         &amp; !ab       "fire", actions !aa, !ab and !ac, respectively</pre></blockquote><blockquote good="GOOD4"><pre>      | (!pc1:!pc2) &amp; !ac       are triggered.</pre></blockquote><blockquote good="GOOD2"><pre>      )</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Take care for the grouping of the <code FFF="fff">: &amp;</code> and <code FFF="fff">|</code> operators :<br ex="ENDEX2" /><br /><br /><br ex="EX2" />(!s:!pa):!pb and<code BBB="bbb"> !s:(!pa:!pb) have, incidentally, the same effect, but the</code>
following expressions are very different :<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code AAA="aaa">(!s:!p)&amp;!e </code>or<code AAA="aaa"> !s:!p&amp;!e</code></dt><dd>   If<code BBB="bbb"> !s </code>matches with<code BBB="bbb"> !p, </code>!e is returned.</dd><dt><code AAA="aaa">!s:(!p&amp;!a)</code></dt><dd>   If<code BBB="bbb"> !s </code>matches with<code BBB="bbb"> !p, </code>!a is evaluated, but the expression as a whole
   returns<code BBB="bbb"> !s.</code></dd><dt><code AAA="aaa">(!s:!p)|!e </code>or<code AAA="aaa"> !s:!p|!e</code></dt><dd>   If<code BBB="bbb"> !s </code>matches with<code BBB="bbb"> !p, </code>!s is returned. Otherwise,<code BBB="bbb"> !e </code>is returned.</dd><dt><code AAA="aaa">!s:(!pa|!pb)</code></dt><dd>
   If<code BBB="bbb"> !s </code>matches with either<code BBB="bbb"> !pa </code>or<code BBB="bbb"> !pb </code>(in that order),<code BBB="bbb"> !s </code>is returned.</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The possibility that<code BBB="bbb"> !s </code>might fail further complicates the above examples.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#patternm" style="line-height:12pt">Pattern matching</a><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇒</span><a href="#escappattxt" style="line-height:12pt">Escaping operator in patterns</a><br /><span class="arrow">⇒</span><a href="#pattxttxt" style="line-height:12pt">Pattern matching in strings</a><br /><span class="arrow">⇒</span><a href="#unpattxt" style="line-height:12pt">Prefixes and pattern matching</a><br /><span class="arrow">⇐</span><a href="#prostutxt1" style="line-height:12pt">Program flow</a><br /><span class="arrow">⇐</span><a href="#asstxt" style="line-height:12pt">Assignment to variables</a><br /><h1><a name="escappattxt">Escaping operator in patterns</a></h1><br ex="EX2" />Some operators can not be part of a pattern unless 'escaped', because these
operators play an active role in pattern matching instead of being passiv part
of a pattern. These operators are<code AAA="aaa"> = </code><code AAA="aaa">| </code><code AAA="aaa">&amp; </code>: '<code AAA="aaa"> $ </code>_<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The normal role of these operators is ignored by the pattern matching
evaluator if they are 'escaped' with a<code AAA="aaa"> $ </code>node with an empty lhs.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (=foo'bar):(=$(foo'bar))
{?} (=foo'bar):(=$(?f'?x)) &amp; !f !x
{!} foo bar</pre></blockquote><br ex="ENDEX" /><br ex="EX2" />The escape operator only affects the top node of the escape operator's rhs.
The lhs and rhs of the affected node are matched against the subject in the
normal way. The escape operator functions with all Bracmat operators, but the
operators . , whitespace,<code AAA="aaa"> + </code><code AAA="aaa">* </code><code AAA="aaa">^ </code>\L and \D should not be escaped normally.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#patternm" style="line-height:12pt">Pattern matching</a><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><span class="arrow">⇐</span><a href="#pattxt" style="line-height:12pt">Binary operators in pattern matching</a><br /><span class="arrow">⇐</span><a href="#funmactxt" style="line-height:12pt">function evaluation</a><br /><span class="arrow">⇐</span><a href="#pattxt2" style="line-height:12pt">Matching a number in a string</a><br /><span class="arrow">⇐</span><a href="#unpattxt" style="line-height:12pt">Prefixes and pattern matching</a><br /><span class="arrow">⇐</span><a href="#macrotxt" style="line-height:12pt">macro evaluation</a><br /><h1><a name="syntax">The grammar of Bracmat</a></h1><br ex="EX2" />Note: in long lists the<code AAA="aaa"> "|" </code>is left out.<blockquote pech="C"><pre>&lt;input&gt;           ::= [&lt;expression&gt;] [;&lt;input&gt;]
&lt;expression&gt;      ::=   &lt;white space&gt; &lt;expression&gt; &lt;white space&gt;</pre></blockquote><blockquote good="GOOD1"><pre>                     | [&lt;prefixes&gt;] ( &lt;expression&gt; )</pre></blockquote><blockquote good="GOOD4"><pre>                     | &lt;leaf&gt;</pre></blockquote><blockquote good="GOOD1"><pre>                     | &lt;expression&gt; &lt;binop&gt; &lt;expression&gt;</pre></blockquote><blockquote pech="C"><pre>&lt;leaf&gt;            ::= [&lt;prefixes&gt;] &lt;atom-or-nil&gt;
&lt;atom-or-nil&gt;     ::= &lt;atom&gt; | &lt;nil&gt;
&lt;atom&gt;            ::= "&lt;string&gt;" | &lt;string&gt;
&lt;string&gt;          ::= &lt;character&gt; [&lt;string&gt;]
&lt;character&gt;       ::= any printable character except \ and " | &lt;spec&gt;
&lt;spec&gt;            ::= \a \b \t \n \v \f \r \" \\
&lt;nil&gt;             ::= ""   (or nothing at all, such as in "()")
&lt;binop&gt;           ::= = . , | &amp; : &lt;white space&gt; + * ^ \L \D ' $ _
&lt;prefixes&gt;        ::= &lt;prefix&gt; [&lt;prefixes&gt;]
&lt;prefix&gt;          ::= [ ~ / # &lt; &gt; % @ ` ? ! !!
&lt;white space&gt;     ::= spaces, tabs, new line and form feed characters</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />White space (operator/cosmetic measure) almost never leads to confusion. It
does in (some) cases where a <i>nil</i> leaf without prefixes is adjacent to the white
space operator. For example : <code FFF="fff">get' out$now</code>. Bracmat interprets this as :
<code FFF="fff">get'(out$now)</code>. <code FFF="fff">""</code> or <code FFF="fff">()</code> fixes the problem : <code FFF="fff">get'() out$now</code>.
Quotation marks are not part of the string they surround. They should be used
if necessary, e.g. <code FFF="fff">in this case</code> or <code FFF="fff">he{this is not a comment}re</code>.
Comments can be written everywhere, except in the middle of a string in
Quotation marks. Comments are enclosed in<code AAA="aaa"> {} </code>and may be nested.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="binmenu">Binary operators</a></h1><br ex="EX2" /><br ex="ENDEX2" /><dl><dt><a href="#binovztxt"> choose a specific binary operator</a></dt><dt><a href="#algtxt"> algebraic operations</a></dt><dt><a href="#binprotxt"> program flow</a></dt><dt><a href="#pattxt"> pattern matching</a></dt><dt><a href="#contxt"> data structures</a></dt><dt><a href="#asstxt"> assignment</a></dt><dt><a href="#funmactxt"> functions and macros</a></dt><dt><a href="#dumtxt"> the dummy operator</a></dt></dl><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="binovztxt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a></h1><br ex="EX2" />These are the 15 binary Bracmat operators. The higher in the list, the lower
in the order of operations. Use parentheses to force an operator to a higher
position in the order of operations.
<br ex="ENDEX2" /><dl><dt><a href="#savtxt"><code FFF="fff">=</code></a></dt><dd>    assignment:<code FFF="fff">(x=7)</code><code FFF="fff">(square=.!arg^2)</code><br />    object member definition:<code FFF="fff">(myobject=(place=Copenhagen) (setPlace=.!arg:?(its.place)))</code></dd><dt><a href="#contxt"><code FFF="fff">.</code></a></dt><dd>    fixed data structure:<code FFF="fff">(Palme.Olof.Sweden)</code><br />    object member referencing:<code FFF="fff">(myhash..insert)$(xxx.998743)</code></dd><dt><a href="#contxt"><code FFF="fff">,</code></a></dt><dd>    list with autostretch:<code FFF="fff">(ham,(bread,butter),jam):(ham,bread,butter,jam)</code></dd><dt><a href="#binprotxt"><code FFF="fff">|</code></a></dt><dd>    or else:<code FFF="fff">get$myfile | out$"Cannot read myfile"</code></dd><dt><a href="#binprotxt"><code FFF="fff">&amp;</code></a></dt><dd>    and then:<code FFF="fff">out$"alomost done" &amp; Done</code></dd><dt><a href="#asstxt"><code FFF="fff">:</code></a></dt><dd>    match subject with pattern:<code FFF="fff">Meeting at 4 in room 24:? ?#hour ? ?#room ?</code></dd><dt><a href="#contxt"><code AAA="aaa">[blank]</code></a></dt><dd>    sentence, neutral element "":<code FFF="fff">Oh well this can go on and on:?a Oh ?z &amp; !a:""</code></dd><dt><a href="#algtxt"><code FFF="fff">+</code></a></dt><dd>    add, neutral term 0:<code FFF="fff">(a+6+b+a+10)</code>,<code FFF="fff">(a+b:?x+a+?y &amp; !x:0)</code></dd><dt><a href="#algtxt"><code FFF="fff">*</code></a></dt><dd>    multiply, neutral factor 1:<code FFF="fff">(46546*647547564)</code>,<code FFF="fff">(a*b:?x*a*?y &amp; !x:1)</code></dd><dt><a href="#algtxt"><code FFF="fff">^</code></a></dt><dd>    raise to a power, neutral exponent 1:<code FFF="fff">(9975^332)</code>,<code FFF="fff">(45:?n^?exp &amp; !exp:1)</code></dd><dt><a href="#algtxt"><code FFF="fff">\L</code></a></dt><dd>    take logarithm:<code FFF="fff">10\L1050</code></dd><dt><a href="#difftxt"><code FFF="fff">\D</code></a></dt><dd>    differentiate:<code FFF="fff">x\D(x^10)</code></dd><dt><a href="#funmactxt"><code FFF="fff">'</code></a></dt><dd>    function evaluation (does not evaluate rhs):<code FFF="fff">str'(b+a):"b+a"</code><br />    macro:<code FFF="fff">()'(my name is ()$name)</code></dd><dt><a href="#funmactxt"><code FFF="fff">$</code></a></dt><dd>    function evaluation (evaluates rhs):<code FFF="fff">str$(b+a):"a+b"</code><br />    variable in macro:<code FFF="fff">()'(my name is ()$name)</code></dd><dt><a href="#dumtxt"><code FFF="fff">_</code></a></dt><dd>    dummy:   <code FFF="fff">!expr:?lhs_?rhs &amp; (do$!lhs)_(do$!rhs)</code>  </dd></dl><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><h1><a name="savtxt">The<code AAA="aaa"> = </code>operator</a></h1><br ex="EX2" />This operator assures that the right hand operator stays unevaluated. It is
mainly used in the definition of pieces of code (e.g. functions). The code
on the right is bound to the name on the left.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><code AAA="aaa"><i>atom</i>=<i>expression</i></code><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Each time when the value of <i>atom</i> is asked for, a fresh copy of <i>expression</i>
is made available. <i>expression</i> itself is unchangeable and can only be wiped
out by removing the binding between <i>expression</i> and its name, <i>atom</i>. This
has, in turn, no influence on the copies made earlier.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} a=2    { create binding }
{?} !a:?b  { bind copy to b }
{?} !b     { show b's value }
{?} a=3    { remove a's binding to 2}
{?} !b     { show b's value }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />There is a second way of using the<code AAA="aaa"> = </code>operator, with a slightly different
syntax :<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><code AAA="aaa"><i>nil</i>=<i>expression</i></code><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The<code AAA="aaa"> = </code>operator serves as a shock proof container for <i>expression</i>.
The effect of evaluating this type of expression is almost the same as that
of the macro instruction ()'<i>expression</i>. Indeed, after evaluating a macro
instruction we have an expression with the<code AAA="aaa"> <i>nil</i>=<i>expression</i> </code>syntax.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} out$(b+a)
{?} out$(=b+a)
{?} out$('(b+a))
{?} c=3
{?} out$(=b+a+$c)
{?} out$('(b+a+$c))</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇒</span><a href="#objecttxt" style="line-height:12pt">Objects</a><br /><h1><a name="objecttxt">Objects</a></h1><br ex="EX2" />With the<code AAA="aaa"> = </code>and . operators you can construct and dereference conventional data
structures and even objects with methods. In an expression, each subexpression
with a<code AAA="aaa"> = </code>operator in the top node and an atom in the lhs of the top node
indicates a field or object method that can be accessed and changed
independently of other fields and methods, i.e. without the need to dissect and
reassemble the whole expression. Such expressions are objects. An object member
(a field or method) is addressed by using the lhs of the<code AAA="aaa"> = </code>operator as the
member's name, preceded by the objects name. The name of the object and the
name of the member must be separated by a dot operator.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />In the example below an object named <code FFF="fff">John</code> is created with the members
<code FFF="fff">length</code>, <code FFF="fff">age</code> and <code FFF="fff">name</code>. The <code FFF="fff">name</code> member has two sub-members
<code FFF="fff">first</code> and <code FFF="fff">family</code>:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} John = (length = 180),(age = 30),(name = (first=John) (family=Bull))</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />There is no prescribed way in which the members should be glued together to
form an object. Here, the comma operator and blank operator are used, but any
operator but the<code AAA="aaa"> = </code>operator can be used to separate field names.
John's length can be changed to 185 in the following ways:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} John.length = 185</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />or<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 185 : ?(John.length)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The same object can be assigned to another variable, creating an alias, but
we have to take care not to evaluate <code FFF="fff">John</code>, because that would create or
overwrite the variables <code FFF="fff">length</code>, <code FFF="fff">age</code> and <code FFF="fff">name</code>):<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} !John:?alias {Wrong, (alias=length,age,name);}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} '$John : (=?alias) {Right,  (alias=
                                  (length=185)
                                , (age=30)
                                , (name=(first=John) (family=Bull)));}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat replaces the expression<code AAA="aaa"> '$John </code>by the value of John, protected
against evaluation by a<code AAA="aaa"> = </code>operator. For that reason, the pattern on the rhs
of the match operator : contains a<code AAA="aaa"> = </code>operator as well. Now we can change John's
age by operating on the variable <code FFF="fff">alias</code>:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} alias.age = 31</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />To see that the above expression indeed has the wanted (side-)effect, we can
inspect <code FFF="fff">John</code>:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} lst$John
 (John=
   (length=180)
 , (age=30)
 , (name=(first=John) (family=Bull)));</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Alternatively, we can also just show the field <code FFF="fff">age</code> in <code FFF="fff">John</code>:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} !(John.age)
{!} 31</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />It is also possible to create an alias for a sub-object. Taking the previous
example, we could create an alias for the name member:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} '$(John.name):(=?nm)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Now assign a new family name:<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} Flinter:?(nm.family)
{?} lst$John
 (John=
   (length=180)
 , (age=30)
 , (name=(first=John) (family=Flinter)));</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Using an alias for a sub-object can save some code and processing time if the
sub-object is accessed many times. Without the alias for John's name, we can
change his family name in this way:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} Flinter:?(John.name.family)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />It is valid to have an empty name for a member:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} x=(header=blabla) (=(a=1) (b=2))</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Here, <code FFF="fff">a</code> and <code FFF="fff">b</code> are fields in a "nameless" sub-object of <code FFF="fff">x</code>. We can ask for the
value of <code FFF="fff">b</code>:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} !(x..b)
{!} 2</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />To retrieve the whole sub-object:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} '$(x.):(=?sub-object)
{?} lst$sub-object
 (sub-object=
 (a=1) (b=2));</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />An alias can also be created for part of an object:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} x=(a=) (b=) (c=) (d=)
{?} '$x:(=(a=) ?alias (d=))</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Now <code FFF="fff">alias</code> only shares the members <code FFF="fff">x.b</code> and <code FFF="fff">x.c</code> with <code FFF="fff">x</code>. The same result follows
from<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} '$x:(=? ((b=) (c=):?alias) ?)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Objects can be composed to form new objects containing the union of the members
of the contributing objects:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} x=(a=) (b=)
{?} '((p=) ($x) (q=)):(=?r)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Evaluation of an expression that contains<code AAA="aaa"> '=' </code>operators can have
unexpected side effects, as the following example shows.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />First suppose that <code FFF="fff">x</code> (containing one record with one anonymous field) is
unevaluated (case A) and assigned to two other variables:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} x=(=)
{?} !x:?y
{?} !x:?z</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />In this case, <code FFF="fff">x</code>, <code FFF="fff">y</code> and <code FFF="fff">z</code> are different objects. For example does<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 2:?(y.)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />not affect <code FFF="fff">x</code> and <code FFF="fff">z</code>. Do the assignment again, but this time evaluating <code FFF="fff">x</code> only
once:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} !x:?y:?z</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Now <code FFF="fff">y</code> and <code FFF="fff">z</code> are the same object, but still different from <code FFF="fff">x</code>.
A change made to <code FFF="fff">y</code> affects <code FFF="fff">z</code> but does not affect <code FFF="fff">x</code>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Suppose that <code FFF="fff">x</code> IS evaluated (case B):<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (=):?x
{?} !x:?y
{?} !x:?z</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Now <code FFF="fff">x</code>, <code FFF="fff">y</code> and <code FFF="fff">z</code> are the same object.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Explanation: in (A) the value of <code FFF="fff">x</code> is not evaluated, especially the lhs of
the<code AAA="aaa"> '=' </code>operator. Therefore, a new<code AAA="aaa"> '=' </code>node is created each time <code FFF="fff">x</code> is
evaluated. In (B), the value of <code FFF="fff">x</code> IS evaluated, so no new copies of the
<code AAA="aaa">'=' </code>node are made.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><span class="arrow">⇐</span><a href="#savtxt" style="line-height:12pt">The<code AAA="aaa"> = </code>operator</a><br /><span class="arrow">⇐</span><a href="#contxt" style="line-height:12pt">Construction of data structures</a><br /><span class="arrow">⇒</span><a href="#asstxt" style="line-height:12pt">Assignment to variables</a><br /><h1><a name="asstxt">Assignment to variables</a></h1><br ex="EX2" />There are two forms of assignment to a variable:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><i>variable</i><code AAA="aaa"> = </code><i>expression</i></dt><dd>     <i>expression</i> is not evaluated before assignment to <i>variable</i>.</dd><dt><i>expression</i> :<code BBB="bbb"> ?<i>variable</i></code></dt><dd>
     <i>expression</i> is evaluated before assignment takes place.</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The<code AAA="aaa"> = </code>operator is used to bind (still) unevaluated expressions such as
patterns and functions to variables.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Assignment with the <code FFF="fff">:</code> makes use of pattern matching with a universally
unifying pattern. This way of assignment is very powerful and can even be
used to assign unevaluated expressions, by preceding the subject with an
<code AAA="aaa">= </code>or an ' operator. Example: define Lisp's car-function, first using<code AAA="aaa"> = </code>and
then using : to bind the function definition to the variable <code FFF="fff">car</code>.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} car=.!arg:(?%arg ?)&amp;!arg          { one may freely reuse arg ! }
{?} (=(.!arg:(?%arg ?)&amp;!arg)):(=?car) { another way to define car }
{?} car$(one two three)
{?} (four five six):(?`%first ?rem) {"`": 0 of 1, "%": 1 or more, together 1}
{?} The first element is !first and the remainder is !rem.</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇐</span><a href="#objecttxt" style="line-height:12pt">Objects</a><br /><span class="arrow">⇒</span><a href="#pattxt" style="line-height:12pt">Binary operators in pattern matching</a><br /><h1><a name="contxt">Construction of data structures</a></h1><br ex="EX2" />In Bracmat linear lists can be made by separating the elements with comma,
plus sign, asterisk, space and dot. The first four operators create linear
structures (right descending lists), moving nodes as necessary, whereas the
dot operator creates any tree structure. In addition, the plus sign and the
asterisk (times) do not preserve the order of the elements if they are not
canonical order. Which operator one should use in a given situation depends on
the following considerations:<ul><li> Space, comma, plus and asterisk offer automatic concatenation of lists, but
  are slower than the dot.</li><li> Space, plus and asterisk are useful if there is a need to search in a list,
  because these operator support backtracking, but they are slower than the
  comma.</li><li> The comma can be used in linear lists that are accessed recursively and in
  record-like structures, where the elements must have absolute positions.
  The dot can be used for the same purpose.</li><li> If a function has a fixed number of parameters, you should use dots to
  separate them.</li><li> If there is a need to sort elements alphabetically, use the plus operator.</li><li> Lists constructed with plus or asterisk behave like sets. Adding an element
  that already is present does not make the list any longer, but will instead
  increase a factor (plus) or exponent (astererisk).</li></ul><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Examples :<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} x=a.b.c
{?} y=p.q
{?} !x.!y
{!} (a.b.c).p.q
{?} x=a b c
{?} y=p q
{?} !x !y
{!} a b c p q
{?} set=jan+piet+klaas
{?} !set
{!} jan+klaas+piet
{?} !set+klaas
{!} jan+2*klaas+piet</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} rotate=car,cdr.!arg:(?car,?cdr) &amp; (!cdr,!car)
{?} rotate$(one,two,three,four)
{?} rotate$((one,two),(three,four))</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />By combining dots, commas and spaces, one may build any tree-like data structure
that, thanks to the backtracking mechanism on space-separated lists, make
the formulation of queries (goals) almost as easy as in Prolog. This is an
example of a simple database, in which each row starts with a descriptor
field, followed by a varying number of similar fields.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} M=( (odd  ,1 3 5 7 9)
        (even ,0 2 4 6 8)
        (prime,2 3 5 7)
      )</pre></blockquote><br ex="ENDEX" /><br ex="EX2" />We choose the space operator to form the backbone of the lists of numbers,
because we want to access these numbers associatively, by using the back-
tracking mechanism.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Let us formulate a query that searches for all numbers that occur in
two or more categories (odd, even, prime). The findings are to be
printed to the screen.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} ( !M
    :   ?                                   { skip 0 or more rows ---               }
        (?c1,?row)                          { ---fetch (number type, number row)--- }
        ?                                   { ---skip 0 or more rows ---            }
        ( ?c2                               { ---fetch another number type,...      }
        ,   ?                               { ...skip 0 or more numbers...          }
            ( %?`el                         { ...fetch a number...                  }
            &amp; !row:? !el ?                  { does number occur in earlier row ?    }
            &amp; out$(!el is both !c1 and !c2) { yes?  show result                     }
            &amp; ~                             { not satisfied yet: fail and backtrack }
            )
            ?                               { ...skip rest of numbers---            }
        )
        ?                                   { ---skip rest of rows                  }
    )</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />This prints<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   3 is both odd and prime</pre></blockquote><blockquote good="GOOD1"><pre>   5 is both odd and prime</pre></blockquote><blockquote good="GOOD4"><pre>   7 is both odd and prime</pre></blockquote><blockquote good="GOOD2"><pre>   2 is both even and prime</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />and finally fails when backtracking (induced by the <code FFF="fff">~</code>) has found all answers
to the query.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Experimentation with the implementation of matrices in Bracmat has learned
that lists (of lists (of lists..)) lead to smaller and faster programs than
arrays, artificially made multidimensional by playing with the index.
A drawback of the list approach is its unconventionality. Much time has to
be spend in reformulating existing algorithms based on indices. On the other
hand, the list approach is essentially insensitive to the dimensionality
of the matrix at hand, and may even be indifferent to the number of indices.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><span class="arrow">⇒</span><a href="#objecttxt" style="line-height:12pt">Objects</a><br /><h1><a name="binprotxt">Binary operators in program flow</a></h1><br ex="EX2" /><dl DEF="def"><dt><i>exprA</i><code AAA="aaa"> &amp; </code><i>exprB</i></dt><dd>   ("<i>exprA</i> and then <i>exprB</i>")
   <i>exprB</i> is only evaluated if <i>exprA</i> succeeds,</dd><dt><i>exprA</i><code AAA="aaa"> | </code><i>exprB</i></dt><dd>   ("<i>exprA</i> or else <i>exprB</i>")
   <i>exprB</i> is only evaluated if <i>exprA</i> does not succeed.</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />In both cases <i>exprA</i> is always evaluated and <i>exprB</i> conditionally.
If <i>exprB</i> is to be evaluated, <i>exprA</i> and the<code AAA="aaa"> &amp; </code>or<code AAA="aaa"> | </code>operator have served
their purpose. Therefore, they are eliminated before <i>exprB</i> is evaluated.
In this way, the program stack doesn't grow indefinitely when recursive
calls are made from the right hand side of any<code AAA="aaa"> &amp; </code>or<code AAA="aaa"> | </code>operator occurring
in an expression . Even a conventional sequence of instructions (where the
success or failure of the evaluations of each instruction do not matter) can
make use of this tail recursion optimisation. In that case one uses the
pacifier (short cut prefix)<code AAA="aaa"> ` </code>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote pech="C"><pre>(`!a &amp; !b)     !b is always evaluated. (sequence)
(`!a | !b)     !b is not evaluated. (useless in this form)</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The pacifier or shortcut prefix is inherited by higher levels, it percolates
towards operators that are closer to the root of the tree, until it is
subsumed in situations like the above ones.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇒</span><a href="#prostutxt1" style="line-height:12pt">Program flow</a><br /><span class="arrow">⇒</span><a href="#prostutxt2" style="line-height:12pt">Some often used control structures</a><br /><h1><a name="prostutxt1">Program flow</a></h1><br ex="EX2" />Most binary operators are used in expressions that "flow on their own" or
"flow not at all". In the first group are the arithmetic operators, in
the second is the dot-operator. In between are the two other structuring
operators, comma and white space.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Branching to a function is done with the<code AAA="aaa"> $ </code>and ' operators :<br ex="ENDEX2" /><br /><br /><br ex="EX2" />a<code AAA="aaa"> $ </code>b (or a'b)       "evaluate function a with argument b"<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Branching without argument passing and local variables is done with the
unary operator (prefix)<code BBB="bbb"> ! </code>:<br ex="ENDEX2" /><br /><br /><br ex="EX2" />!X                   "do subroutine X"<br ex="ENDEX2" /><br /><br /><br ex="EX2" />but often this prefix and its cousin<code BBB="bbb"> !! </code>are used for the purpose of variable
expansion, it just depends on whether a variable is bound to an unevaluated
or to an evaluated expression :<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote pech="C"><pre>!X                   "expand X"
!!Y                  "expand expansion of Y" (two !'s is the maximum)</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Conditional evaluation is decided by the success or failure of subexpressions.
Every (sub)expression has two kinds of value: a visible value and a
success(S)/failure(F)/ignore(I) value. Success and failure are primarily
decided by the low level functions in the interpreter. The ignore value
is generated if a failing expression is back-quoted. The<code AAA="aaa"> &amp; </code>and<code AAA="aaa"> | </code>operators
are sensitive to the S/F/I value of the left operand (where I counts as S).
Often this left operand is a matching expression.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote pech="C"><pre>!a &amp; !b              "if !a succeeds do !b"
!a | !b              "if !a fails do !b"
!subject : !pattern  "try to prove that !pattern describes !subject"</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The back quote<code AAA="aaa"> ` </code>can be used to overrule the failure of a subexpression.
The tilde<code AAA="aaa"> ~ </code>negates failure and success.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote pech="C"><pre>`!p &amp; !q             "do !p and then do !q"
!a:!p &amp; `!b | !c     "if !a matches !p do !b else do !c"
~!a                  "succeed if !a fails and fail if !a succeeds"</pre></blockquote><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇐</span><a href="#binprotxt" style="line-height:12pt">Binary operators in program flow</a><br /><span class="arrow">⇒</span><a href="#pattxt" style="line-height:12pt">Binary operators in pattern matching</a><br /><span class="arrow">⇒</span><a href="#prostutxt2" style="line-height:12pt">Some often used control structures</a><br /><h1><a name="algtxt">Algebraic operations</a></h1><br ex="EX2" /><dl DEF="def"><dt>addition</dt><dd>   <i>term</i><code AAA="aaa"> + </code><i>term</i></dd><dt>multiplication</dt><dd>   <i>factor</i><code AAA="aaa"> * </code><i>factor</i></dd><dt>exponentiation</dt><dd>   <i>base</i><code AAA="aaa"> ^ </code><i>exponent</i></dd><dt>logarithm</dt><dd>   <i>base</i><code AAA="aaa"> \L </code><i>expr</i></dd><dt>differentiation</dt><dd>
   <i>variable</i><code AAA="aaa"> \D </code><i>expr</i></dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Subtraction and division are treated as special forms of addition and
multiplication. Therefore there are no binary operators for subtraction and
division. (The minus sign <code FFF="fff">-</code> and the slash <code FFF="fff">/</code> can be used in numbers, however.)<br ex="ENDEX2" /><br /><br /><br ex="EX2" />If one operand of an algebraic operator is evaluated then the other one is
normally evaluated as well, even if this may seem unnecessary (multiplication
by 0). This is done to ensure that all side effects take place as intended.
However, if an operand fails to evaluate then the algebraic expression fails
too and if the failing operand is the left hand side of the expression, then
the right hand side is not evaluated. In this sense algebraic operators behave
like the logical<code AAA="aaa"> &amp; </code>operator.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat gives the user practically NO control over the format of evaluated
algebraic expressions, such as the order of terms or factors. Bracmat tries to
present algebraic objects in a unique (canonical) form. This is in many cases
an unattainable goal : the forms<blockquote good="GOOD1"><pre>   (a+b)*(c+d)</pre></blockquote><dl DEF="def"><dt>and</dt><dd>  <code AAA="aaa"> a*c+a*d+b*c+b*d</code></dd><dt>are both stable expressions. On the other hand,</dt><dd>  <code AAA="aaa"> (a+b)*(c+d)+e</code></dd><dt>becomes</dt><dd>
  <code AAA="aaa"> e+a*c+a*d+b*c+b*d</code></dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat keeps "expensive" completely factorised expressions, but does not
automatically factorise factorisable expressions. Another domain of duality
are expressions with logarithms.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Sums and products start with rational numbers, followed by <code FFF="fff">pi</code>, <code FFF="fff">i</code> and <code FFF="fff">e</code>
(if present, that is). Then follow other terms and factors. It is recommended
not to assume anything about the ordering of these terms and factors, as
this may change in later versions of the program.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇐</span><a href="#difftxt" style="line-height:12pt">Differentiation</a><br /><h1><a name="difftxt">Differentiation</a></h1><br ex="EX2" /><i>variable</i><code AAA="aaa"> \D </code><i>expr</i><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat knows how to differentiate expressions in which no other binary
operators occur but<code AAA="aaa"> + </code><code AAA="aaa">* </code><code AAA="aaa">^ </code>and<code AAA="aaa"> \L.</code>
Example:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} y\Dx\D(a^(x^2+y^2))
{!} 4*a^(x^2+y^2)*x*y*e\La^2
{?} y\Dr
{!} 0</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The last example gives zero, which in many applications isn't what we want.
Often, with <code FFF="fff">y</code> we express the <i>y</i>-component of a vector with length <i>r</i>, and <i>r</i>
consequently is a function of <i>y</i> (and the other components). We can solve this
as follows:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} dep=(r.x) (r.y) (r.z) {'dep' is a special variable}
{?} y\Dr
{!} y\Dr</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Now the expression is just left unevaluated. Later, you can substitute an
expression for <code FFF="fff">r</code> in terms of its components<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} y\D(r^-1):?derivative
{!} -1*r^-2*y\Dr
{?} sub$(!derivative.r.(x^2+y^2+z^2)^1/2):?derivative
{!} -1*y*(x^2+y^2+z^2)^-3/2</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />And, if you like, you can simplify the result by putting <code FFF="fff">r</code> back in:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} sub$(!derivative.x^2+y^2+z^2.r^2):?derivative
{!} -1*r^-3*y</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇒</span><a href="#algtxt" style="line-height:12pt">Algebraic operations</a><br /><h1><a name="funmactxt">function evaluation</a></h1><br ex="EX2" />The binary operators<code AAA="aaa"> $ </code>and ' are similar in most respects. In general, the
left operand evaluates to the name of a built-in or defined function, whereas
the right operand is an expression that is passed as an argument to the
function. The<code AAA="aaa"> $ </code>evaluates the right operand before it is passed over, the '
doesn't. Parameter passing is by value, although the implementation postpones
and limits copying of data as much as possible. In the code of the called
function, the passed argument is bound to a local variable that is always
called arg.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Most often, the left operand of the<code AAA="aaa"> $ </code>and the ' operator evaluates to an alfa-
numeric name. There are a few special function names:<ul><li> No name at all. Here, the<code AAA="aaa"> $ </code>and the ' operator have decidedly different and
  complementary roles. (Forced evaluation of subexpressions in otherwise
  unevaluated expressions, such as patterns)</li><li> An integral number. (Array indexing.)</li><li> Only prefixes. (Prefix pasting or influencing success and failure of non-
  atomic expressions.)</li></ul><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Function calls are even effective in patterns, as it is fair to assume
that the<code AAA="aaa"> $ </code>and ' operators seldom occur in subjects and so need not to be
matched (the same is, a fortiori, true for the<code AAA="aaa"> &amp; </code>and<code AAA="aaa"> | </code>operators). In patterns,
the return value of a function is part of the pattern. A function may be
called several times during one evaluation of a matching expression, due to
backtracking and retrying.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><span class="arrow">⇒</span><a href="#macrotxt" style="line-height:12pt">macro evaluation</a><br /><span class="arrow">⇒</span><a href="#escappattxt" style="line-height:12pt">Escaping operator in patterns</a><br /><span class="arrow">⇒</span><a href="#naamloos" style="line-height:12pt">The "nameless" functions<code AAA="aaa"> $<i>expression</i> </code>and '<i>expression</i></a><br /><h1><a name="macrotxt">macro evaluation</a></h1><br ex="EX2" />The ' operator with empty lhs is the macro evaluator. The macro evaluator
returns the rhs unchanged, except where the<code AAA="aaa"> $ </code>operator (also with empty lhs)
occurs. The expressions headed by such<code AAA="aaa"> $ </code>operators are replaced as follows:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   '$$</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If the rhs is the<code AAA="aaa"> $ </code>operator with empty lhs, the macro evaluator replaces the
expression with the rhs of the heading<code AAA="aaa"> $, </code>and macro-evaluates the rhs of the
result.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} '(one dollar ($($)))
{!} =one dollar ()$
{?} '(two dollars ($($($($)))))
{!} =two dollars ()$($)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   '$_</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If the rhs is headed by the _ operator, the expression is replaced by the rhs,
where the dummy operator is evaluated to its current value.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (=a^b):(=?_?) &amp; '(dummy (a_b) power ($(a_b)))
{!} =dummy a_b power a^b</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />In all other cases the rhs is evaluated to a variable name, a member name or a
definition. The expression is thereafter replaced by the value of the variable,
the member of the definition.
More examples:<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} '(b+a c)
{!} =b+a c
{?} (x=value) &amp; '(a ($x) z)
{!} =a value z
{?} (object=(member=value)) &amp; '(a ($(object.member)) z)
{!} =a value z
{?} '(a ($(=value)) z)
{!} =a value z</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><span class="arrow">⇐</span><a href="#funmactxt" style="line-height:12pt">function evaluation</a><br /><span class="arrow">⇐</span><a href="#naamloos" style="line-height:12pt">The "nameless" functions<code AAA="aaa"> $<i>expression</i> </code>and '<i>expression</i></a><br /><span class="arrow">⇒</span><a href="#escappattxt" style="line-height:12pt">Escaping operator in patterns</a><br /><h1><a name="dumtxt">The dummy operator "_"</a></h1><br ex="EX2" />Bracmat has only 1 "variable" that binds to a binary operator, the "_"
operator. Worse even, this variable is global. Nevertheless this variable is
most useful in definitions of certain types of recursive functions
("tree walkers").<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The assignment of a new value to the "_" variable can only take place
in a match. A "_" in a pattern is always "receiving", whereas a "_"
outside a pattern is either "giving" or left unchanged. Try this :<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} a_b             { This has unpredictable results. }
{?} x^y:?_? &amp; a_b   { _ gets bound to ^. Thus a_b evaluates to a^b }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />A "_" is evaluated by the expression evaluator, but also by the macro
evaluator. The latter is useful if the "_" has matched an operator that is
very volatile, such as <code FFF="fff">&amp;</code> and <code FFF="fff">|</code>.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (=!a:!b&amp;!c):(=?left_?right) {match the "&amp;"}
{?} '_
{!} =&amp;              { It worked, the "_" is replaced by a "&amp;". }
{?} get$(str$('$_),MEM,VAP):"=" ?op &amp; !op { "freeze" and slice }
{!} &amp;               { The operator is immobilised in a string. }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The "_" variable is always expanded BEFORE the left and right hand side
operands are evaluated. That explains why new assignments in the operands do
not result in unwanted side effects in the upper node with the "_".<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇒</span><a href="#funtxt3" style="line-height:12pt">Recursion and the "_"-operator</a><br /><h1><a name="funtxt3">Recursion and the "_"-operator</a></h1><br ex="EX2" />In Bracmat functions are allowed to call themselves. Often this happens
if a the function's argument is split into a left subtree and a right
subtree and the function is called with each subtree in turn as its argument.
If the operator in between the subtrees is unknown, it is time consuming
to try all patterns<code AAA="aaa"> ?+? </code><code AAA="aaa">?*? </code><code AAA="aaa">?$? </code>?'? etc. The _ operator circumvents this
problem. It is a dummy operator that matches any other operator and
expands to the operator with which it matched last time. Thereby preceding
matches are "forgotten" : the _ operator is a global variable.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} ( reverse
    =   l,r
      .     (!arg:?l_?r)              { If arg is a compound expression ...}
          &amp; (reverse$!r)_(reverse$!l) { ... swap the reversed operands. }
        | !arg                        { Let atoms as they are. }
    )
{?} reverse$(Bill loves sweet Nancy. This is true)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binovztxt" style="line-height:12pt"><code AAA="aaa">=.,|&amp;: </code><code AAA="aaa">+*^\L\D'$_</code></a><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><span class="arrow">⇐</span><a href="#dumtxt" style="line-height:12pt">The dummy operator "_"</a><br /><span class="arrow">⇐</span><a href="#funtxt1" style="line-height:12pt"><code AAA="aaa"><i>function name</i>=<i>var1</i> </code><code AAA="aaa">[,<i>var2</i>, </code><code AAA="aaa">...].<i>function body</i></code></a><br /><h1><a name="prostutxt2">Some often used control structures</a></h1><br ex="EX2" />In the left column control structures are written in pseudocode, in the right
column the nearest equivalents are written in Bracmat.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   Sequence:</pre></blockquote><blockquote good="GOOD2"><pre>   a; b;                                  `!a &amp; !b { !b must be evaluated, even if !a fails }</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   Repetition:</pre></blockquote><blockquote good="GOOD1"><pre>   WHILE a DO b;                           whl'(!a &amp; !b);</pre></blockquote><blockquote good="GOOD4"><pre>   DO b WHILE a;                           whl'(!b &amp; !a);</pre></blockquote><blockquote good="GOOD1"><pre>   DO b UNTIL a;                           whl'(`!b &amp; ~!a);</pre></blockquote><blockquote good="GOOD4"><pre>   FOR i := m TO n DO b;                   !m:?i &amp; whl'(!i:~&gt;!n &amp; `!b &amp; 1+!i:?i);</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   Selection:</pre></blockquote><blockquote good="GOOD1"><pre>   IF a THEN b ELSE c;                    !a &amp; `!b | !c;</pre></blockquote><blockquote good="GOOD4"><pre>   v := IF a THEN b ELSE c;               (!a &amp; `!b | `!c) : ?v  {works even if !c fails}</pre></blockquote><blockquote good="GOOD1"><pre>   SELECT  a                              !a : (!c1 &amp; `!b1 | !c2 &amp; `!b2 |? &amp; !bx);</pre></blockquote><blockquote good="GOOD4"><pre>   WHEN  c1 : b1</pre></blockquote><blockquote good="GOOD1"><pre>   WHEN  c2 : b2</pre></blockquote><blockquote good="GOOD4"><pre>   OTHERWISE  bx;                         { the ? matches anything }</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   Branching:</pre></blockquote><blockquote good="GOOD1"><pre>   CALL a;                                !a;</pre></blockquote><blockquote good="GOOD4"><pre>   CALL b(x,y,z);                         b$(x,y,z);</pre></blockquote><blockquote good="GOOD2"><pre>   v := b(x,y,z);                         b$(x,y,z) : ?v;</pre></blockquote><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇐</span><a href="#binprotxt" style="line-height:12pt">Binary operators in program flow</a><br /><span class="arrow">⇐</span><a href="#prostutxt1" style="line-height:12pt">Program flow</a><br /><h1><a name="naamloos">The "nameless" functions<code AAA="aaa"> $<i>expression</i> </code>and '<i>expression</i></a></h1><br ex="EX2" />Sometimes a variable predictably will evaluate to the same value repeatedly,
for example in an inner loop or a pattern that repeatedly backtracks. In
such situations macro substitution can improve performance by replacing the
variable by its value in an early stage.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />In Bracmat, a macro has the general form '<i>expression</i>. When '<i>expression</i> is
evaluated, <i>expression</i> is searched for sub-expressions headed by the operator
<code AAA="aaa">$, </code>with empty lhs. Such sub-expressions are replaced, depending on what is
found on the rhs of the<code AAA="aaa"> $ </code>operator.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />After macro substitution has taken place, what remains is an expression of
the form<code AAA="aaa"> =<i>expression</i>. </code>The<code AAA="aaa"> = </code>operator is a safeguard against evaluation of
<i>expression</i>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Macro substitution makes it possible to dynamically create unevaluated code and
bind it to a variable.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} '($out):?my-fun-var
{?} !my-fun-var$(Hello world)
{?} '($out):(=?my-fun-alias)
{?} my-fun-alias$(Hello world)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Pattern matching can sometimes be made more efficient by using macro
substitution, but the resulting code is harder to understand:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} ( 0:?count
    &amp;   41 3 5 7 6 23 12 11 19
      :   ?
          %?`A
          ?
          ( %?`B                            {Each number pair [A,B] ... }
          &amp; !A+!B:?C                        {is added only once, giving C. }
          &amp;   '(? ()$(!count+1:?count&amp;C) ?)
            : (=?rem)                       {C's value is hard-coded into rem}
          )
          !rem                              {which is the remaining pattern. }
    &amp; out$(after !count "trials:" !A "+" !B "=" !C )
    )</pre></blockquote><br ex="ENDEX" /><br ex="EX2" />after 16 trials: 5<code AAA="aaa"> + </code>7<code AAA="aaa"> = </code>12<br ex="ENDEX2" /><br /><br /><br ex="EX2" />In the same way, function code can be pieced together before it is ever
executed.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} power=three
{?} ((!power : two &amp; (=!arg^2)) | (=!arg^3)) : (=?abc)      {If power="two",
    abc is bound to !arg^2 (unevaluated). Otherwise, abc is bound to !arg^3.}
{?} '(.!arg + -1*$abc + 2) : (=?poly) {"poly" is the name of a new function
    that will return a value that depends on the current value of arg
    and on the value of power at the time when abc got its binding.}
{?} lst$poly { show poly's definition }
{?} poly$4
{!} -58</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The macro construct '<i>expr</i> is useful if an expression has to be executed
many times while parts of it remain constant, for example in nested loops:<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Without macro construct (5 X 5 multiplication table) :<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 0 : ?m                    { initialise counter of outer loop }
{?} (outer = 1+!m : &lt;6 : ?m   { code for outer loop : }
            &amp; put$\n          { start output on new line }
            &amp; 0 : ?n          { initialise counter of inner loop }
            &amp; `!inner         { execute inner loop }
            &amp; !outer)         { loop }
{?} (inner = 1+!n : &lt;6 : ?n   { code for inner loop : }
           &amp; put$(!m X !n "=" !m*!n ", ")
                              { the same !m is expanded 10 times }
           &amp; !inner)          { loop }
{?} !outer</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />With macro construct :<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 0:?m
{?} (outer = 1+!m : &lt;6 : ?m
            &amp; '( 1+!n : &lt;6 : ?n
               &amp; put$($m X !n "=" ()$m*!n ",")
                              { !m is expanded only 2 times }
               &amp; !inner
               ) : (=?inner)  { at each pass through the outer loop
                                the inner loop "inner" is defined anew }
            &amp; put$\n
            &amp; 0 : ?n
            &amp; `!inner
            &amp; !outer)
{?} !outer</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#binmenu" style="line-height:12pt">Binary operators</a><br /><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><span class="arrow">⇐</span><a href="#funmactxt" style="line-height:12pt">function evaluation</a><br /><span class="arrow">⇒</span><a href="#macrotxt" style="line-height:12pt">macro evaluation</a><br /><h1><a name="unopsmenu">Prefixes</a></h1><br ex="EX2" /><br ex="ENDEX2" /><dl><dt><a href="#unstuurtxt"> program flow</a></dt><dt><a href="#unpattxt"> pattern matching</a></dt><dt><a href="#unpattxt"> prefixes combined with expressions</a></dt><dt><a href="#unops"> unary operators</a></dt></dl><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="unstuurtxt">Prefixes and program flow</a></h1><br ex="EX2" />Unlike other programming languages, Bracmat does not return the value of a
variable or object member if we type its name. In Bracmat, variables and
object members have to be told explicitly that we want their value, not their
name. This is achieved with the<code BBB="bbb"> ! </code>and the<code BBB="bbb"> !! </code>prefixes in front of the variable
name or object member name.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt>!<i>atom</i></dt><dd>   is replaced by the binding of <i>atom</i></dd><dt>!!<i>atom</i></dt><dd>
   is replaced by the binding of the binding (after evaluation) of <i>atom</i></dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Likewise<code BBB="bbb"> !(<i>object name</i>.<i>member name</i>) is replaced by the binding</code>
of <i>object name</i>.<i>member name</i><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bindings can be evaluated or unevaluated. In the last case, the next step after
expansion is the evaluation of the binding, unless expansion took place within
a pattern.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 2+3:?four     { bind 5 to "four" }
{?} !four         { evaluation has already taken place when four is expanded }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 5=2+!four     { numbers are legal names. 5 is bound to 2 + !four}
{?} !5            { evaluation takes place immediately after expansion }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} sum=%+%       { define pattern "sum" }
{?} a+b+c:!sum    { is a+b+c a sum? After expansion, %+% is not evaluated }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The<code BBB="bbb"> !! </code>prefix is not used as often as the single<code BBB="bbb"> !, </code>but comes in handy if you
want to pass a variable by name instead of by value.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (check=one,two,criterion
      .     !arg:(?one,?criterion,?two)
          &amp; !!criterion
          &amp; TRUE
        | FALSE
    )
{?} is-greater-than = !one:&gt;!two
{?} is-divisor-of = (div$(!two,!one)*!one):!two
{?} check$(3,is-greater-than,15)  { pass by name }
{?} check$(3,is-divisor-of,15)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Passing by name is used here to postpone the evaluation of the second argument
until it has arrived in the function check and the local variables "one" and
"two" have been bound to the first and the third arguments, respectively.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Postponement of evaluation can also be achieved with the<code AAA="aaa"> = </code>and the '
operators.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (chack=one,two,criterion
      .    !arg:(?one,(=?criterion),?two)
         &amp; !criterion
         &amp; TRUE
       | FALSE
    )
{?} is-greater-than == !one:&gt;!two                  { an extra = }
{?} is-divisor-of ='((div$(!two,!one)*!one):!two)  { an extra ' }
{?} chack$(3,!is-greater-than,15)  { pass by value }
{?} chack$(3,!is-divisor-of,15)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#unopsmenu" style="line-height:12pt">Prefixes</a><br /><h1><a name="unpattxt">Prefixes and pattern matching</a></h1><br ex="EX2" />In patterns, atoms and expressions within parentheses may be preceded by
prefixes that control the matching process.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code FFF="fff">!</code> and <code FFF="fff">!!</code></dt><dd>   in front of an non-nil atom or an expression denoting a member of an
   object causes expansion of the atom or the member to its direct or
   indirect binding. This binding is matched with the subject.</dd><dt><code FFF="fff">`</code></dt><dd>   causes backtracking if the pattern did not successfully unify with a
   non-trivial element of the subject-list. A list is an expression
   consisting of terms (<code FFF="fff">+</code> operator), factors (<code FFF="fff">*</code> operator) or words
   (white-space operator). Trivial elements are 0 in a sum, 1 in a product
   and a word without characters in a list of words. In non-sophisticated
   patterns, <code FFF="fff">`</code> means simply : unify with at most one non-trivial element.
   Zero non-trivial elements are allowed, in which case unification takes
   place with an implicit trivial element: Bracmat sees 0's everywhere in a
   sum, 1's in a product and zero length words in a sentence.</dd><dt><code FFF="fff">?</code></dt><dd>   unifies with anything. If<code BBB="bbb"> ? </code>is followed by a non-nil atom denoting a
   variable or an expression denoting a member of an object, then the matched
   part of the subject is captured by this variable or member. In other
   words, pattern matching can have assignment as a side-effect.</dd><dt><code FFF="fff">@</code></dt><dd>   unifies only with atoms.</dd><dt><code FFF="fff">%</code></dt><dd>   causes the match to succeed only with one or more non-trivial elements of
   the subject-list. (Exception: in combination with <code FFF="fff">[</code> prefix).</dd><dt><code FFF="fff">&lt;</code></dt><dd>   unifies only with atoms that are "less" than the atom following the <code FFF="fff">&lt;</code>
   prefix.</dd><dt><code FFF="fff">&gt;</code></dt><dd>   unifies only with atoms that are "greater" than the atom following the <code FFF="fff">&gt;</code>
   prefix.</dd><dt><code FFF="fff">#</code></dt><dd>   unifies only with rational numbers.</dd><dt><code FFF="fff">/</code></dt><dd>   unifies only with non-integer rational numbers.</dd><dt><code FFF="fff">~</code></dt><dd>   constrains the match to subjects that are not equal to the atom following
   the<code AAA="aaa"> ~ </code>prefix.</dd><dt><code FFF="fff">[</code></dt><dd>   Position prefix. Must be followed by an expression that evaluates to a
   number (For example <code FFF="fff">[4</code> or <code FFF="fff">[(!pos+3)</code> ) or by a variable having a question
   mark as in <code FFF="fff">[?pos</code>. In the first case, the pattern cannot succeed unless the
   element following the<code AAA="aaa"> [ </code>element is at the indicated position. The <code FFF="fff">[</code>
   element itself does not occupy a position; it sits in front of the
   indicated position. The second form is for querying the current position.
   Position 0 is the start of the subject. Positive positions count from the
   beginning of the subject, negative positions from the end. Position -1 is
   the position following the last element. (When combined with <code FFF="fff">%</code> the
   meaning is different.)</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The above prefixes may be combined. The ordering in which they are input by the
user is irrelevant; Bracmat keeps prefixes in this order :<blockquote good="GOOD1"><pre>   [ ~ / # &lt; &gt; % @ ` ? ! !!</pre></blockquote>Repeating prefixes in front of the same atom does not convey a new meaning to
the pattern, except for the <code FFF="fff">!</code> and the <code FFF="fff">~</code> prefixes. More than one <code FFF="fff">!</code> is
interpreted as the <code FFF="fff">!!</code> prefix. An odd number of <code FFF="fff">~</code> is treated as a single <code FFF="fff">~</code>, an
even number thereof is treated as none. A <code FFF="fff">~</code> in front of other prefixes negates
the first of them. The most useful combinations are:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code FFF="fff">?!</code></dt><dd>   in front of an atom causes the atom to be expanded to its binding.
   This binding is treated as a variable name.</dd><dt><code FFF="fff">?!!</code></dt><dd>   is like<code BBB="bbb"> ?!, </code>but expands two levels deep (with an evaluation of the
   first level expansion), instead of one.</dd><dt /><dd>   is like a solitary<code AAA="aaa"> ~.</code></dd><dt><code FFF="fff">/5/6</code></dt><dd>   unifies only with non-integer rational numbers unequal to 5/6.</dd><dt><code FFF="fff">~&lt;</code></dt><dd>   means "greater or equal" ("not less").</dd><dt><code FFF="fff">~&gt;</code></dt><dd>   means "less or equal".</dd><dt><code FFF="fff">~</code></dt><dd>   means "not different", i.e. "the same, in some sense". Strings
   are compared case insensitive. This applies to the full Unicode
   table, but defaults to ASCII and the upper 128 characters in the
   ISO8859-1 (Latin 1) character set if the characters are not UTF-8
   encoded.</dd><dt><code FFF="fff">~#</code></dt><dd>   does not unify with rational numbers.</dd><dt><code FFF="fff">~/</code></dt><dd>   does not unify with non-integer rational numbers.</dd><dt><code FFF="fff">~/#</code></dt><dd>   unifies only with integer numbers.</dd><dt><code FFF="fff">~/#&lt;9</code></dt><dd>   unifies only with integer numbers less than 9.</dd><dt><code FFF="fff">~/#0</code></dt><dd>   unifies only with non-zero integer numbers.</dd><dt><code FFF="fff">~@</code></dt><dd>   unifies only with non-atomic expressions.</dd><dt><code FFF="fff">~`</code></dt><dd>   backtrack immediately.</dd><dt><code FFF="fff">[%</code></dt><dd>   The current subject is stored in the variable <code FFF="fff">sjt</code> and the expression
   carrying this prefix combination is evaluated. If the evaluation succeeds,
   the match succeeds and vice versa. The subject can be a trivial element of
   the subject list.</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Many of these combinations can be combined further, e.g.<code AAA="aaa"> ~/#?!! </code>accepts only
an integer number and binds it to the indirect binding of the atom following
the prefixes.<br ex="ENDEX2" /><br /><br /><br PECH="PECH" /><br ex="EX2" />If you want to match pattern<code BBB="bbb"> !pat </code>one or more times (this is often written as
<code AAA="aaa">{pat}+ </code>), use the complex pattern <code FFF="fff">(? !pat|`)</code>. Likewise, if you want to match
!pat zero or more times (<code AAA="aaa"> {pat}* </code>), use <code FFF="fff">(|? !pat|`)</code>.
These patterns should not be the last sub-pattern or precede a subpattern that
is static and fixes the end point of the repeating sequence, because the
correct working of the repeating patterns depends on repeated backtracking
from following sub-patterns. Bracmat may be optimized to skip such
backtracking and jump to the 'right' end position if that is fixed by the next
subpattern.
In the last resort, you can add a pattern like <code FFF="fff">()</code> or <code FFF="fff">(&amp;)</code> or <code FFF="fff">(|)</code> or <code FFF="fff">(:)</code>, which
match with an empty list only (assuming that the connecting nodes are spaces,
otherwise use 0 in the case of a sum and 1 in the case of a product). Such
patters don't fix the next position.
Example:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} a a a c c:(? a|`) (|? b|`) (? c|`) (&amp;) { {a}+ {b}* {c}+ }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The following expression succeeds, because the subpattern doesn't confront the
substring aaak.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} @(aaakamcccc:(? a|`) m (|? b|`) (? c|`)) (&amp;)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />An empty string before the m has the effect that Bracmat doesn't optimize
the backtracking process away.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} @(aaakamcccc:(? a|`) () m (|? b|`) (? c|`)) (&amp;)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#unopsmenu" style="line-height:12pt">Prefixes</a><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇐</span><a href="#pattxt" style="line-height:12pt">Binary operators in pattern matching</a><br /><span class="arrow">⇒</span><a href="#escappattxt" style="line-height:12pt">Escaping operator in patterns</a><br /><h1><a name="unops">minus sign</a></h1><br ex="EX2" />The minus sign <code FFF="fff">-</code> has only its normal arithmetic meaning when used as an
unary operator in front of a rational number or the imaginary number <code FFF="fff">i</code>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />If a product contains both a rational number and the number <code FFF="fff">i</code>, the <code FFF="fff">i</code>
takes precedence in accepting a minus sign:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>                  -7*i*a</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />is evaluated to   <code AAA="aaa"> 7*-i*a.</code><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The advantage of having both <code FFF="fff">i</code> and <code FFF="fff">-i</code> becomes clear by considering
the following:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>                  (-1*i)^1/3</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />evaluates to      <code AAA="aaa"> (-i)^1/3,</code><br ex="ENDEX2" /><br /><br /><br ex="EX2" />which is written as<code AAA="aaa"> -i^1/3. </code>As expected, this is the complex conjugate of<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>                   i^1/3.</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If Bracmat did not have a separate representation for <code FFF="fff">-i</code>, then<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD3"><pre>                  (-1*i)^1/3</pre></blockquote>would evaluate to <code FFF="fff">i</code>,<br ex="ENDEX2" /><br /><br /><br ex="EX2" />(because<code AAA="aaa"> i^3 </code>is equal to <code FFF="fff">-i</code>),which means that Bracmat would not consider
<code AAA="aaa">(-1*i)^1/3 </code>and<code AAA="aaa"> i^1/3 </code>as complex conjugates.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The transcendental numbers <code FFF="fff">e</code> and <code FFF="fff">pi</code> do not accept arithmetic minus signs.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#unopsmenu" style="line-height:12pt">Prefixes</a><br /><h1><a name="atotxt">strings or atoms</a></h1><br ex="EX2" />A string in Bracmat is the same as an "atom". If you envisage a Bracmat
expression as a tree like structure, atoms or strings are to be found in the
leafs. In Bracmat terminology, an empty leaf is syntactically represented
by <i>nil</i>. <i>nil</i> is not an <i>atom</i> proper, but an <i>atom-or-nil</i>. So not every
leaf contains an atom. On the other hand, leafs may contain other things
besides <i>atoms</i>, such as prefixes.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />In Bracmat, atoms are less accessible than trees. Therefore there are some
ways to convert atoms to trees and back.<ol><li> Conversion between an atom and its constituent characters:<ul><li><code AAA="aaa"> get$(<i>atom</i>,MEM,VAP)</code> puts every character in the literal <i>atom</i> in its own
    leaf in a tree, which has space-operators in every node.</li><li><code AAA="aaa"> str$<i>tree</i> </code>does more or less the inverse.</li></ul></li><li> Conversion between an atom and executable Bracmat code:<ul><li><code AAA="aaa"> get$(<i>atom</i>,MEM)</code> literally "reads" an atom as though it is a file with
    Bracmat expressions.</li><li><code AAA="aaa"> lst$(<i>variable</i>,MEM)</code> "writes" the expression that is bound to <i>variable</i>
    to an atom.</li></ul></li></ol><p><br ex="EX2" />Atoms can be used as names for variables, functions, files, etc.. Often they
are used as literals, such as mathematical symbols or text.<br ex="ENDEX2" /></p><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Most characters which the computer knows of can be members of an atom. Only
the first seven characters in the ASCII character set are forbidden. These
characters are used by the system. In most cases you don't need quotation marks
in order to get a string of characters into an atom. You do need them if you
want parentheses, operators or prefixes to be part of an atom. Some special
characters have to be preceded by a back slash:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code AAA="aaa">\a</code></dt><dd>   attention (bell)</dd><dt><code AAA="aaa">\b</code></dt><dd>   backspace</dd><dt><code AAA="aaa">\t</code></dt><dd>   tab</dd><dt><code AAA="aaa">\n</code></dt><dd>   new line</dd><dt><code AAA="aaa">\v</code></dt><dd>   vertical tab</dd><dt><code AAA="aaa">\f</code></dt><dd>   form feed</dd><dt><code AAA="aaa">\r</code></dt><dd>   carriage return</dd><dt><code AAA="aaa">\\</code></dt><dd>   back slash</dd><dt><code AAA="aaa">\"</code></dt><dd>
   double quote</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If you precede a string with the prefix<code AAA="aaa"> @, </code>then back slashes are treated as
normal characters. E.g.<code AAA="aaa"> sys$@"C:\dos\edit".</code>
In stead of the tab and new line characters above, you may enter tabs and
new lines by pressing the tab and the return key, respectively.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Examples:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} this is a "tree" with\nsix leafs
{?} (this is a "tree" with
      seven leafs)
{?} "this" has 4 characters and "" (nil) none
{?} "this is an \"atom\" with 36 characters"
{?} "this string\nno verb"
{?} "this string</pre></blockquote><br ex="ENDEX" /><br ex="EX2" />no verb either"<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} "if zero equals one, I hang up" = "1:0&amp;get$(\")y\",MEM)"
{?} get$(!"if zero equals one, I hang up",MEM)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="varsmenu">Symbols</a></h1><br ex="EX2" /><br ex="ENDEX2" /><dl><dt><a href="#varmattxt"> literals</a></dt><dt><a href="#varprotxt"> variables</a></dt></dl><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="varmattxt">Literals</a></h1><br ex="EX2" />In Bracmat, symbols have only literal meaning, unless we explicitly state that
we want a symbol to behave like a programming variable. Contrary to most
computer languages, Bracmat evaluates an expression with literals not by
expanding these literals to their associated values (if they have any) and
computing with these values until a result is obtained, but by rearranging
and transforming the expression until a stable form is reached.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} a + a
{?} i*i
{?} e^(19/2*pi*i)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />In Bracmat, the context of a symbol decides whether it is treated as a
variable or as a literal. So it is not necessary to "kill" a variable in order
to use its symbol as a literal, the two uses live peacefully together.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} i=2   { variable i is bound to the literal "2" }
{?} !i^2  { the associated value of i is squared }
{?} i^2   { the literal "i" (a special one, like "pi" and "e") is squared }
{?} 7 = prime { the variable 7 is bound to the literal "prime"}
{?} 7 is !7 { the symbol 7 is used as both a literal and a variable}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#varsmenu" style="line-height:12pt">Symbols</a><br /><h1><a name="varprotxt">Variables</a></h1><br ex="EX2" />Variables are represented by <i>atom</i>'s, but not all <i>atom</i>'s are variables.
The context of a symbol determines whether it is a variable or not :<ol><li>the left operand of the<code AAA="aaa"> = </code>operator, unless this operand has zero length.</li><li>the atom following the<code BBB="bbb"> ! </code>and<code BBB="bbb"> !! </code>prefixes</li><li>within a pattern, a non-zero length atom following the<code BBB="bbb"> ? </code>prefix</li><li>the left operand of the<code AAA="aaa"> $ </code>and ' operators</li><li>the right operand of the<code AAA="aaa"> $ </code>operator in macro constructs (e.g.<code AAA="aaa"> '(1+$a) </code>).</li></ol><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#varsmenu" style="line-height:12pt">Symbols</a><br /><h1><a name="evaltxt">The four evaluators</a></h1><br ex="EX2" />In Bracmat, a binary operator may have four different effects, depending on
the context of the operator. For each of these contexts there is one evaluator.
Of these four evaluators, the macro evaluator is relatively unimportant.
The four evaluators are :<ol><li> the expression evaluator, which takes care for the transformations of
   expressions.</li><li> the match evaluator, which handles the unification of pattern expressions
   with subject expressions.</li><li> the macro evaluator, which merely substitutes certain parts of an
   expression.</li><li> the archivist, which doesn't do anything but keeping expressions alive.</li></ol><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The expression evaluator is the first evaluator that a newly input expression
is confronted with. If necessary, it delegates tasks to one of the other three
evaluators.
The match evaluator can only delegate tasks to the expression evaluator and to
the archivist.
The macro evaluator can only delegate tasks to the expression evaluator.
The archivist doesn't delegate any tasks to other evaluators.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The cross link is in most cases a binary operator. The exceptions to this rule
are in the context of the match evaluator: some (combinations of) prefixes
involve the expansion of a chain of variable bindings and all but the last
subexpansion demand the expression evaluator.
In the scheme below, you'll find the "current" evaluator in the left column
and the successor evaluators in the top row. A cross link is represented by the
relevant operator or prefixes. If the change of evaluator only applies to the
left (right) operand of the cross link operator, the symbol "l" ("r") is used.
If the transition depends on the left operand being <i>nil</i>, the symbol "n" is
used.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>            expression       match            macro            archivist</pre></blockquote><blockquote good="GOOD1"><pre>expression                   :r               n'r              =r 'r</pre></blockquote><blockquote good="GOOD4"><pre>match       &amp;r $ 'l ?! !!                     n'r              =r 'r</pre></blockquote><blockquote good="GOOD1"><pre>macro       $r</pre></blockquote><blockquote good="GOOD4"><pre>archivist</pre></blockquote><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="progsmenu">Programming advice</a></h1><br ex="EX2" /><br ex="ENDEX2" /><dl><dt><a href="#prostutxt1"> program flow</a></dt><dt><a href="#pattxt"> pattern matching</a></dt><dt><a href="#contxt"> data structures</a></dt><dt><a href="#debugtxt"> debugging</a></dt></dl><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="debugtxt">Debugging</a></h1><br ex="EX2" />If a program written in the Bracmat language doesn't work properly, the
same debugging protocol applies as with other programming languages :<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><ul><li> Test extensively, above all with absurd and trivial input, in order to
  locate the pain in the many limbs of your program code.</li><li> Create watch points by inserting<code AAA="aaa"> out$ </code>instructions at sensible places
  (entry and exit points of functions, branches, before and after assignments).</li><li> If you are in doubt whether Bracmat has interpreted your program in the way
  you intended, use<code AAA="aaa"> lst$(<i>function-name</i>,<i>file-name</i>) </code>and inspect the
  code that is output into <i>file-name</i>.</li><li> Errors that are easily made are :<ul><li> Forget that Bracmat may see trivial elements (0 terms, 1 factors, zero
    length words) at places where this is not what you intend. Are all
   <code AAA="aaa"> % </code><code AAA="aaa">` </code>and<code AAA="aaa"> @ </code>prefixes in place?</li><li> Forget the grouping of operators.
    <code FFF="fff">a b c : ?%x ?%y</code>  is grouped as <code FFF="fff">(a b c):(?%x ?%y)</code> , but
    <code FFF="fff">a,b,c : ?%x,?%y</code>  is grouped as <code FFF="fff">a,b,(c:?%x),?%y</code>
    Remember that <code FFF="fff">=</code> and <code FFF="fff">.</code> have very low priorities, often making a pair of
    parentheses necessary.</li><li> A misconceived idea about the Bracmat's backtracking mechanism. Unlike
    other languages with backtracking capabilities, Bracmat does not offer
    suspend/resume cycles. An expression embodying alternatives does not
    successively produce each alternative on every evaluation.</li></ul></li></ul><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇒</span><a href="#debugtxt2" style="line-height:12pt">using<code AAA="aaa"> out$ </code>as debugging aid</a><br /><h1><a name="debugtxt2">using<code AAA="aaa"> out$ </code>as debugging aid</a></h1><br ex="EX2" />The best aid in finding out what a program does, is using the<code AAA="aaa"> out$ </code>function.
The following code is part of a function that computes n! .<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> loop = !k+1 : ?k          { increment k }</pre></blockquote><blockquote good="GOOD1"><pre>             : &lt;!n         { compare (old) k+1 with n; if not less, stop }</pre></blockquote><blockquote good="GOOD4"><pre>      &amp; !fac*!k : ?fac     { multiply fac with k }</pre></blockquote><blockquote good="GOOD2"><pre>      &amp; !loop              { repeat until k = n }</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Outside patterns<code AAA="aaa"> out$ </code>is most easily used. Inside patterns, if you want to
inspect a variable that has just been assigned a new value, you use the<code AAA="aaa"> &amp;</code>
operator to temporarily escape into the non-pattern world. If you want to add
extra text to the output, remember that the atgument to<code AAA="aaa"> out$ </code>is returned.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> loop = out$!k+1 : (?k &amp; out$(k is !k)) {show k before and after increment}</pre></blockquote><blockquote good="GOOD1"><pre>                 : &lt;!n                  {but before comparison with n}</pre></blockquote><blockquote good="GOOD4"><pre>      &amp; out$("new fac is:" (!fac*!k:?fac)) {show fac after computation}</pre></blockquote><blockquote good="GOOD1"><pre>      &amp; out$(still need !n+-1*!k loops) {you don't always need quotation marks}</pre></blockquote><blockquote good="GOOD4"><pre>      &amp; !loop</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Now an example that is faulty. The purpose is to find two equal words in a
sentence. This expression succeeds, but finds nothing:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> (He loves her and she loves him : (? ?a ? !a ?) &amp; out$(!a is occurring twice))</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Check what is unified with <code FFF="fff">? ?a</code>. To do so, put a variable after the first
<code FFF="fff">?</code> and insert an output action after each sub-pattern.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> (He loves her and she loves him</pre></blockquote><blockquote good="GOOD1"><pre>     : ((?x &amp; out$(x is !x))   {output x after unification}</pre></blockquote><blockquote good="GOOD4"><pre>       (?a &amp; out$(a is !a))    {output a after unification}</pre></blockquote><blockquote good="GOOD1"><pre>       ? !a ?)                 {the remainder of the pattern}</pre></blockquote><blockquote good="GOOD4"><pre>     &amp; out$(!a is occurring twice)</pre></blockquote><blockquote good="GOOD1"><pre> )</pre></blockquote>The program would have to backtrack several times until<code BBB="bbb"> ?a </code>was unified with
"loves", but the match succeeds with<code BBB="bbb"> ?a </code>unified with the omnipresent zero
length word. A<code AAA="aaa"> % </code>sign avoids this. A back quote<code AAA="aaa"> ` </code>helps speeding up, since it
avoids multi-word assignments and forces immediate backtracking.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> (He loves her and she loves him</pre></blockquote><blockquote good="GOOD1"><pre>     : ((?x &amp; out$(x is !x))  { Watch the number of words in ?x grow ... }</pre></blockquote><blockquote good="GOOD4"><pre>       (%`?a &amp; out$(a is !a)) { while ?a moves towards "loves". }</pre></blockquote><blockquote good="GOOD1"><pre>       ? !a ?)                { There backtracking stops }</pre></blockquote><blockquote good="GOOD4"><pre>     &amp; out$(!a is occurring twice) { and the message is output. }</pre></blockquote><blockquote good="GOOD2"><pre> )</pre></blockquote><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><span class="arrow">⇐</span><a href="#debugtxt" style="line-height:12pt">Debugging</a><br /><span class="arrow">⇐</span><a href="#outtxt" style="line-height:12pt"><code AAA="aaa">out$<i>expression</i></code></a><br /><span class="arrow">⇒</span><a href="#debugtxt3" style="line-height:12pt">using <code FFF="fff">dbg'</code> as debugging aid</a><br /><h1><a name="debugtxt3">using<code AAA="aaa"> |_dbg'_| </code>as debugging aid</a></h1><br ex="EX2" />Some programming errors may be found with the built-in <code FFF="fff">dbg</code> function. The
argument of the <code FFF="fff">dbg</code> function is evaluated with an internal debugging flag set.
With this flag set, suspicious code is warned against.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />It is important that the argument is not evaluated before being passed to the
<code FFF="fff">dbg</code> function.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#progsmenu" style="line-height:12pt">Programming advice</a><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><span class="arrow">⇐</span><a href="#debugtxt2" style="line-height:12pt">using<code AAA="aaa"> out$ </code>as debugging aid</a><br /><h1><a name="funcmenu">functions</a></h1><br ex="EX2" /><br ex="ENDEX2" /><dl><dt><a href="#funmactxt"> function evaluation</a></dt><dt><a href="#funtxt1"> defining functions</a></dt><dt><a href="#naamloos"> nameless functions</a></dt><dt><a href="#lambda"> lambda abstractions, currying</a></dt><dt><a href="#inbltmenu"> built-in functions</a></dt><dt><a href="#predefmenu"> predefined, changeable functions</a></dt></dl><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="funtxt1"><code AAA="aaa"><i>function name</i>=<i>var1</i> </code><code AAA="aaa">[,<i>var2</i>, </code><code AAA="aaa">...].<i>function body</i></code></a></h1><br ex="EX2" />Definition of a function. <i>var1</i>,<i>var2</i>, etc. are explicitly declared local
variables. A function is called by
<code AAA="aaa"><i>function name</i>$<i>argument expression</i> </code>or
<i>function name</i>'<i>argument expression</i> ,
depending on whether <i>argument expression</i> must be evaluated<code AAA="aaa"> ($) </code>or not (')
before it is passed to the function in the always present local variable
"arg".
The returned value of a function is simply the function body after it
has been evaluated.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} square=.!arg^2 {definition}
{?} square$5            {call}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (swap = a,b            {declare local variables a and b}
        .   (!arg:(?a,?b)) {dissect arg to find the "real" arguments}
         &amp; (!b,!a))        {swap and return}
{?} swap$(I think,I guess)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />In a match context, a function call creates a second local variable,
<code FFF="fff">sjt</code>, the current subject. The value returned from a function in a match
context is interpreted as a pattern by the match evaluator. However, if the
function call fails, the pattern match is not attempted and fails as well.
If the returned value is negated the behaviour is not defined.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} ( like
    =
      .   sim$(!arg,!sjt):&gt;9/10 &amp; ?
        |   den$(sim$(!sjt,)):~&lt;(den$(sim$(!arg,0)))
          &amp; ~`
    )
{?} @( "Dogs and Cats are my enemies": ? like$cat ?)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Local variables in Bracmat are shallowly bound dynamically scoped variables.
This means that variables that are used in a function but not locally declared
in that function, are inherited from the (function or global) context from
which the function is called, which in turn may inherit any undeclared
variables from another calling context. This scheme contrasts with most
programming languages. It is efficient, but the effect of forgetting to
declare a local variable can be unexpected behaviour of conceptually unrelated
code.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />It is possible to declare a function inside another function. Always declare
the name of an embedded function as a local variable.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><span class="arrow">⇒</span><a href="#funtxt3" style="line-height:12pt">Recursion and the "_"-operator</a><br /><h1><a name="lambda">Lambda calculus, currying</a></h1><br ex="EX2" />The lambda abstraction<blockquote good="GOOD2"><pre>     (λx.x)y</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />translates to<blockquote good="GOOD2"><pre>   /('(x.$x))$y</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat's implementation of lambda calculus is a variant of Bracmat's macro
substitution. The expression<blockquote good="GOOD2"><pre>    /('(x.$x))</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />evaluates to itself, not to something like<blockquote good="GOOD2"><pre>   /(=(x.foo))</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />(assuming that the variable <code FFF="fff">x</code> had the value <code FFF="fff">foo</code>). In contrast, the same
expression without the leading slash<blockquote good="GOOD2"><pre>   ('(x.$x))</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />evaluates to<blockquote good="GOOD2"><pre>   =x.foo</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The rhs of the<code AAA="aaa"> $ </code>operator must be an atom.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />In an lambda abstraction<blockquote good="GOOD2"><pre>   /('(x.$x,$y))</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" /><code AAA="aaa">$x </code>is a bound variable and<code AAA="aaa"> $y </code>is a free variable.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The expression<code AAA="aaa"> $x </code>is only replaced by a value if <code FFF="fff">x</code> is the variable in the
lambda abstraction or a lambda abstraction that contains the lambda
abstraction, as in<blockquote good="GOOD2"><pre>   /('(x.(/('(y.($x) ($y)))$aap)))$noot</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />which evaluates to<blockquote good="GOOD2"><pre>   noot aap</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />No Bracmat variables come into play, not even <code FFF="fff">arg</code>. Thus, in the example above
the value <code FFF="fff">aap</code> is bound in <code FFF="fff">($x)</code>, but never assigned to a variable <code FFF="fff">x</code>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The expression<blockquote good="GOOD2"><pre>   /('(x.(/('(x.($x) ($x)))$aap)))$noot</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />evaluates to<blockquote good="GOOD2"><pre>   aap aap</pre></blockquote><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><h1><a name="inbltmenu">Built-in functions</a></h1><br ex="EX2" /><br ex="ENDEX2" /><dl><dt><a href="#seltxt"><i>N</i></a></dt><dd>    access array element:<code FFF="fff">!(12$a):?(11$a)</code></dd><dt><a href="#alctxt"><code FFF="fff">alc</code></a></dt><dd>    allocate memory (low level):<code FFF="fff">alc$100</code></dd><dt><a href="#argtxt"><code FFF="fff">arg</code></a></dt><dd>    return program (command line) argument:<code FFF="fff">(arg$0:?programName)</code><code FFF="fff">((arg$:?o1)&amp;(arg$:?o2))</code></dd><dt><a href="#asctxt"><code FFF="fff">asc</code></a></dt><dd>    convert character to internal representation:<code FFF="fff">asc$y:121</code></dd><dt><a href="#chrtxt"><code FFF="fff">chr</code></a></dt><dd>    convert internal representation to character:<code FFF="fff">chr$121:y</code></dd><dt><a href="#chutxt"><code FFF="fff">chu</code></a></dt><dd>    convert Unicode codepoint to UTF-8 character:<code FFF="fff">chu$2000</code></dd><dt><a href="#clktxt"><code FFF="fff">clk</code></a></dt><dd>    CPU seconds since start of session:<code FFF="fff">clk$:?t0</code></dd><dt><a href="#d2xtxt"><code FFF="fff">d2x</code></a></dt><dd>    convert decimal number to hexadecimal number:<code FFF="fff">d2x$73083734:45B2B56</code></dd><dt><a href="#dbgtxt"><code FFF="fff">dbg</code></a></dt><dd>    debugging aid:<code FFF="fff">dbg'(a b c:? b ?)</code></dd><dt><a href="#dentxt"><code FFF="fff">den</code></a></dt><dd>    denominator:<code FFF="fff">den$22/7:7</code></dd><dt><a href="#divtxt"><code FFF="fff">div</code></a></dt><dd>    quotient:<code FFF="fff">div$(22.7):1</code></dd><dt><a href="#filtxt"><code FFF="fff">fil</code></a></dt><dd>    file I/O (low-level)</dd><dt><a href="#flgtxt"><code FFF="fff">flg</code></a></dt><dd>    splits expression in prefixes and expression without prefixes</dd><dt><a href="#glftxt"><code FFF="fff">glf</code></a></dt><dd>    opposite of flg: combines prefixes and expression</dd><dt><a href="#fretxt"><code FFF="fff">fre</code></a></dt><dd>    return allocated memory (low level)</dd><dt><a href="#gettxt"><code FFF="fff">get</code></a></dt><dd>    get input (from file,keyboard or memory)</dd><dt><a href="#lowtxt"><code FFF="fff">low</code></a></dt><dd>    convert to lower case</dd><dt><a href="#lsttxt1"><code FFF="fff">lst</code></a></dt><dd>    list un-evaluated value of variable(s)</dd><dt><a href="#memtxt"><code FFF="fff">mem</code></a></dt><dd>    list existing variable names</dd><dt><a href="#modtxt"><code FFF="fff">mod</code></a></dt><dd>    remainder</dd><dt><a href="#newobjecttxt"><code FFF="fff">new</code></a></dt><dd>    create new object as a copy of another object</dd><dt><a href="#peetxt"><code FFF="fff">pee</code></a></dt><dd>    get value from address (peek) (low level)</dd><dt><a href="#poktxt"><code FFF="fff">pok</code></a></dt><dd>    put value at address (poke) (low level)</dd><dt><a href="#puttxt1"><code FFF="fff">put</code></a></dt><dd>    write output</dd><dt><a href="#rentxt"><code FFF="fff">ren</code></a></dt><dd>    rename file or directory or move file</dd><dt><a href="#rmvtxt"><code FFF="fff">rev</code></a></dt><dd>    string reverse</dd><dt><a href="#revtxt"><code FFF="fff">rmv</code></a></dt><dd>    remove file</dd><dt><a href="#simtxt"><code FFF="fff">sim</code></a></dt><dd>    similarity between two atoms</dd><dt><a href="#strtxt"><code FFF="fff">str</code></a></dt><dd>    stringize expression into atom</dd><dt><a href="#switxt"><code FFF="fff">swi</code></a></dt><dd>    software interrupt (low level)</dd><dt><a href="#systxt"><code FFF="fff">sys</code></a></dt><dd>    command line shell</dd><dt><a href="#tbltxt"><code FFF="fff">tbl</code></a></dt><dd>    create array, remove array/variable</dd><dt><a href="#upptxt"><code FFF="fff">upp</code></a></dt><dd>    convert to upper case</dd><dt><a href="#utftxt"><code FFF="fff">utf</code></a></dt><dd>    convert UTF-8 character to Unicode codepoint</dd><dt><a href="#whltxt"><code FFF="fff">whl</code></a></dt><dd>    while loop</dd><dt><a href="#x2dtxt"><code FFF="fff">x2d</code></a></dt><dd>    convert hexadecimal number to decimal number<code FFF="fff">x2d$BABEFACE:3133078222</code><br /></dd></dl><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><h1><a name="seltxt"><code AAA="aaa"><i>index</i>$<i>array name</i></code></a></h1><br ex="EX2" />Both <i>array name</i> and <i>index</i> should evaluate to atoms. <i>array name</i> may be
preceded by prefixes, such as ? or<code BBB="bbb"> !. </code>Indexing starts at 0 and is done
modulo(size-of-array). Negative values count from the upper end of the array.
The chosen index remains in force until a new indexing function is evaluated.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} tbl$(array,4)              { declare array[0..3] }
{?} a-value : 2 $ ?array       { array[2] := a-value }
{?} array = another-value      { array[2] := another-value }
{?} !array : -1 $ ?array       { array[3] := another-value }
{?} 45 : 1$?array              { array[1] := 45 }
{?} 2'!array : 3'!array        { are array[2] and array[3] equal?
                                 Notice use of ' instead of $. }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="alctxt"><code AAA="aaa">alc$<i>number of bytes</i></code></a></h1><br ex="EX2" />This function allocates memory and returns the starting address of the
allocated memory, but crashes the program if not enough memory can be
allocated. Access to memory that has been allocated in this way is by means of
<code AAA="aaa">pee$ </code>and<code AAA="aaa"> pok$. </code>Any allocated memory should at some time be returned to the
memory heap with the function<code AAA="aaa"> fre$.</code><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} alc$1000:?p {allocate 1000 bytes and assign starting address to p}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="argtxt"><code AAA="aaa">arg$ </code>or<code AAA="aaa"> arg$<i>number</i></code></a></h1><br ex="EX2" />If Bracmat is started with any arguments (argc &gt; 1) every argument is
evaluated from left to right, unless arguments are consumed by calls to<code AAA="aaa"> arg$.</code>
For example,<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   bracmat get$myprog -i c:\documents\input.txt -o d:\html\index.html</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />would evaluate<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   get$myprog</pre></blockquote><blockquote good="GOOD1"><pre>   -i</pre></blockquote><blockquote good="GOOD4"><pre>   c:\documents\input.txt</pre></blockquote><blockquote good="GOOD1"><pre>   -o</pre></blockquote><blockquote good="GOOD4"><pre>   d:\html\index.html</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />in that order. Evaluating the last four arguments is not very meaningful,
however: the backslashes are interpreted as escapes, which they are not.
Moreover, the colon and the dot are interpreted as operators. However, the
bracmat program 'myprog' can call the function<code AAA="aaa"> arg$ </code>four times and in that way
empty the queue of arguments.<code AAA="aaa"> arg$ </code>returns an atom containing an exact copy of
the next program argument. Using string matching the arguments can be parsed,
if necessary.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Precautions must be taken if the path or name of the bracmat program contains
characters that can be mistakenly interpreted. E.g. (in Windows)<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   bracmat "get$@\"c:Program Files\yourprog.bra\""</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />In<code AAA="aaa"> *N?X </code>the apostrophes surrounding the first argument must be replaced by
quotes.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />A second form is<code AAA="aaa"> arg$N, </code>where 0<code AAA="aaa"> &lt;= </code>N &lt; argc.<code AAA="aaa"> arg$0 </code>will normally return the
command name 'bracmat' or a path leading to 'bracmat'. Here is a simple
program 'myprog' that demonstrates the two ways of calling the 'arg' function<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   { myprog }</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   (test=</pre></blockquote><blockquote good="GOOD1"><pre>     0:?N</pre></blockquote><blockquote good="GOOD4"><pre>   &amp;   whl</pre></blockquote><blockquote good="GOOD1"><pre>     ' ( arg$:?argument</pre></blockquote><blockquote good="GOOD4"><pre>       &amp; out$(The next argument is !argument)</pre></blockquote><blockquote good="GOOD1"><pre>       )</pre></blockquote><blockquote good="GOOD4"><pre>   &amp;   whl</pre></blockquote><blockquote good="GOOD1"><pre>     ' ( arg$!N:?argument</pre></blockquote><blockquote good="GOOD4"><pre>       &amp; out$(Argument !N is !argument)</pre></blockquote><blockquote good="GOOD1"><pre>       &amp; 1+!N:?N</pre></blockquote><blockquote good="GOOD4"><pre>       )</pre></blockquote><blockquote good="GOOD2"><pre>   );</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   !test;</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Now running bracmat with these arguments (example is Windows):<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   bracmat get$myprog -i c:\documents\input.txt -o d:\html\index.html</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />results in the following output being written to the terminal:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre>   The next argument is -i</pre></blockquote><blockquote good="GOOD1"><pre>   The next argument is c:documentsinput.txt</pre></blockquote><blockquote good="GOOD4"><pre>   The next argument is -o</pre></blockquote><blockquote good="GOOD1"><pre>   The next argument is d:htmlindex.html</pre></blockquote><blockquote good="GOOD4"><pre>   Argument 0 is bin\bracmat</pre></blockquote><blockquote good="GOOD1"><pre>   Argument 1 is get$myprog</pre></blockquote><blockquote good="GOOD4"><pre>   Argument 2 is -i</pre></blockquote><blockquote good="GOOD1"><pre>   Argument 3 is c:documentsinput.txt</pre></blockquote><blockquote good="GOOD4"><pre>   Argument 4 is -o</pre></blockquote><blockquote good="GOOD2"><pre>   Argument 5 is d:htmlindex.html</pre></blockquote><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="asctxt"><code AAA="aaa">asc$<i>character</i></code></a></h1><br ex="EX2" /><code AAA="aaa">asc$ </code>returns the integer value that corresponds to the character according to
the current table used by the operating system (e.g. an extended ASCII table).<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} asc$"+" {return "ASCII" value of character +}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="chrtxt"><code AAA="aaa">chr$<i>value</i></code></a></h1><br ex="EX2" /><code AAA="aaa">chr$ </code>returns the character at location <i>value</i> in the current table of
characters used by the operating system. (e.g. an extended ASCII table).
<code AAA="aaa">chr$ </code>fails if <i>value</i> equals 0.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} chr$255 {return the last character from the current table of characters
             (assuming a machine with 8-bit characters)}
{?} ( tolower=.
        !arg:~&lt;A:~&gt;Z                  {If arg is in the range A-Z,}
      &amp; chr$(asc$!arg+-1*asc$A+asc$a) {then return its lower case equivalent,}
    | !arg                            {else return arg unchanged.}
    ) {(Works only correctly if the "distance" between lower and upper case
        versions is the same for all characters in the range A-Z.)}
{?} tolower$G</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="chutxt"><code AAA="aaa">chu$<i>value</i></code></a></h1><br ex="EX2" /><code AAA="aaa">chu$ </code>returns the UTF-8 character at Unicode code point <i>value</i>.
<code AAA="aaa">chu$ </code>fails if <i>value</i> equals 0 or less or if <i>value</i> exceeds 2147483647
(7FFFFFFF). According to the UTF-8 standard values above 1114111 (10FFFF)
are illegal.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} d2x$utf$chu$x2d$7fffffff</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="clktxt"><code AAA="aaa">clk$</code></a></h1><br ex="EX2" /><code AAA="aaa">clk$ </code>returns the number of CPU seconds that that has been spend on running the
current session of Bracmat. The number is an unreduced quotient of number of
clock ticks and the number of clock ticks per second.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} clk$
{!} 30375/1000</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="d2xtxt"><code AAA="aaa">d2x$<i>decimal value</i></code></a></h1><br ex="EX2" /><code AAA="aaa">d2x$ </code>converts a decimal number between 0 and 4294967295<code AAA="aaa"> (2^32+-1) </code>to an
hexadecimal number consisting of characters 0-9 and A-F. On 64-bit platforms
the upper bound is 18446744073709551615<code AAA="aaa"> (2^64+-1). </code>The function fails if the
argument is not an integer number or if the number is outside this range.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} d2x$(2^32+-1)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="dbgtxt"><code AAA="aaa">|_dbg'<i>expression</i>_|</code></a></h1><br ex="EX2" />Create warnings in situations that probably are programming errors.
Currently, a warning is generated when a function definition can not be found.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} dbg'(foo$a)
{?} dbg'((myclass.yourfunc)$X)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="dentxt"><code AAA="aaa">den$<i>rational number</i></code></a></h1><br ex="EX2" />The denominator of <i>rational number</i> is returned. There is no built-in
numerator extractor function.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} den$22/7
{?} num = .!arg*den$!arg { home-made numerator function }
{?} num$22/7
{?} den$sim$(,monkey)   { return length of word "monkey"}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="divtxt"><code AAA="aaa">div$(<i>rational number</i>,<i>rational number</i>)</code></a></h1><br ex="EX2" /><code AAA="aaa">div$ </code>returns the (integral) quotient of its arguments.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} div$(123/45,67/890)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="filtxt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a></h1><br ex="EX2" /><code AAA="aaa">fil$ </code>is a multi-purpose low level I/O function.
<br ex="ENDEX2" /><dl><dt><a href="#modetxt"><code FFF="fff">fil$([<i>file name</i>],<i>mode</i>)</code></a></dt><dd>    Set file mode, open a file in a file mode</dd><dt><a href="#fixdtxt"><code FFF="fff">fil$([<i>file name</i>],<i>type</i>,<i>size</i>[,<i>number</i>])</code></a></dt><dd>    Prepare for reading or writing fixed sized records</dd><dt><a href="#varitxt"><code FFF="fff">fil$([<i>file name</i>],STR[,<i>stop</i>])</code></a></dt><dd>    Prepare for reading or writing variable sized record    </dd><dt><a href="#positiontxt"><code FFF="fff">fil$(<i>file name</i>,TEL)</code></a></dt><dd>    Telling position inside file    </dd><dt><a href="#filesettxt"><code FFF="fff">fil$(<i>file name</i>,<i>whence</i>,<i>offset</i>)</code></a></dt><dd>    Go to file position    </dd><dt><a href="#readtxt"><code FFF="fff">fil$([<i>file name</i>][,,<i>number</i>])</code></a></dt><dd>    Read from file    </dd><dt><a href="#writetxt"><code FFF="fff">fil$([<i>file name</i>],,<i>number</i>,<i>value</i>)</code></a></dt><dd>    Write to file    </dd><dt><a href="#closetxt"><code FFF="fff">fil$([<i>file name</i>],SET,-1)</code></a></dt><dd>    Close  a file</dd></dl><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="modetxt"> <code AAA="aaa"> fil$([<i>file name</i>],<i>mode</i>) </code> </a></h1><br ex="EX2" />Set file mode, open file in file mode.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Option <i>mode</i> is one of the following:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code FFF="fff">r</code></dt><dd>   open text file for reading</dd><dt><code FFF="fff">w</code></dt><dd>   create text file for writing, or truncate to zero length</dd><dt><code FFF="fff">a</code></dt><dd>   append; open text file or create for writing at eof</dd><dt><code FFF="fff">rb</code></dt><dd>   open binary file for reading</dd><dt><code FFF="fff">wb</code></dt><dd>   create binary file for writing, or truncate to zero length</dd><dt><code FFF="fff">ab</code></dt><dd>   append; open binary file or create for writing at eof</dd><dt><code FFF="fff">"r+"</code></dt><dd>   open text file for update (reading and writing)</dd><dt><code FFF="fff">"w+"</code></dt><dd>   create text file for update, or truncate to zero length</dd><dt><code FFF="fff">"a+"</code></dt><dd>   append; open text file or create for update, writing at eof</dd><dt><code FFF="fff">"r+b"</code> or <code FFF="fff">"rb+"</code></dt><dd>   open binary file for update (reading and writing)</dd><dt><code FFF="fff">"w+b"</code> or <code FFF="fff">"wb+"</code></dt><dd>   create binary file for update, or truncate to zero length</dd><dt><code FFF="fff">"a+b"</code> or <code FFF="fff">"ab+"</code></dt><dd>
   append; open binary file or create for update, writing at eof</dd></dl><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#filtxt" style="line-height:12pt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a><br /><h1><a name="fixdtxt"> <code AAA="aaa"> fil$([<i>file name</i>],<i>type</i>,<i>size</i></code><code AAA="aaa">[,<i>number</i>]) </code> </a></h1><br ex="EX2" />Prepare for reading or writing fixed sized records.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Option <i>type</i> is one of the following :<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code FFF="fff">CHR</code></dt><dd>   character or string I/O</dd><dt><code FFF="fff">DEC</code></dt><dd>
   number I/O</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Option <i>size</i> must be a non-negative integer and determines the number of
bytes that are read or written as one chunk during a future call to<code AAA="aaa"> fil$.</code>
If <i>type</i> is <code FFF="fff">DEC</code>, only values 1,2 and 4 are valid, corresponding to 1, 2
and 4 byte sized integers, respectively. Notice that 2 and 4 byte integers are
not portable between implementations with different byte order. The optional
<i>number</i> tells how many read or write operations of size <i>size</i> have to be
performed. If <i>type</i> is <code FFF="fff">DEC</code>, the product of <i>size</i> and <i>number</i> may not be
greater than 4. If a number is read or written in 2 or more chunks, the least
significant bytes or 16 bit words are read or written first (little endian).<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#filtxt" style="line-height:12pt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a><br /><h1><a name="varitxt"> <code AAA="aaa"> fil$([<i>file name</i>],STR[,<i>stop</i>]) </code> </a></h1><br ex="EX2" />Prepare for reading or writing variable sized record<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Option <i>stop</i> is a string of characters. If the read character or the character
to be written is equal to one of the characters in the stop string, reading or
writing stops. The default is not to stop until the end of the file (reading)
or the end of the string (writing).<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#filtxt" style="line-height:12pt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a><br /><h1><a name="positiontxt"> <code AAA="aaa"> fil$(<i>file name</i>,TEL)</code>  </a></h1><br ex="EX2" />Telling the position inside the file.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Returns the current value of the file position indicator.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#filtxt" style="line-height:12pt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a><br /><h1><a name="filesettxt"> <code AAA="aaa"> fil$(<i>file name</i>,<i>whence</i>,<i>offset</i></code>)  </a></h1><br ex="EX2" />Go to file position.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Sets the current value of the file position indicator to an <i>offset</i> based
on the value of <i>whence</i>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Option <i>whence</i> is one of the following:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt>SET</dt><dd>   start of file</dd><dt>CUR</dt><dd>   current file position</dd><dt>END</dt><dd>
   end of file. (In some implementations, binary files may not handle END).</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />For a text file, <i>offset</i> must be 0, or the value returned from a call to
<code AAA="aaa">fil$(<i>file name</i>,TEL)</code>, in which case <i>whence</i> must be SET.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#filtxt" style="line-height:12pt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a><br /><h1><a name="readtxt"> <code AAA="aaa"> fil$([<i>file name</i>][,,<i>number</i>]) </code> </a></h1><br ex="EX2" />Reading from a file.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Reads (if <i>mode</i> permitting) <i>number</i> chunks of <i>size</i> bytes.
When reading variable sized records (<code FFF="fff">STR</code>),<code AAA="aaa"> fil$ </code>returns a dot-separated list
of two elements: the found stop character and the read string (which does not
contain the stop character).<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} fil$("mytext.txt","rb")               { Open for reading in binary mode. }
{?} fil$(,STR)                   { Prepare for reading until the next 0-byte.}
{?} fil$:(?line.?stop)                         { Read until the next 0-byte. }
{?} fil$(,SET,-1)                                          { Close the file. }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} fil$("mytext.txt","rb")               { Open for reading in binary mode. }
{?} fil$(,STR,"\n \t\r")    { Prepare for reading until the next white space.}
{?} :?words             { In a moment, accumulate all words in this variable }
{?} whl'(fil$:(?word.?stop)&amp;!word !words:?words)&amp;          { Read all words. }
{?} fil$(,SET,-1)                                          { Close the file. }
{?} !words                              { Show all words, in reversed order. }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#filtxt" style="line-height:12pt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a><br /><h1><a name="writetxt"> <code AAA="aaa"> fil$([<i>file name</i>],,<i>number</i>,<i>value</i></code>)  </a></h1><br ex="EX2" />Writing to a file<br ex="ENDEX2" /><br /><br /><br ex="EX2" />writes (if <i>mode</i> permitting) <i>number</i> chunks of <i>size</i> bytes from <i>value</i>.
If <i>type</i> is <code FFF="fff">DEC</code>,<code AAA="aaa"> <i>number</i>*<i>size</i> </code>must be 1,2,3 or 4. <i>value</i> must be an
integer value and is cast to a binary number with at most<code AAA="aaa"> <i>number</i>*<i>size</i>*8</code>
bits. This number is stored in<code AAA="aaa"> <i>number</i>*<i>size</i> </code>bytes, which in turn are output.
If <i>number</i> is greater than 1, the byte(s) with the least significant digits
are output first. In machines with little-endian byte-order, only the
product<code AAA="aaa"> <i>number</i>*<i>size</i> </code>matters.
If <i>type</i> is <code FFF="fff">CHR</code> and the length of <i>value</i> is shorter than<code AAA="aaa"> <i>number</i>*<i>size</i>,</code><i>value</i> is padded with spaces (to the right).<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#filtxt" style="line-height:12pt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a><br /><h1><a name="closetxt"> <code AAA="aaa"> fil$([<i>file name</i>],SET,-1)</code>  </a></h1><br ex="EX2" />Closing a file.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />An open file is closed by specifying an impossible file position.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#filtxt" style="line-height:12pt"><code AAA="aaa">fil$([[<i>file name</i>][,<i>option</i>[,<i>number</i></code><code AAA="aaa">[,<i>value to output</i>]]]])</code></a><br /><h1><a name="flgtxt"><code AAA="aaa">flg$(=<i>expression</i>)</code></a></h1><br PECH="PECH" /><br ex="EX2" />flg returns a copy of the expression without prefixes ('flags') and a new
leaf with the prefixes of the original expression. These two results are
coupled with a dot-operator, the prefixes to the left and the expression without
prefixes to the right. The result is protected against evaluation by a<code AAA="aaa"> '='</code>
operator.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} flg$(=~#&lt;&gt;?%@a)
{!} (=~#&lt;&gt;%@?).a</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Use macro evaluation if the expression to be split is the value of a variable:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} X=~(%+%)
{!} X
{?} flg$('$X):(=?prefixes.?expr)
{!} =~.%+%
{?} glf$('($prefixes.%*%))
{!} =~(%*%)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="glftxt"><code AAA="aaa">glf$(=<i>prefixes</i>.<i>expression</i>)</code></a></h1><br PECH="PECH" /><br ex="EX2" />glf returns a copy of <i>expression</i> with <i>prefixes</i> added to its prefixes.
If <i>expression</i> has one or more prefixes also present in <i>prefixes</i>, then glf
fails. Therefore, glf can be used to test for the presence of one or more
prefixes. The result is protected against evaluation by a<code AAA="aaa"> '=' </code>operator.
The function glf has an effect that is the opposite of flg.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} glf$flg$(=?a)
{!} =?a</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Use macro evaluation if the expression to be split is the value of a variable.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} X=?!x
{!} X
{?} flg$('$X):(=?prefixes.?expr)
{!} =?!.x
{?} glf$('($prefixes.z))
{!} =?!z</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="fretxt"><code AAA="aaa">fre$<i>memory address</i></code></a></h1><br ex="EX2" /><code AAA="aaa">fre$ </code>returns a chunk of memory to the memory pool (heap). The only valid
parameter is a return value of<code AAA="aaa"> alc$. </code>Applying<code AAA="aaa"> fre$ </code>to a chunk of memory that
was never allocated or that has been returned already results in undefined
behaviour of the program.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} alc$1000:?p {allocate chunk of 1000 bytes from the memory pool}
{?} fre$!p      {return this chunk to the memory pool}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="gettxt"><code AAA="aaa">get$(<i>atom-or-nil</i>[,MEM][,ECH][,VAP][,STR])</code></a></h1><br ex="EX2" /><code AAA="aaa">get$ </code>reads and interprets characters in a string (internal memory) or file
(external memory or keyboard).<br ex="ENDEX2" /><br /><br /><br ex="EX2" />options :<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code FFF="fff">MEM</code> present</dt><dd>   The name of the first parameter is the source of the characters. (MEMory)</dd><dt><code FFF="fff">MEM</code> not present</dt><dd>   A file with the name of the first parameter is the source.</dd><dt><code FFF="fff">ECH</code> present</dt><dd>   The characters are echoed to the screen as they are read.</dd><dt><code FFF="fff">ECH</code> not present</dt><dd>   No echo.</dd><dt><code FFF="fff">VAP</code> present</dt><dd>   The (8-bit) characters are read "as is". Extra spaces
   are inserted between the characters. (VAPorised)</dd><dt><code FFF="fff">VAP</code> not present</dt><dd>   No extra spaces are added.</dd><dt><code FFF="fff">STR</code> present</dt><dd>   The characters are read into one string.</dd><dt><code FFF="fff">STR</code> not present</dt><dd>   The characters are interpreted as parts of a Bracmat expression and
   evaluated after the whole expression has been read.</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The <code FFF="fff">VAP</code> option is evaluated before the <code FFF="fff">STR</code> option.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Applications :<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> get'(matrix,|_ECH_|)</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Read file "matrix" and evaluate the expressions (delimited by semicolons)
therein. If the system finds a syntax error in a multiple expression file,
the <code FFF="fff">ECH</code> option makes it easier to locate the error.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> get'(matrix,STR):?intern</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Read file "matrix" into a string called "intern". If this file contains
Bracmat instructions, they hereafter exist in a "sleeping" state in memory.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> get$(!intern,MEM)</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />!intern is, in this example, expanded to an atom with a very long name, namely
all of the text of file "matrix". The sleeping expressions are evaluated one
after the other, just as if <code FFF="fff">get'matrix</code> was evaluated.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> get'(,VAP):?space-list</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Read characters from standard input (normally keyboard) until next line feed
character. Put each character into an atom. Put all atoms into a linear list
with space operators. Bind this list to the name "space-list".<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><blockquote good="GOOD4"><pre> get'(")y",MEM)</pre></blockquote><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Read the sleeping "expression" <code FFF="fff">)y</code> from memory. The lexical scanner
will find an unbalanced right parenthesis, which could mean that this Bracmat
session should stop. The <code FFF="fff">y</code> confirms this assumption and the program will
come to an end immediately. If the <code FFF="fff">y</code> hadn't been present, Bracmat would
ask <code FFF="fff">end Bracmat session ? (y/n)</code> after which the user has to choose. This
trick is useful in batch processing.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />If the first parameter is <i>nil</i> or <code FFF="fff">stdin</code> and the <code FFF="fff">MEM</code> option is not used,
input is coming from standard input.
Take care for putting filenames in double quotes if they contain any
characters that can be misunderstood, such as dots, (back) slashes or dollars.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="lowtxt"><code AAA="aaa">low$(<i>atom-or-nil</i>)</code></a></h1><br ex="EX2" /><code AAA="aaa">low$ </code>converts a string to all-lowercase.
The characters 'A'-'Z' are converted to 'a'-'z'. Other characters are handled
as UTF-8 encoded Unicode characters, but default to ISO 8859 (Latin 1) if
the argument is not valid UTF-8.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇒</span><a href="#DOSopttxt" style="line-height:12pt">Codepage 850 support</a><br /><h1><a name="DOSopttxt">Codepage 850 support</a></h1><br ex="EX2" />As of July 2009 Codepage 850 is not supported, unless bracmat is compiled with
<code AAA="aaa">#define </code>CODEPAGE850 1.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇐</span><a href="#lowtxt" style="line-height:12pt"><code AAA="aaa">low$(<i>atom-or-nil</i>)</code></a><br /><span class="arrow">⇐</span><a href="#upptxt" style="line-height:12pt"><code AAA="aaa">upp$(<i>atom-or-nil</i>)</code></a><br /><h1><a name="lsttxt1"><code AAA="aaa">lst$(<i>variable</i>[,LIN])</code></a></h1><br ex="EX2" />Outputs all present bindings of one or more variables to standard output.
If the first parameter is the zero-length string, then all variables with
names starting with a character below ASCII 128 are shown. If a variable
has more than one binding (arrays/stacks) then the current value is preceded
by a "&gt;"-sign.
The second parameter is optional.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} lst$help      { shows this programme on screen,
                    unless stdout has been redirected }
{?} lst$(tay,LIN) { listing without indentations of function tay$ }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇒</span><a href="#humtxt" style="line-height:12pt">option <code FFF="fff">LIN</code></a><br /><h1><a name="humtxt">option<code AAA="aaa"> |_LIN_|</code></a></h1><br PECH="PECH" /><br ex="EX2" />If <code FFF="fff">LIN</code> is not present, output is very much indented, sometimes making it more
readable for humans. If <code FFF="fff">LIN</code> is present, output is as compact as possible.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇐</span><a href="#lsttxt1" style="line-height:12pt"><code AAA="aaa">lst$(<i>variable</i>[,LIN])</code></a><br /><span class="arrow">⇐</span><a href="#puttxt1" style="line-height:12pt"><code AAA="aaa">put$(<i>expression</i>[,LIN])</code></a><br /><span class="arrow">⇒</span><a href="#lsttxt2" style="line-height:12pt"><code AAA="aaa">lst$(<i>variable</i>,MEM [,LIN])</code></a><br /><span class="arrow">⇒</span><a href="#puttxt2" style="line-height:12pt"><code AAA="aaa">put$(<i>expression</i>,MEM [,LIN])</code></a><br /><h1><a name="lsttxt2"><code AAA="aaa">lst$(<i>variable</i>,MEM [,LIN])</code></a></h1><br ex="EX2" />The difference with the preceding form is, that "output" takes place to
memory. What is normally visible on screen is put in one atom, which is
the return value of the call to lst. It has the opposite effect of
<code AAA="aaa">get$(<i>atom</i>,MEM)</code>. Use : compression of an expression to save space. If the
compressed expression is needed, it is decompressed with<code AAA="aaa"> get$. </code>Compression is
typically by a factor of about 5, but may be as large as 16. Expressions with
very large atoms (such as this help function) do less well. Example:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} lst$(fct,MEM):?sleeping-fct
{?} tbl$(fct,0)   { remove function fct$ from memory }
{?} { .. celebrate space-saving, until fct$ is needed .. }
{?} get$(!sleeping-fct,MEM)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇐</span><a href="#humtxt" style="line-height:12pt">option <code FFF="fff">LIN</code></a><br /><span class="arrow">⇒</span><a href="#lsttxt3" style="line-height:12pt"><code FFF="fff">lst$(<i>variable</i>,<i>file name</i>,NEW | APP [,LIN])</code></a><br /><h1><a name="lsttxt3"><code AAA="aaa">|_lst$(<i>variable</i>,<i>file name</i>,NEW </code><code AAA="aaa">| </code>APP<code AAA="aaa"> [,LIN])_|</code></a></h1><br ex="EX2" />This time, output is sent to the named file instead of standard output.
The third argument is explained below.
Code that has been saved with<code AAA="aaa"> lst$ </code>can be reloaded with<code AAA="aaa"> get$.</code><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} lst$(,"all",NEW,LIN)
    { write all current code without indentations to file "all" }
{?} lst$(tay,taylor,NEW)
    { save function tay$ to file "taylor" in indented format }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇐</span><a href="#lsttxt2" style="line-height:12pt"><code AAA="aaa">lst$(<i>variable</i>,MEM [,LIN])</code></a><br /><span class="arrow">⇒</span><a href="#newtxt" style="line-height:12pt">options <code FFF="fff">NEW</code> and <code FFF="fff">APP</code></a><br /><h1><a name="newtxt">options<code AAA="aaa"> |_NEW_| </code>and<code AAA="aaa"> |_APP_|</code></a></h1><br ex="EX2" />one of the options <code FFF="fff">NEW</code> and <code FFF="fff">APP</code> must be present :
<code FFF="fff">NEW</code><blockquote good="GOOD1"><pre>   tells the computer to open a new file or overwrite an old one.</pre></blockquote><code FFF="fff">APP</code><blockquote good="GOOD1"><pre>   directs output to an existing file. If the file does not exist, it is</pre></blockquote><blockquote good="GOOD4"><pre>   created first.</pre></blockquote><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇐</span><a href="#lsttxt3" style="line-height:12pt"><code FFF="fff">lst$(<i>variable</i>,<i>file name</i>,NEW | APP [,LIN])</code></a><br /><span class="arrow">⇐</span><a href="#puttxt3" style="line-height:12pt"><code FFF="fff">put$(<i>expression</i>,<i>file name</i>,NEW | APP [,LIN])</code></a><br /><h1><a name="memtxt"><code AAA="aaa">mem$[EXT]</code></a></h1><br ex="EX2" /><code AAA="aaa">mem$ </code>produces a list of all currently existing variables, except those
beginning with a character above ASCII 126. The EXT option adds information
about the number of occurrences (array or stack size - 1) of those variables
which have more than one occurrence and shows which of them is currently in
focus (index into array: 0 .. size-1).
The predefined function<code AAA="aaa"> cat$ </code>makes use of<code AAA="aaa"> mem$.</code><br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} mem$
{?} mem$EXT</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="modtxt"><code AAA="aaa">mod$(<i>number</i>,<i>divisor</i>)</code></a></h1><br ex="EX2" /><code AAA="aaa">mod$ </code>divides <i>number</i> by <i>divisor</i>. The rest is returned.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} mod$(22,7)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="newobjecttxt"><code AAA="aaa">new$<i>object</i> </code>or<code AAA="aaa"> new$(<i>object</i>,<i>args</i>)</code></a></h1><br ex="EX2" /><code AAA="aaa">new$ </code>creates a shallow copy of an object and calls the method "new" of the
new object, if there is one. With the second form, <i>args</i> is passed to the
method "new". Example:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (patient=
  (name=(first=John),(last=Bull)) {name is a copy, first and last are not}
  , (age=20)
  , ( new
    =
      .   out$"hello world"
        &amp; new$(its.name):(=?(its.name)) {create fresh copies of first and last}
        &amp;   !arg
          : (?(its.name.first).?(its.name.last).?(its.age))
  ))
{?} new$(patient,(Albert.Keinstein.42)):?x
{?} new$(patient.name):(?Name)
{?} Alice:?(Name..first)
{?} new$(('$patient),(Albert.Keinstein.42)):?y {x and y are identical !}
{?} new$(=(a=1),(b=2)):?ab {"die" is called when ab is reassigned}
{?} 3:?(ab..a)
{?} new$(=(a=1),(b=2),(new=.),(die=.)):(=?cd) {"die" is called at once!}
{?} 3:?(cd.a)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />When an object was created with the<code AAA="aaa"> new$ </code>function, an internal flag is set in
the object telling the system that the "die" method must be called just
before deletion of the object. The "die" method, like the "new" method, is
optional and should be used to do clean-up.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="peetxt"><code AAA="aaa">pee$(<i>address</i> [,<i>size</i>])</code></a></h1><br ex="EX2" />Depending on <i>size</i>, a 1, 2 or 4 byte sized integer allocated at <i>address</i> is
returned.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />2 and 4 byte integers may only start at addresses that are multiples
of 2 and 4, respectively. <i>address</i> is lowered to the nearest allowable value,
if needed. Notice that multi byte integers are stored differently in Little
Endian (iAPx86, VAX, ARM) and Big Endian (MC680x0) machines. Many operating
systems abort programs that try to access non-existent or protected memory
areas.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} chr$pee$34567  {return value at address 34567 (1 byte) as a character}
{?} pee$(34567,2) {return value at address 34566 (2 bytes)}
{?} pee$(34567,4) {return value at address 34564 (4 bytes)}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="poktxt"><code AAA="aaa">pok$(<i>address</i>,<i>value</i> </code><code AAA="aaa">[,<i>size</i>])</code></a></h1><br ex="EX2" />Depending on <i>size</i>, a 1, 2 or 4 byte sized integer is stored at <i>address</i>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />2 and 4 byte integers may only start at addresses that are multiples
of 2 and 4, respectively. <i>address</i> is lowered to the nearest allowable value,
if needed. Notice that multi byte integers are stored differently in Little
Endian (iAPx86, VAX, ARM) and Big Endian (MC680x0) machines. Many operating
systems abort programs that try to access non-existent or protected memory
areas.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} pok$(34567,asc$K) {store the internal value of the character K at memory
                        location 34567 (as 1 byte)}
{?} pok$(34567,-1,4) {store 2^32-1 at memory location 34564
                      (assuming 1-complement arithmetic)}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="puttxt1"><code AAA="aaa">put$(<i>expression</i>[,LIN])</code></a></h1><br ex="EX2" />Sends <i>expression</i> to standard output. The cursor is positioned after the
last output character. The predefined function<code AAA="aaa"> out$ </code>does the same as<code AAA="aaa"> put$,</code>
with the exception that it positions the cursor on the beginning of the next
line.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} put$("b+a" is after evaluation b+a)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇒</span><a href="#humtxt" style="line-height:12pt">option <code FFF="fff">LIN</code></a><br /><h1><a name="puttxt2"><code AAA="aaa">put$(<i>expression</i>,MEM [,LIN])</code></a></h1><br ex="EX2" /><i>expression</i> is stringized and placed into an atom, which is the return
value of the call. This use of<code AAA="aaa"> put$ </code>is similar to the<code AAA="aaa"> str$ </code>function, but
whereas<code AAA="aaa"> str$ </code>suppresses the space-operator,<code AAA="aaa"> put$ </code>transfers every character,
including space-operators, to the atom.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} put$(this is not Lotus 1 1+1 1+1+1,MEM):?proposition &amp;
{?} put$!proposition</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇐</span><a href="#humtxt" style="line-height:12pt">option <code FFF="fff">LIN</code></a><br /><span class="arrow">⇒</span><a href="#puttxt3" style="line-height:12pt"><code FFF="fff">put$(<i>expression</i>,<i>file name</i>,NEW | APP [,LIN])</code></a><br /><h1><a name="puttxt3"><code AAA="aaa">|_put$(<i>expression</i>,<i>file name</i>,NEW </code><code AAA="aaa">| </code>APP<code AAA="aaa"> [,LIN])_|</code></a></h1><br ex="EX2" />Write <i>expression</i> to the named file.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} put$(tay$(e^x,x,10),"e.out",APP)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇐</span><a href="#puttxt2" style="line-height:12pt"><code AAA="aaa">put$(<i>expression</i>,MEM [,LIN])</code></a><br /><span class="arrow">⇒</span><a href="#newtxt" style="line-height:12pt">options <code FFF="fff">NEW</code> and <code FFF="fff">APP</code></a><br /><h1><a name="rentxt"><code AAA="aaa">ren$(<i>oldname</i>.<i>newname</i>)</code></a></h1><br ex="EX2" />Renames a file or directory or moves a file.
The<code AAA="aaa"> ren$ </code>function succeeds, unless a syntactic error was made. If there is an
error at the operating system level, one of the following codes is returned:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code FFF="fff">EACCES</code></dt><dd>   File or directory specified by newname already exists or could not be
   created (invalid path); or oldname is a directory and newname specifies
   a different path.</dd><dt><code FFF="fff">ENOENT</code></dt><dd>   File or path specified by oldname not found.</dd><dt><code FFF="fff">EINVAL</code></dt><dd>
   Name contains invalid characters.</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If the command succeeds at the operating system level, the value 0 is returned.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="rmvtxt"><code AAA="aaa">rmv$<i>file name</i></code></a></h1><br ex="EX2" />Removes a file.
The<code AAA="aaa"> rmv$ </code>function succeeds, unless a syntactic error was made. If there is an
error at the operating system level, one of the following codes is returned:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code FFF="fff">EACCES</code></dt><dd>   Indicates that the path specifies a read-only file or that the file
   is open.</dd><dt><code FFF="fff">ENOENT</code></dt><dd>   Indicates that the filename or path was not found or that the path
   specifies a directory.</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If the command succeeds at the operating system level, the value 0 is returned.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="revtxt"><code AAA="aaa">rev$<i>atom</i></code></a></h1><br ex="EX2" />Reverses the order of bytes in an atom. This function can be useful in case of
a string match that asks for the last occurrence of a pattern.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The<code AAA="aaa"> rev$ </code>function succeeds on all atoms and fails on all other expressions.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="simtxt"><code AAA="aaa">sim$(<i>atom-or-nil</i>,<i>atom-or-nil</i>)</code></a></h1><br ex="EX2" /><code AAA="aaa">sim$ </code>uses the Ratcliff/Obershelp pattern matching algorithm in establishing
a measure of the similarity between its two (atomic) arguments. The returned
value is an unsimplified fraction. The denominator is the sum of the numbers
of characters in both arguments. The numerator is the total number of
characters that have been matched successfully. Matching is case-insensitive.
This applies to the full Unicode table, but defaults to ASCII and the upper
128 characters in the ISO8859-1 (Latin 1) character set if the characters are
not UTF-8 encoded.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} sim$(colour,Color)
{?} den$sim$(,"this is an easy way to find this string's length")
{?} div$(sim$("similarity rounded","and in procents")+1/200,1/100)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="strtxt"><code AAA="aaa">str$<i>expression</i></code></a></h1><br ex="EX2" /><code AAA="aaa">str$ </code>"writes" <i>expression</i> into one single atom. All atoms, prefixes and
operators, with the exception of the space-operator, are copied to the
output string. Main use : pasting of two or more atoms.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} n=3
{?} str$(var !n) = seventeen
{?} out$(var3 is !var3)
{?} editfile = mytxts/story
{?} sys$str$("vi " !editfile)   { execute UNIX command "vi mytxts/story" }
{?} a=x+2*y;b=2*x+y
{?} put$str$(!a "+" !b " = " !a+!b)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="switxt"><code AAA="aaa">swi$(<i>interrupt number</i>.<i>input value</i>,[<i>input value</i></code><code AAA="aaa">,...])</code></a></h1><br ex="EX2" />This function is the most operating-system-dependent function in Bracmat.
Currently, it is implemented for RISC-OS (Archimedes) and 16-bit MS-DOS
versions of Bracmat. All arguments must be integer values. The list of input
values (registers r0 and upwards) need not be complete. Missing values are
assumed to be zero. Blocks of memory should be passed by allocating memory
with<code AAA="aaa"> alc$ </code>and passing the returned value.
The returned value has the form<br ex="ENDEX2" /><br /><br /><br ex="EX2" />(<i>error code</i>.<i>output value</i>,<i>output value</i>,...)<br ex="ENDEX2" /><br /><br /><br ex="EX2" />An error code of 0 means that no error is reported.
In the MS-DOS version, the input registers are AX,BX,CX,DX,BP,SI,DI,DS,ES and
FLAGS, respectively.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} {RISC-OS only}
{?} putstr=(loop,c,buf,ret.        { goal:copy argument to memoryblock }
      alc$(den$sim$(!arg,)+1):?buf:?ret { allocate block for string to fit }
    &amp; get$(!arg,MEM,VAP):?arg      { argument -&gt; single characters }
    &amp; (loop = !arg:%?c ?arg &amp; pok$(!buf.asc$!c.1) &amp; !buf+1:?buf &amp; !loop)
    &amp; ~!loop                       { poke each character into memory block }
    &amp; pok$(!buf.0.1)               { poke string-delimiting zero }
    &amp; !ret)                         { return pointer to block }
{?} putstr$"OS_EvaluateExpression":?inbuf { create pointer to string }
{?} 57:?"OS_SWINumberFromString"   { From manual }
{?} swi$(!"OS_SWINumberFromString".0,!inbuf):(?error.?nummer,?) { find
     interrupt number corresponding with the string "OS_EvaluateExpression"}
{?} fre$!inbuf { deallocate block containing copy of input string }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} {MS-DOS only}
{?} gotoxy = (VIDEO,setCursorPosition,videoPage0.
{?}   16:?VIDEO                 { interrupt number 10H }
{?} &amp; 2*256:?setCursorPosition  { AH }
{?} &amp; 0*256:?videoPage0         { BH }
{?} &amp; !arg:(?x,?y)              { DL and DH }
{?} &amp; swi$(!VIDEO.!setCursorPosition,!videoPage0,0,!x+256*!y)
{?} )
{?} gotoxy$(0,0) &amp; put$(top left corner)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="systxt"><code AAA="aaa">sys$<i>command line commando</i></code></a></h1><br ex="EX2" />In most environments,<code AAA="aaa"> sys$ </code>passes its argument to the command line
interpreter. Therefore,<code AAA="aaa"> sys$ </code>has a functionality that very much depends on
the operating system in which Bracmat runs. One has to take care for
memory limitations and the possibility that<code AAA="aaa"> sys$ </code>may never return.
Possible uses are for example :<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><ul><li> instructions to the video display unit for cursor movement or graphics</li><li> running another program, such as an editor</li><li> manipulation of files (directory listing, copying, etc.)</li></ul><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The functions<code AAA="aaa"> put$(<i>expression</i>,MEM)</code> or<code AAA="aaa"> str$<i>expression</i> </code>may be used for
constructing an argument for<code AAA="aaa"> sys$ </code>:<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} file = bracmat.c
{?} !file:((?stem.?)|?stem) {remove file extension and put result in "stem"}
{?} sys$str$("copy " !file " " !stem.bak)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />The<code AAA="aaa"> sys$ </code>function succeeds, unless a syntactic error was made. If there is an
error at the operating system level, one of the following codes is returned:<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><dl DEF="def"><dt><code FFF="fff">E2BIG</code></dt><dd>   Argument list (which is system-dependent) is too big.</dd><dt><code FFF="fff">ENOENT</code></dt><dd>   Command interpreter cannot be found.</dd><dt><code FFF="fff">ENOEXEC</code></dt><dd>   Command-interpreter file has invalid format and is not executable.</dd><dt><code FFF="fff">ENOMEM</code></dt><dd>   Not enough memory is available to execute command; or available memory
   has been corrupted; or invalid block exists, indicating that process
   making call was not allocated properly.</dd></dl><br ex="ENDEX2" /><br /><br /><br ex="EX2" />If the command succeeds at the operating system level, the value 0 is returned.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="tbltxt"><code AAA="aaa">tbl$(<i>variable</i>,<i>array size</i>)</code></a></h1><br ex="EX2" />The named variable is (re-)sized to an array with <i>array size</i> elements.
Resizing always affects the elements with the highest indexes first :
shrinking means that the last elements are lost, expanding creates new
zero-valued elements at the end.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />If <i>array-size</i> equals zero, the named variable ceases to exist in memory.
This is the only way in Bracmat to get rid of global variables.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Stacks and arrays are exactly the same thing in Bracmat. Therefore, it is not
possible to declare arrays locally.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat never accesses arrays as a whole; there is always just one element that
is in focus. By issuing an instruction of the form<code AAA="aaa"> <i>index</i>$<i>array name</i> </code>or
<code FFF="fff"><i>index</i>'<i>array name</i></code> you can explicitly tell Bracmat to put focus on some
element. Bracmat does this automatically in the case of pushing and popping
local variables onto and from a stack.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} tbl$(bigarray,16000)
{?} lst$bigarray          { this may take a long time to execute }
{?} tbl$(bigarray,0)      { remove bigarray }
{?} lst$bigarray</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="upptxt"><code AAA="aaa">upp$(<i>atom-or-nil</i>)</code></a></h1><br ex="EX2" /><code AAA="aaa">upp$ </code>converts a string to all-uppercase.
The characters 'a'-'z' are converted to 'A'-'Z'. Other characters are handled
as UTF-8 encoded Unicode characters, but default to ISO 8859 (Latin 1) if
the argument is not valid UTF-8.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><span class="arrow">⇒</span><a href="#DOSopttxt" style="line-height:12pt">Codepage 850 support</a><br /><h1><a name="utftxt"><code AAA="aaa">utf$<i>UTF-8 character</i></code></a></h1><br ex="EX2" /><code AAA="aaa">utf$ </code>returns the Unicode code point of the UTF-8 character.
The function fails if the string is too short or too long, or if the sequence
is an invalid UTF-8 string.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />It is safe to use<code AAA="aaa"> utf$ </code>in a pattern:
<code AAA="aaa">@(!txt:(?%c &amp; utf$!c) ?)</code>
If the value of <code FFF="fff">txt</code> starts with an valid UTF-8 sequence, bracmat backtracks
until the value of <code FFF="fff">c</code> matches the UTF-8 sequence.
If <code FFF="fff">txt</code> starts with a sequence that is not UTF-8, bracmat stops backtracking
when that fact has been established.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="whltxt"><code AAA="aaa">|_whl'(<i>expression</i>)</code><code AAA="aaa">_|</code></a></h1><br ex="EX2" />whl' implements a <code FFF="fff">while <i>expression</i></code> loop. The expression is repeatedly evaluated
until it fails. <code FFF="fff">whl'</code> always succeeds. Notice that <code FFF="fff">whl'</code> is faster than loops using tail recursion.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="x2dtxt"><code AAA="aaa">x2d$<i>hexadecimal value</i></code></a></h1><br ex="EX2" /><code AAA="aaa">x2d$ </code>converts an hexadecimal number between 0 and FFFFFFFF to a decimal
number. On 64-bit platforms the upper bound is FFFFFFFFFFFFFFFF.
The function fails if the argument is not a string with a length
between 1 and 8 only containing the characters 0-9, a-f and A-F.<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} x2d$ffffffff</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#inbltmenu" style="line-height:12pt">Built-in functions</a><br /><h1><a name="predefmenu">Predefined functions</a></h1><br ex="EX2" />Besides hard-coded built-in functions, Bracmat offers a number of soft-coded
functions which behave as user defined functions in all respects. They are
redefinable and removable, for example. Some functions are called by the
interpreter itself and should never be changed by the user. Such functions have
names that start with an 8-bit character with the high-bit set. Bracmat has
been drilled to leave these names out when the user asks for a list of variable
names<code AAA="aaa"> (lst$ </code>or<code AAA="aaa"> mem$), </code>so you will not notice their existence. The following
visible functions are predefined:
<br ex="ENDEX2" /><dl><dt><a href="#sgntxt"><code FFF="fff">abs</code></a></dt><dd>    absolute value</dd><dt><a href="#cattxt"><code FFF="fff">cat</code></a></dt><dd>    list existing variable names selectively</dd><dt><a href="#gontxt"><code FFF="fff">cos</code></a></dt><dd>    cosine formula</dd><dt><a href="#factxt"><code FFF="fff">fct</code></a></dt><dd>    factorisation</dd><dt><a href="#flttxt"><code FFF="fff">flt</code></a></dt><dd>    floating point notation of numbers</dd><dt><a href="#outtxt"><code FFF="fff">out</code></a></dt><dd>    output to screen, then new line</dd><dt><a href="#sgntxt"><code FFF="fff">sgn</code></a></dt><dd>    sign</dd><dt><a href="#gontxt"><code FFF="fff">sin</code></a></dt><dd>    sine formula</dd><dt><a href="#subtxt1"><code FFF="fff">sub</code></a></dt><dd>    substitution</dd><dt><a href="#taytxt"><code FFF="fff">tay</code></a></dt><dd>    Taylor series development</dd></dl><span class="arrow">⇑</span><a href="#funcmenu" style="line-height:12pt">functions</a><br /><h1><a name="sgntxt"><code AAA="aaa">abs$<i>expression</i> </code>and<code AAA="aaa"> sgn$<i>expression</i></code></a></h1><br ex="EX2" /><code AAA="aaa">sgn$ </code>determines the sign of the numerical factor of <i>expression</i>. If the sign
is <code FFF="fff">-</code>, then <code FFF="fff">sgn</code> returns <code FFF="fff">-1</code>. In all other cases the returned value is 1.<br ex="ENDEX2" /><br /><br /><br ex="EX2" /><code AAA="aaa">abs$<i>expression</i> </code>is defined as <code FFF="fff">sgn$<i>expression</i>*<i>expression</i></code>.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} sgn$(-1*i)
{?} abs$(-7*a)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><h1><a name="cattxt"><code AAA="aaa">cat$([<i>include list</i>][,[<i>exclude list</i>][,EXT]])</code></a></h1><br ex="EX2" /><code AAA="aaa">cat$ </code>is like the built-in function<code AAA="aaa"> mem$, </code>but offers the possibility to exclude
names that are not in the first parameter and/or to exclude names that are in
the second parameter. The optional third parameter adds information about array
size and current index value, e.g. (arg,5,5). If the first parameter is
missing, this is taken to mean that NO names are excluded (unless by virtue of
the second parameter). You can use<code AAA="aaa"> cat$ </code>to save the state of the variable space
for later use, e.g. removing all variables that have been created since.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} cat$(,,EXT):?save-state  { mem$EXT is also OK. }
{?} newvar1=12345            { create new variables }
{?} tbl$(newvar2,100)
{?} cat$(,!save-state,EXT)   { show the newcomers }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><h1><a name="gontxt"><code AAA="aaa">cos$<i>expression</i> </code>and<code AAA="aaa"> sin$<i>expression</i></code></a></h1><br ex="EX2" />These functions produce cos(expression) and sin(expression), expressed in
powers of <code FFF="fff">e</code>. In this way, expressions with goniometric functions can be
differentiated and, sometimes, simplified.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><h1><a name="factxt"><code AAA="aaa">fct$<i>expression</i></code></a></h1><br ex="EX2" /><code AAA="aaa">fct$ </code>uses some heuristics in trying to factorise <i>expression</i>.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 1+(2*a^3+6/7*t)*(3*x+4*y+z^-1)+-1:?sum
{?} fct$!sum</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><h1><a name="flttxt"><code AAA="aaa">flt$(<i>rational number</i>,<i>number of decimals</i>)</code></a></h1><br ex="EX2" /><code AAA="aaa">flt$ </code>converts a rational number to a floating point presentation. The result
is stored in an atom. This function is meant for output, Bracmat does not use
floating point numbers itself.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} flt$(123/456,78)
{?} flt$(sub$(tay$(sin$x,x,40).x.11/7),12)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><h1><a name="outtxt"><code AAA="aaa">out$<i>expression</i></code></a></h1><br ex="EX2" />Uses the built-in function<code AAA="aaa"> put$ </code>to output <i>expression</i> to the output stream
(usually the screen). Output is ended with a new line. Normally,<code AAA="aaa"> out$ </code>returns
its argument.<code AAA="aaa"> out$ </code>is a good debugging tool, but<code AAA="aaa"> put$ </code>is slightly safer, as it
handles failing arguments in the correct way, contrary to<code AAA="aaa"> out$.</code><br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} put$a &amp; put$b
{?} out$a &amp; out$b</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><span class="arrow">⇒</span><a href="#debugtxt2" style="line-height:12pt">using<code AAA="aaa"> out$ </code>as debugging aid</a><br /><h1><a name="subtxt1"><code AAA="aaa">sub$(<i>expression</i>.<i>pattern</i>.<i>replacement</i></code>)</a></h1><br ex="EX2" />substitution function
argument 1 : subject
argument 2 : pattern
argument 3 : replacement for subexpressions matched by pattern.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><h1><a name="taytxt"><code AAA="aaa">tay$(<i>expression</i>,<i>variable</i>,<i>number of terms</i></code>)</a></h1><br ex="EX2" />A Taylor expansion is applied to <i>expression</i>.
The second argument is the independent variable.
The third argument denotes the number of terms, including vanishing terms.<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} tay$((cos$x)^-1,x,20)</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#predefmenu" style="line-height:12pt">Predefined functions</a><br /><h1><a name="hashtxt">Hash tables</a></h1><br ex="EX2" />If you need to manage a large data set it, may be a good idea to use a hash-
table instead of a list. Storing, retrieving and deleting are costly processes
in lists, but cheap in hash tables. Handling hash tables in Bracmat is very
simple. You create a hash table as follows<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} new$hash:?myhash</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Hereafter, <code FFF="fff">myhash</code> refers to a hash table and is treated in the same way as
a user defined object. Bracmat keeps the load factor between 50 and 100,
rehashing as necessary.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />If you know the hash table is going to be much bigger than about 100 bins, you
can suggest the size of the table to Bracmat, but this is not necessary:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} new$(hash,1000000):?mybiggerhash</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />This tells Bracmat to start off with a million bins.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />The following methods are defined for hash tables:<br ex="ENDEX2" /><dl><dt><a href="#findtxt"><code FFF="fff">find</code></a></dt><dd>    find all values for a given key</dd><dt><a href="#inserttxt"><code FFF="fff">insert</code></a></dt><dd>    insert a value for a key</dd><dt><a href="#removetxt"><code FFF="fff">remove</code></a></dt><dd>    remove a key and all its values</dd><dt><a href="#Newtxt"><code FFF="fff">New</code></a></dt><dd>    creates a hash table, cannot be called programmatically</dd><dt><a href="#Dietxt"><code FFF="fff">Die</code></a></dt><dd>    cleans up a hash table, cannot be called programmatically</dd><dt><a href="#ISOtxt"><code FFF="fff">ISO</code></a></dt><dd>    make all key access case-insensitive</dd><dt><a href="#casesensitivetxt"><code FFF="fff">casesensitive</code></a></dt><dd>    make all key access case sensitive. (Default)</dd><dt><a href="#foralltxt"><code FFF="fff">forall</code></a></dt><dd>    apply a function to all key-value pairs</dd></dl><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="findtxt"><code AAA="aaa">|_(myhash..find)$key:(?Key.?Value)</code><code AAA="aaa"> ?OtherKeyValuePairs_|</code></a></h1><br ex="EX2" />Returns a blank-separated list of key-value pairs, all with the same key.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#hashtxt" style="line-height:12pt">Hash tables</a><br /><h1><a name="inserttxt"><code AAA="aaa">(myhash..insert)$(Key.Value)</code></a></h1><br ex="EX2" />Inserts the key <code FFF="fff">Key</code> with the value <code FFF="fff">Value</code>. Multiple values for the same key are
possible and the same value can be inserted more than once for the same key.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#hashtxt" style="line-height:12pt">Hash tables</a><br /><h1><a name="removetxt"><code AAA="aaa">(myhash..remove)$key:?KeyValuePairs</code></a></h1><br ex="EX2" />Removes the key with all its values and returns a blank-separated list of
key-value pairs.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#hashtxt" style="line-height:12pt">Hash tables</a><br /><h1><a name="Newtxt">New</a></h1><br ex="EX2" />This is a method of the hash class that is called by the system when it
evaluates<code AAA="aaa"> new$hash. </code>It cannot be called from user code.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#hashtxt" style="line-height:12pt">Hash tables</a><br /><h1><a name="Dietxt">Die</a></h1><br ex="EX2" />This method is called when a hash object is deleted. It is not directly
called from user code. (Compare with a<code AAA="aaa"> C++ </code>destructor). You can add your own
clean up code by writing a <code FFF="fff">die</code> method and adding it to a hash object once it
is created. Example:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} new$hash:?myhash; { create a hash table myhash }
{?} ((
    =   ( Insert                       { Add a method 'Insert' to myhash that
                                         only allows one value per key. }
        =   K,V
          .     !arg:(?K.?V)
              &amp; (Its..find)$!K:(?.?v)
              &amp;   out
                $ ( str
                  $ ( "Key "
                      !K
                      " already present"
                      ( !V:!v&amp;" with same"
                      | ", but with different"
                      )
                      " value "
                      !v
                    )
                  )
            | (Its..insert)$!arg
        )
        (die=.out$"Oh my dear")        { This method is called just before
                                         the object is deleted. }
    )
  : (=?(myhash.)))</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} (myhash..Insert)$(X.12);                { Insert the value 12 for key X. }
{?} (myhash..Insert)$(X.12);                { Try to do it one more time. }
{?} (myhash..Insert)$(X.10);                { Try to insert another value
                                              for the same key.}
{?} (myhash..insert)$(Z.1);                 { Use the built-in insert method.}
{?} (myhash..insert)$(Z.1);                 { Insert same value again. }
{?} (myhash..insert)$(Z.2);                 { Also insert a different value. }
{?} (myhash..find)$X;                       { Show all key-value pairs of X.
                                                             (only 1) }
{?} (myhash..find)$Z;                     { Show all key-value pairs of Z.(3)}
{?} (myhash..remove)$Z:?values;
{?} :?myhash;                               { Get rid of the hash table. }</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#hashtxt" style="line-height:12pt">Hash tables</a><br /><h1><a name="ISOtxt"><code AAA="aaa">(myhash..ISO)$</code></a></h1><br PECH="PECH" /><br ex="EX2" />Make all key access case-insensitive. This applies to the full Unicode table,
but defaults to ASCII and the upper 128 characters in the ISO8859-1 (Latin 1)
character set if the characters are not UTF-8 encoded.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#hashtxt" style="line-height:12pt">Hash tables</a><br /><h1><a name="casesensitivetxt"><code AAA="aaa">(myhash..casesensitive)$</code></a></h1><br ex="EX2" />Make all key access case sensitive. This the default.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#hashtxt" style="line-height:12pt">Hash tables</a><br /><h1><a name="foralltxt"><code AAA="aaa">(myhash..forall)$<i>Function</i></code></a></h1><br ex="EX2" />Apply the function to all key-value pairs. The function can be specified
by its name or by its function body. The forall method finishes when all
elements are traversed or before that if the function fails. The behaviour of
forall is undefined if the hash table is changed or deleted during the
traversal, although this can be done safely. For example may some members be
missed and others be processed more than once.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Example:<br ex="ENDEX2" /><br /><br /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} new$hash:?myhash; { create a hash table myhash }
{?} (myhash..insert)$(X.12);                { Insert the value 12 for key X. }
{?} (myhash..insert)$(Z.1);                 { Use the built-in insert method.}
{?} ( (myhash..forall)                      { Output all key-value pairs. }
    $ (
      =   Key,Value,loop
        .   ( loop
            =   !arg:(?Key.?Value) ?arg
              &amp; out$(str$("Key=" !Key  " Value=" !Value))
              &amp; !loop
            )
          &amp; ~!loop
      )
    )</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#hashtxt" style="line-height:12pt">Hash tables</a><br /><h1><a name="filosofie">How Bracmat evolved</a></h1><br ex="EX2" />Bracmat originated from a Basic program that was meant (and able) to do some
algebraic calculations in General Relativity. This program could do the
mathematical operations that Bracmat can: add, multiply, take powers and
logarithms and differentiate. This calculator was not programmable, all
program flow had to be done in Basic. It became clear that the program could
only solve the simplest algebraic problems. The reason for this was its
inability to recognise complex patterns in the subject expressions. All
pattern recognition had to be done in Basic and this was a very fault prone
business. It would be nice to have an interpreter at hand that could interpret
human readable production rules. That is exactly what Bracmat embodies.
This program is written in ANSI-C and developed on the fastest home computer
that existed at that time (Acorn Archimedes). Although Bracmat is much faster
than its predecessor, its main virtue lies in its programmability. The speed
at which it processes formulae is not impressive, Bracmat needs a fast machine.
Unlike many other algebra systems, its grammar has no relationship to the Algol
grammar. Instead, the language component extends the syntax of simple algebraic
formulae.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Compared with other algebra systems, Bracmat has few built-in functions and
even its set of mathematical operators is small. There are no operators for
subtraction and division, for example. Nevertheless, Bracmat is general and
flexible enough to be able to solve even problems outside the field of computer
algebra in an elegant way. This flexibility on the programming level is traded
off against the inability to change the behaviour of the interpreter itself.
There are no switches (toggles) that could influence, for example, the order of
terms within a polynomial, or whether or not complex products are expanded, or
the way backtracking is done. This choice was, of course, easier to implement,
but it also has benefits for the user: the working of Bracmat programs is not
obscured by deep side effects of switch settings. The only side effects that
Bracmat allows are expression binding and change of focus in a multiple valued
variable (array indexing, stacking). A later addition is support of objects,
i.e. data structures that allow for partial updates. This introduced another
kind of side effect.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />One peculiar thing about the original, object-less Bracmat is
the way in which it manages data:<ol><li>  Processes are not periodically interrupted for garbage collection.</li><li>  Each piece of data has a reference counter. If the reference counter equals
    zero, the occupied memory is returned to the memory pool at once. If the
    reference counter is about to overflow, a fresh copy of this piece of data
    is made with a reference counter set to one. For objects, the reference
    counter counts to approximately 4000000000, making overflow practically
    impossible.</li><li>  Data is only created and destroyed. It is never changed.</li><li>  To the user, there is no difference between two expressions being equal,
    but stored in different parts of memory, and two expressions being two
    representations of the same parts of memory.</li><li>  There is no facility for named fields within a data structure.</li></ol><p><br ex="EX2" />Leaving one of these features out would have severe consequences for the other
features. (2) explains why (1) is true. (3) ensures that (2) is workable: if two
pieces of data are created equal they will remain so. This, in turn, explains
why (4) is true. (5) almost follows from (3) : in any full fledged programming
language, named fields allow all types of actions on the named parts of a
data structure that are allowed on whole data structures, that is: creation
and destruction. But the possibility to destroy only part of a data structure
means that the data structure as a whole is changeable, which violates (3).<br ex="ENDEX2" /></p><br ex="ENDEX2" /><br /><br /><br ex="EX2" />In the current version of Bracmat, with objects, the last restriction (5)
no longer exists. As a consequence, restrictions (3) and (4) are not true for
objects. (2) needs the additional remark that the reference counter for objects
is made so big (counts to more than 4000000000), that overflow is practically
impossible. Restriction (1) is still true, which means that the Bracmat
programmer must take care of the deletion of some pathological structures
(to be precise: circular structures, which were non-existent in the
object-less Bracmat).<br ex="ENDEX2" /><br /><br /><br ex="EX2" />How can a programming language that is created for handling data structures
do without named fields<code BBB="bbb"> ? </code>If I only can create and destroy data, how can I let
data evolve gradually, piecemeal<code BBB="bbb"> ? </code>The answer lies in the well-developed
pattern matching mechanism. Change of data is a two step process. In the first
step you retrieve, by means of pattern matching, all those parts of the data
that you want to keep. The second step is building the new data from the
retrieved parts, together with new pieces. Creation of complex data structures
from parts is straightforward in Bracmat. For example, the variable Row is a
list of three words. We want to change the second word into the word <code FFF="fff">cat</code>:<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} the dog runs:?Row     {initial creation}
{?} !Row:%?one % %?three  {step 1: retrieval of 1st and 3rd word}
{?} !one cat !three:?Row  {step 2: reconstruction}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" />This may seem complicated and cumbersome, but look at this:<br ex="ENDEX2" /><br ex="EX" /><blockquote pech="EXAMPL"><pre>{?} 123:?a                  {create three variables a,b and c}
{?} a sentence:?b
{?} (a.silly,data*structure):?c
{?} (!a.!b.!c):(?b.?c.?a)   {permutation of 3 values in just 1 "statement"}</pre></blockquote><br ex="ENDEX" /><br ex="EX2" /><br ex="ENDEX2" /><br /><br /><br ex="EX2" />Bracmat has no clear genealogy, but it has borrowed features from a number of
programming languages. It is not declarative, like Prolog, nor deeply object
oriented, like Smalltalk, but it is more or less procedural, like the majority
of languages. Below, I have tried to make the origin of some details more
explicit:<br /> C:<ol><li> conditional execution of right operands of "and" and "or"</li><li> parameter passing (only "by value")</li></ol><p><br ex="EX2" />Pascal:<br /> locally defined functions and routines
 Lisp:<ol><li> implementation of expressions in binary trees</li><li> weak type checking</li><li> late binding
 Logo:
 different notations for the same variable, depending on whether it
 produces or receives a value
 Snobol,Icon :
1) a well developed pattern matching apparatus including backtracking
2) dual results of evaluations : both value and success/failure</li></ol><p><br ex="EX2" />Every similarity to other computer algebra systems is a matter of evolutionary
convergence.<br ex="ENDEX2" /></p><br ex="ENDEX2" /></p><br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="Bracmat-name">Why the name 'Bracmat'?</a></h1><br ex="EX2" />The name Bracmat stems from Ludvig Holbergs novel 'Nicolai Klimii iter
subterraneum', the history of Niels Klim who visits the planet Nazar and
comments the habits of its inhabitants. For example, the people of the country
Bracmat are clumsy juniper trees and Niels Klim initially thinks they must be
more or less blind. But he discovers that their sight is so sharp that they
can see the smallest details in the far distance and therefore don't see
what is right in front of them. They are mostly occupied with astronomy and
transcendental philosophy, but the state also uses them to do prospection
for minerals in the mines.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />It so happens that the Latin word 'brachiatus', meaning 'with arms' or
'with branches', in litterature of botany often is shortened to 'brachiat.'.
I like to think that Ludvig Holberg, who wrote the story in 1742, knew about
the works of Carl Linnaeus (1707 - 1778) and was inspired by him to populate
his planet with smart trees. The word 'Bracmat' is only a ligature away from
the word 'brachiat.'! Whether true or not, this derivation highlights one
of the most prominent characteristics of the programming language Bracmat:
it is all about tree branches.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="colofon">How to obtain Bracmat</a></h1><br ex="EX2" />There are a few download options. You can get the last revision from
<a href="https://github.com/BartJongejan/Bracmat">https://github.com/BartJongejan/Bracmat</a>.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />At <a href="http://cst.dk/download/bracmat/">http://cst.dk/download/bracmat/</a> you can follow the history of Bracmat from
its inception somewhere in the eighties up to the last version. At this site
you can also find compiled versions for some platforms.<br ex="ENDEX2" /><br /><br /><br ex="EX2" />Alternatively, you can obtain a copy of Bracmat by sending an e-mail to me
(Bart Jongejan) at<code AAA="aaa"> bart[AT]cst.dk. </code>Please state your hardware/OS.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><h1><a name="morexmlps">more example code</a></h1><br ex="EX2" />At <a href="http://rosettacode.org/wiki/Category:Bracmat">http://rosettacode.org/wiki/Category:Bracmat</a> over 100 tasks are solved
using Bracmat. The site is an excellent way to compare how the same task is
solved in a great number of programming languages.<br ex="ENDEX2" /><br /><br /><span class="arrow">⇑</span><a href="#lusmenu" style="line-height:12pt">                       BRACMAT                       </a><br /><a href="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-xhtml10-blue" alt="Valid XHTML 1.0 Strict" height="31" width="88" /></a></body></html>