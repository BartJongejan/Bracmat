{xmlio.bra

Reads document that has been converted from XML to Bracmat and writes the data
as an XML-file. This file should be exactly the same as the original XML file.

Tip to the programmer: Let Bracmat nicely format this source code. Here is how:

If xmlio.bra is loaded interactively in Bracmat (type get$"xmlio.bra" 
after the prompt), typing !rxmlio after the prompt rereads the program and saves it
to disk after renaming the original file to xmlio.bak. The newly saved
xmlio.bra is nicely formatted.

Handy if your latest changes to xmlio.bra 
have been detrimental to the lay-out!

}

XMLIO=
  ( nest
  =   a L B s e x
    .   :?L
      & whl'(!arg:%?a ?arg&!a !L:?L)
      & !L:?arg
      & :?L:?B:?s
      &   whl
        ' ( !arg:%?a ?arg
          & (   !a:(.?e.)
              & (!L.) !B:?B
              & :?L
              & !e !s:?s
            |     ( !a:(?e.?,?)&!a
                  |   !a:(?e.?x)
                    & (   !s:!e ?s
                        &   (!e.!x,!L)
                            (!B:(%?L.) ?B&)
                      | !a
                      )
                  | !a
                  )
                  !L
              : ?L
            )
          )
      & !L
  )
  ( encoding
  =   enc tst meta head h m
    .   :?enc
      & ( charset
        =   ? (charset.?enc) ?
          | ? (content.@(?:? charset ? "=" ?enc)) ?
        )
      & ( meta
        = ? (~<>meta.(!charset,?)|!charset) ?
        )
      & ( head
        =     ?
              (~<>head.(?,!meta)|?&~`)
              ?
          |   ? (~<>head:?h.?) ?m (.!h.) ?
            & !m:!meta
        )
      & (   !arg
          : (   @
                ( "?"
                . @( ?
                   :   ~<>XML
                       (   ?
                           encoding
                           ?
                           "="
                           ?
                           (\" ?enc \"|"'" ?enc "'")
                           ?
                       | ?&utf-8:?enc
                       )
                   )
                )
                ?
            |   ?
                (~<>html.(?,!head)|?&~`)
                ?
            | ? (~<>html.?) !head
            )
        | 
        )
      & ( !enc:~
        |   !arg:? ("!DOCTYPE".@(?:? html ?)) ?
          & utf-8
          | 
        )
  )
  ( convert
  =   xml O enc
    .   !arg:?xml
      & :?O
      & chr$127:?big
      & ( add
        = a.whl'(!arg:%?a ?arg&!a !O:?O)
        )
      &     
          ' ( a c n
            .     @(!arg:?a (>%@($big) ?:?arg))
                & ( @(!arg:(%?c&utf$!c:?n) ?arg)
                  | @(!arg:(%?c&asc$!c:?n) ?arg)
                  )
                & !a "&#" !n ";" ASC$!arg
              | !arg
            )
        : (=?ASC)
      &     
          ' ( a c n
            .     @(!arg:?a (>%@($big) ?:?arg))
                & (   @( !arg
                       : (%?c&utf$!c:?n) ?arg
                       )
                    & (   !n:>255
                        & !a "&#" !n ";" ISO$!arg
                      | !a chr$!n ISO$!arg
                      )
                  | !a !arg
                  )
              | !arg
            )
        : (=?ISO)
      &     
          ' ( a c n
            .     @(!arg:?a (>%@($big) ?:?arg))
                & (   @(!arg:(%?c&utf$!c:?n) ?)
                    & !a !arg
                  |   @( !arg
                       : (%?c&asc$!c:?n) ?arg
                       )
                    & !a chu$!n UTF$!arg
                  )
              | !arg
            )
        : (=?UTF)
      &   (its.encoding)$!arg
        : ( ~<>utf-8&UTF:?FUN
          | ~<>iso-8859-1&ISO:?FUN
          | ?&ASC:?FUN
          )
      & chr$127:?DEL
      & '($FUN)$!a:(=?AA)
      & '($FUN)$!arg:(=?ARG)
      &     
          ' ( a b
            .     @(!arg:?a "&" ?arg)
                & $AA "&amp;" "&"$!arg
              | $ARG
            )
        : (=?"&")
      &     
          ' ( a b
            .     @(!arg:?a ()$DEL ?arg)
                &   "&"$!a
                    (@(!arg:%?b ?arg)&!b)
                    ESC$!arg
              | "&"$!arg
            )
        : (=?ESC)
      &     
          ' ( a
            .     @(!arg:?a "<" ?arg)
                & ESC$!a "&lt;" lt$!arg
              | ESC$!arg
            )
        : (=?lt)
      & ( gt
        =   a
          .     @(!arg:?a ">" ?arg)
              & lt$!a "&gt;" gt$!arg
            | lt$!arg
        )
      & ( \"
        =   a
          .     @(!arg:?a \" ?arg)
              & gt$!a "&quot;" \"$!arg
            | gt$!arg
        )
      & ( "'"
        =   a
          .     @(!arg:?a "'" ?arg)
              & \"$!a "&apos;" "'"$!arg
            | \"$!arg
        )
      & ( atts
        =   a v
          .     !arg:(?a.?v) ?arg
              & " " gt$!a "=\"" "'"$!v \" atts$!arg
            | 
        )
      & ( write
        =   xml car A B C att
          .   !arg:?xml
            &   whl
              ' ( !xml:%?car ?xml
                & (   !car:(?A.?B)
                    & (   !B:(?att,?C)
                        & (   !C:
                            & add$("<" !A atts$!att " />")
                          |   add$("<" !A atts$!att ">")
                            & (   !A:(~<>script|~<>style)
                                & add$!C
                              | write$!C
                              )
                            & add$("</" !A ">")
                          )
                      |   !A
                        : (   
                            & !B:(?B.)
                            & add$("</" gt$!B ">")
                          | "!"&add$("<!" !FUN$!B ">")
                          | "!--"&add$("<!--" !FUN$!B "-->")
                          | "?"&add$("<?" !FUN$!B "?>")
                          |   "![CDATA["
                            & add$("<![CDATA[" !FUN$!B "]]>")
                          |   "!DOCTYPE"
                            & add$("<!DOCTYPE" !FUN$!B ">")
                          | ?&add$("<" !A atts$!B ">")
                          )
                      )
                  | add$(gt$!car)
                  )
                )
        )
      & write$!xml
      &   str
        $ ( ( 
            =   a L
              .   :?L
                &   whl
                  ' (!arg:%?a ?arg&!a !L:?L)
                & !L
            )
          $ !O
          )
  )
  ( new
  =   doc docnested rem
    .   get$(!arg,X,HT,ML):?doc
      & lst$(doc,str$(!arg ".bra"),NEW)
      & out$(str$("Encoding, unnested:[" (its.encoding)$!doc "]"))
      & put$Enter
      & get'
      & (its.nest)$!doc:?docnested
      & out$(str$("Encoding, nested:[" (its.encoding)$!docnested "]"))
      & put$Enter
      & get'
      & lst$(docnested,str$(!arg ".nested.bra"),NEW)
      &   put
        $ ( (its.convert)$!docnested
          , str$(!arg ".nested.bra.html")
          , NEW
          , BIN
          )
      & 
  );

rxmlio=
  get'("xmlio.bra",TXT)
& sys$(str$(del " " xmlio ".bak"))
& sys$(str$(ren " " "xmlio.bra" " " xmlio ".bak"))
&   put
  $ ( "{xmlio.bra

Reads document that has been converted from XML to Bracmat and writes the data
as an XML-file. This file should be exactly the same as the original XML file.

Tip to the programmer: Let Bracmat nicely format this source code. Here is how:

If xmlio.bra is loaded interactively in Bracmat (type get$\"xmlio.bra\" 
after the prompt), typing !rxmlio after the prompt rereads the program and saves it
to disk after renaming the original file to xmlio.bak. The newly saved
xmlio.bra is nicely formatted.

Handy if your latest changes to xmlio.bra 
have been detrimental to the lay-out!

}

"
    , "xmlio.bra"
    , NEW
    , BIN
    )
& lst'(XMLIO,"xmlio.bra",APP)
& put'(\n,"xmlio.bra",APP,BIN)
& lst'(rxmlio,"xmlio.bra",APP)
& ;
