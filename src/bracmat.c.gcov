        -:    0:Source:bracmat.c
        -:    0:Graph:bracmat.gcno
        -:    0:Data:bracmat.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:    Bracmat. Programming language with pattern matching on tree structures.
        -:    3:    Copyright (C) 2002  Bart Jongejan
        -:    4:
        -:    5:    This program is free software; you can redistribute it and/or modify
        -:    6:    it under the terms of the GNU General Public License as published by
        -:    7:    the Free Software Foundation; either version 2 of the License, or
        -:    8:    (at your option) any later version.
        -:    9:
        -:   10:    This program is distributed in the hope that it will be useful,
        -:   11:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:    GNU General Public License for more details.
        -:   14:
        -:   15:    You should have received a copy of the GNU General Public License
        -:   16:    along with this program; if not, write to the Free Software
        -:   17:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
        -:   18:*/
        -:   19:/*
        -:   20:email: bartj@hum.ku.dk
        -:   21:*/
        -:   22:/*
        -:   23:COMPILATION
        -:   24:-----------
        -:   25:It is assumed that the hardware is litte-endian, (which has become the most
        -:   26:common these days).
        -:   27:
        -:   28:If you can compile successfully but cannot run the program succesfully,
        -:   29:try putting -DBIGENDIAN on the command line of the compiler.
        -:   30:This works of course only if the machine's hardware is big-endian.
        -:   31:
        -:   32:The program only utilizes standard libraries.
        -:   33:
        -:   34:Until 2012, the source code consisted of a single file, bracmat.c.
        -:   35:Because XML is becoming more popular, a separate source file, xml.c
        -:   36:implements reading XML files.
        -:   37:
        -:   38:On *N?X, just compile with
        -:   39:
        -:   40:    gcc -std=c99 -pedantic -Wall -O3 -static -DNDEBUG -o bracmat bracmat.c xml.c
        -:   41:
        -:   42:
        -:   43:The options are not necessary to successfully compile the program just
        -:   44:
        -:   45:    gcc *.c
        -:   46:
        -:   47:also works and produces the executable a.out.
        -:   48:
        -:   49:Profiling:
        -:   50:
        -:   51:    gcc -Wall -c -pg -DNDEBUG bracmat.c xml.c
        -:   52:    gcc -Wall -pg bracmat.o xml.o
        -:   53:    ./a.out 'get$"valid.bra";!r'
        -:   54:    gprof a.out
        -:   55:
        -:   56:Test coverage:
        -:   57:(see http://gcc.gnu.org/onlinedocs/gcc/Invoking-Gcov.html#Invoking-Gcov)
        -:   58:
        -:   59:    gcc -fprofile-arcs -ftest-coverage -DNDEBUG bracmat.c xml.c
        -:   60:    ./a.out
        -:   61:    gcov bracmat.c
        -:   62:    gcov xml.c
        -:   63:
        -:   64:*/
        -:   65:
        -:   66:#define DATUM "1 November 2012"
        -:   67:#define VERSION "6"
        -:   68:#define BUILD "141"
        -:   69:/*  1 November 2012
        -:   70:Function someopt() conditionally excluded with 
        -:   71:  #if !defined NO_LOW_LEVEL_FILE_HANDLING
        -:   72:
        -:   73:    21 October 2012
        -:   74:Made sure that put$ cannot write to a file that is still open in get$.
        -:   75:
        -:   76:    17 October 2012
        -:   77:In evalvar, the assumption that shared = false is false.
        -:   78:
        -:   79:    15 October 2012
        -:   80:Added 8 byte peek and poke (pee, pok) (perhaps not on all 32 bit platforms).
        -:   81:Default is now 1 byte.
        -:   82:
        -:   83:    14 October 2012
        -:   84:flg$(=~exp):(=?f.?o)  !f now fails, as it should.
        -:   85:Relaxed requirement that parameters be separated with comma for function sim.
        -:   86:new$(hash,1000) gives a hint at the initial size of the hash table.
        -:   87:Default is 97.
        -:   88:
        -:   89:    12 October 2012
        -:   90:Found some places in plus_samenvoegen_of_sorteren that were never reached,
        -:   91:commented these.
        -:   92:
        -:   93:    23 September 2012
        -:   94:Discovered buffer overflow when compiled under fresh installation of Xubuntu 
        -:   95:gcc (Ubuntu/Linaro 4.6.3-1ubuntu5) 4.6.3 with optimization -O1 and higher.
        -:   96:Cause: strcpy in some places got the address of a single byte as destination
        -:   97:and coredumped when that single-byte buffer was overrun, not knowing that
        -:   98:there was, in fact, allocated memory to house the fulle source. See definition
        -:   99:of POBJ.
        -:  100:
        -:  101:    22 September 2012
        -:  102:Discovered that built in objects too easily were copied. The new function is
        -:  103:for that. Worse, the copies were not initialized with a call to New. Also,
        -:  104:new$hash returned ((=).New)'. Now it returns the object node. Changed the rhs
        -:  105:of this node to the node that is the argument of the original call to new, so:
        -:  106:  =hash
        -:  107:
        -:  108:    20 September 2012
        -:  109:Reference counting should now be faster, bigger and better.
        -:  110:Before, reference counting went to 2^30+1024. Now it goes to 2^30*1023+1
        -:  111:Test added to valid.bra.
        -:  112:
        -:  113:    19 September 2012
        -:  114:Made major changes in Naamwoord, Naamwoord_w and doPosition to make two levels
        -:  115:of indirection work also in the case that an object is at the first level.
        -:  116:Handling of two levels of indirection is improved generally.
        -:  117:
        -:  118:    16 September 2012
        -:  119:Using gcov, found some places that are unreachable in merge(), substdiff() and
        -:  120:evalvar(). Simplified substdiff. Function evalvar now expects that the argument
        -:  121:is not shared. Deleted code that was never reached.
        -:  122:
        -:  123:    12 September 2012
        -:  124:Updated u2l and l2u with data from UnicodeData.txt 2011-11-08
        -:  125:(using script uni.bra)
        -:  126:
        -:  127:    22 August 2012
        -:  128:Bug removed. The expression
        -:  129:    ( (=A B)
        -:  130:    : ?G1
        -:  131:    : (=(A&X:?(G1.)) B)
        -:  132:    )
        -:  133:would not match the 'B' in the pattern with anything valid, because the 
        -:  134:assignment X:?(G1.) had deleted the original subject. Now the subject is
        -:  135:temporarily reference-incremented, so the 'B' still matches the old value of
        -:  136:G1. The expression as a whole evaluates to X. Notice that this bug did not
        -:  137:affect the very similar
        -:  138:    ( (G2==A B)
        -:  139:    & !G2
        -:  140:    : (=(A&X:?(G2.)) B)
        -:  141:    )
        -:  142:Reason: here, the subject is not the object that G1 is bound to, but a copy.
        -:  143:And that is so because the object that G1 is bound to is headed by an
        -:  144:unevaluated = (being part of the rhs of an = operator). The expression !G2,
        -:  145:however, must be evaluated, so it cannot be identical to G2's value.
        -:  146:Consequently, the reassignment of G2 does not affect the subject of the
        -:  147:pattern match operation, which is (=A B) at all times.
        -:  148:
        -:  149:     4 August 2012
        -:  150:Removed function "?"$<expr>. The same effect is obtained by <expr>:?!(=)
        -:  151:
        -:  152:    31 July 2012
        -:  153:Made code gcc -pedantic proof. There are two string constants with a length
        -:  154:greater than 509, which ISO C89 compilers are required to support. Therefore
        -:  155:the option -std=c99 is added.
        -:  156:The LL suffix is replaced by L for non-Microsoft compilers.
        -:  157:
        -:  158:     8 July 2012
        -:  159:Added explanation and two small improvements to nextprime()
        -:  160:
        -:  161:     2 July 2012
        -:  162:
        -:  163:Since build 115 (9 February 2012), the version should have read '6',
        -:  164:not '5'. (This was the date when bracmat w√°s brought to GitHub.)
        -:  165:Changes in bmalloc that makes it possible to compile with -O3.
        -:  166:Changed 'unsigned char' to 'char' in a lot of places to make some
        -:  167:warnings go away when compiled with gcc.
        -:  168:
        -:  169:    22 June 2012
        -:  170:
        -:  171:Correction in scompare(). The expression @(1b:~<1 b) did not evaluate 
        -:  172:successfully, which it should. Did a clean-up of this function.
        -:  173:
        -:  174:    4 June 2012
        -:  175:
        -:  176:Introduced READMARKUPFAMILY macro to turn xml-stuff on (1) or off (0)
        -:  177:
        -:  178:    2 June 2012
        -:  179:
        -:  180:xml.c supports reading from stdio (no rewind). Example of use:
        -:  181:type pr-xml-utf-8.xml | bracmat "put$(get$(,ML),\"pr-xml-utf-8.bra\",NEW)&"
        -:  182:
        -:  183:    1 June 2012
        -:  184:
        -:  185:Did some finishing, no essential code changes.
        -:  186:
        -:  187:    1 May 2012
        -:  188:
        -:  189:Added list of HTML entities. These are decoded to unicode codepoints and
        -:  190:encoded as utf-8 if an option HT is added.
        -:  191:
        -:  192:get$("filename.html",HT,ML,TRM)
        -:  193:
        -:  194:   29 April 2012
        -:  195:
        -:  196:Restructured the (ancient) input function and renamed some identifiers to
        -:  197:English equivalents.
        -:  198:Added a source file, xml.c, that reads SGML, HTML and XML files.
        -:  199:Syntax:
        -:  200:
        -:  201:get$(filename,ML)
        -:  202:get$(filename,ML,TRM)
        -:  203:get$(string,MEM,ML)
        -:  204:get$(string,MEM,ML,TRM)
        -:  205:
        -:  206:An option HT is made, but does not work yet. Purpose: translate HTML entities.
        -:  207:
        -:  208:   13 April 2012
        -:  209:
        -:  210:The characters @ and % in front of a string now only turn off escaping with the
        -:  211:\ character inside the string if the string is surrounded by " characters.
        -:  212:Reason: the \L operator was not recognised if its lhs contained a % or @.
        -:  213:
        -:  214:   23 February 2012
        -:  215:
        -:  216:When Bracmat reads a file that is not well-formed, it asks fo a file name where
        -:  217:it can write what it has understood. This did not work. Now it does.
        -:  218:
        -:  219:    9 February 2012
        -:  220:
        -:  221:Corrected error in doPosition that was introduced with the latest
        -:  222:optimizations.
        -:  223:
        -:  224:    4 February 2012
        -:  225:
        -:  226:Discovered that "greater than" relation implemented in the vgl function
        -:  227:wasn't transitive:
        -:  228:(1a.)+(10.)      -> (10.)+(1a.)
        -:  229:(1a.)+(10.)+(2.) -> (1a.)+(2.)+(10.)
        -:  230:Thus the order of (10.) and (1a.) depends on other terms.
        -:  231:Now the rule is: 
        -:  232:1) any number is smaller than any non-number
        -:  233:2) numbers are compared numerically
        -:  234:3) non-numbers are compared with strcmp
        -:  235:
        -:  236:    25 January 2012
        -:  237:
        -:  238:Improved handling of negative positions (positions counted from the end)
        -:  239:in lists, sums and products.
        -:  240:
        -:  241:    24 January 2012
        -:  242:
        -:  243:doPosition is buggy
        -:  244:    a (c,d): ? [-1
        -:  245:
        -:  246:expressionLength  counts the wrong way. It must look at the top level operator 
        -:  247:in the pattern containing the [ and count 1 + the number of this operator 
        -:  248:until the end of the list. 0 if [ is last in the pattern.
        -:  249:
        -:  250:    20 January 2012
        -:  251:
        -:  252:The previous change moved the scanning pointer to the point in the subject
        -:  253:where the rhs pattern starts. The current change moves the end of the
        -:  254:subject as far as necessary to the right to allow a full match of the rhs
        -:  255:pattern with last characters of the subject. Of course, this is only possible
        -:  256:if the final zero byte has not been reached. The calling instance of
        -:  257:stringmatch defines the end of the subject for the called instance. The called
        -:  258:instance can propose to move the end. In this way, scanning can move much
        -:  259:faster if a patterns contains some fixed strings. Speed-up does not work for
        -:  260:alternations of fixed srings. Speed-up only works for the first pattern
        -:  261:in a series of patterns connected by :
        -:  262:
        -:  263:    7 January 2012
        -:  264:
        -:  265:If an non-initial part of a stringpattern is a string, then the scanning
        -:  266:pointer jumps to the first (or next) occurrence in the subject string after
        -:  267:the first mismatch.
        -:  268:
        -:  269:This changes the behaviour of some patterns, such as in
        -:  270:@(abXk:(|? b|`) X ?id)
        -:  271:Before, the match failed, because the 'b' in the pattern did not match the
        -:  272:'a' in the subject. Now, nowing that the first X occurs in the third position,
        -:  273:the pattern matcher not even tries to match 'a' and 'b' and so the expression
        -:  274:succeeds. In many cases the (|? b|`) pattern works as before, though:
        -:  275:@(abXk:(|? b|`) (X|Y) ?id)
        -:  276:@(abXk:(|? b|`) () X ?id)    dangerous! Does not work in @(ab:(|? b|`) ())
        -:  277:@(abXk:(|? b|`) !(=X) ?id)
        -:  278:X:?x
        -:  279:@(abXk:(|? b|`) !x ?id)
        -:  280:
        -:  281:It is not advisable to use this pattern anymore. It is too much dependent on
        -:  282:pattern matching not being optimized.
        -:  283:
        -:  284:    6 January 2012
        -:  285:
        -:  286:Compiled 64 bit version with VS 2008. Had to use _WIN64 and some #defines,
        -:  287:because longs are 32 bit under VS 2008, whereas longs under gcc are 64 bits.
        -:  288:Also used the 64 bit versions of ftell and fseek in the VS 2008 case.
        -:  289:
        -:  290:I have these preprocessor defines
        -:  291:NDEBUG;__CONSOLE__;__WIN32__;WIN32;_CONSOLE;_CRT_SECURE_NO_WARNINGS
        -:  292:
        -:  293:(Some of these are automatically set in the 32 bit version).
        -:  294:For 64 bit
        -:  295:
        -:  296:Impression is that the 32 bit version should be used unless you have to deal
        -:  297:with enormous data (memory, file) or huge numbers (because numerical
        -:  298:computations are faster and bigger numbers can be factorized quickly using
        -:  299:exponentiation with a fractional exponent).
        -:  300:Otherwise, the 64 bit version is significantly slower and has almost three
        -:  301:times less stack depth.
        -:  302:
        -:  303:    2 January 2012
        -:  304:
        -:  305:Made stringmatch 'greedy' to an extend that does not change the program's
        -:  306:behaviour. (That is: all tests in valid.bra go through). Many string
        -:  307:comparisons now continue past the cutoff position deviding the subject in a
        -:  308:lhs and a rhs, pushing the division point to the position where the lhs
        -:  309:patterns succeeds. Previously this point repeatedly was moved one byte until
        -:  310:the lhs pattern either succeeded or definitely failed. The optimization is
        -:  311:turned off for alternating patterns and for all but the first pattern in a
        -:  312:chain of patterns connected by : operators.
        -:  313:
        -:  314:The normal (non-string) match is not optimized. It is questionable whether that
        -:  315:would be worthwhile. Not many patterns require repeated elongation of the part
        -:  316:of the subject left of the division point.
        -:  317:
        -:  318:However, CUTOFFSUGGEST is set to 0. The overhead does seem to outweigh the
        -:  319:optimization!
        -:  320:
        -:  321:
        -:  322:    21 December 2011
        -:  323:
        -:  324:The last changes had introduced a bug: the [ and ` flags were not (always) printed.
        -:  325:
        -:  326:    16 December 2011
        -:  327:
        -:  328:Repaired two bugs in doPosition. The first bug made the FENCE flag disappear
        -:  329:from the result if the program was built in debug mode in VS2008, which made
        -:  330:the program run as expected, the other bug was that the FENCE flag was
        -:  331:returned if the first bug was removed.
        -:  332:
        -:  333:    14 December 2011
        -:  334:
        -:  335:Updated unicode case conversions with data found in the most recent 
        -:  336:http://unicode.org/Public/UNIDATA/UnicodeData.txt (17-Aug-2010)
        -:  337:
        -:  338:    7 December 2011
        -:  339:
        -:  340:Introduced lambda. Syntax similar to macro.
        -:  341:
        -:  342:                (Œªx.x)y
        -:  343:translates to
        -:  344:                /('(x.$x))$y
        -:  345:
        -:  346:    1 December 2011
        -:  347:
        -:  348:Rewrote evalmacro to only copy data where necessary.
        -:  349:Bracmat now tests ok with valid.bra and with REFCOUNTSTRESSTEST set to 1
        -:  350:
        -:  351:    30 November 2011
        -:  352:
        -:  353:Found and solved bugs in merge() that only became visible with
        -:  354:REFCOUNTSTRESSTEST set to 1.
        -:  355:
        -:  356:    22 November 2011
        -:  357:
        -:  358:Rewrote evalmacro to only copy cells where necessary.
        -:  359:
        -:  360:    7 November 2011
        -:  361:
        -:  362:A result of a macro evaluation nested inside an macro was not visited by the
        -:  363:macro evaluator because the heading = operator had its READY flag set.
        -:  364:
        -:  365:    3 November 2011
        -:  366:
        -:  367:Nicified find and getmember calls, collapsing the last three arguments into
        -:  368:one objectStuff struct.
        -:  369:
        -:  370:    2 November 2011
        -:  371:
        -:  372:Made better sense of [<> (equivalent to [~) and [~<> (equivalent to [).
        -:  373:Introduced [% prefix. The expression reigned by [% in a pattern is evaluated.
        -:  374:The success or failure of the expression is the result of the match.
        -:  375:This functionality is similar to patterns that are function calls: in both
        -:  376:cases the current subject is stored in a local variable sjt. In contrast to
        -:  377:the function call, the expression's evaluated value is not itself matched 
        -:  378:against the subject.
        -:  379:Contrary to other uses of the % prefix, [% CAN match a nul object.
        -:  380:
        -:  381:    1 November 2011
        -:  382:
        -:  383:Changed signature of find, getmember, naamwoord and naamwoord_w. Before, these
        -:  384:functions returned TRUE or FALSE, while the binding was returned in a
        -:  385:pointer-to-a-pointer. The program is a bit quicker (approx. 5%).
        -:  386:
        -:  387:    30 October 2011
        -:  388:
        -:  389:The expression    a^(b*d+c*d)
        -:  390:                * (a^(b*f+c*f)+a^(e*b+e*c))
        -:  391:              + -1*(a^((b+c)*(d+e))+a^((b+c)*(d+f)))
        -:  392:did not evaluate to 0. Solved.
        -:  393:
        -:  394:    25 October 2011
        -:  395:
        -:  396:After a change in handling the pattern ?^? (20100806) the function fct didn't
        -:  397:work anymore. The function has been completely reimplemented.
        -:  398:Also changed sub so it cannot go in infinite regress.
        -:  399:
        -:  400:    12 September 2011
        -:  401:
        -:  402:Now you can do:
        -:  403:    (=)=5
        -:  404:This extension mirrors
        -:  405:    5:?(=)
        -:  406:This rather useless extension restores consistency. 
        -:  407:
        -:  408:    2 September 2011
        -:  409:
        -:  410:Corrected error in evalmacro. Inserted operator nodes where deemed to fail
        -:  411:when evaluated later on.
        -:  412:
        -:  413:   31 August 2011
        -:  414:
        -:  415:The escape operator ()$ in patterns can now be used to test for flags on the
        -:  416:subject. A special case is when the rhs is an empty atom with no flags. This
        -:  417:pattern only matches subjects with no flags. In all other cases, if one or
        -:  418:more flags are present in the rhs, the subject must have these flags as well,
        -:  419:and possibly even more.
        -:  420:
        -:  421:If the rhs is an atomic node with a non-empty string, the rhs can only match
        -:  422:atomic subjects with the same string. (But possibly with flags that are not
        -:  423:specified in the rhs.)
        -:  424:
        -:  425:   29 August 2011
        -:  426:
        -:  427:The use of $ as "escape operator" is now taken one step further. One can now
        -:  428:use $ to escape any operator in a pattern, so that the otherwise problematic
        -:  429:operators = | & : ' $ _ can be pacified and parsed.
        -:  430:
        -:  431:   23 August 2011
        -:  432:Inside macros the $ can be used as escape operator to insert a $ with empty
        -:  433:lhs in the evaluated macro. Also, the _ operator is from now on left untouched
        -:  434:in a macro unless escaped. This made it necessary to adapt a few bracmat
        -:  435:scripts, e.g. the cat$ function in this file.
        -:  436:
        -:  437:   19 August 2011
        -:  438:
        -:  439:You can now do this: '($(=$x))
        -:  440:Previously, you had to do this in two steps: flabber=$x & '($flabber)
        -:  441:You also can do this: '('($(=$b))) which evaluates to ='$b
        -:  442:
        -:  443:   26 July 2011
        -:  444:There was a problem with the ! and !! flags in connection with the flg 
        -:  445:function. In flg$(=!a):(=?X.?Z) the assignment to X wouldn't succeed, because
        -:  446:in the result (=!.a) of the evaluation of flg$(=!a), the element ! had the
        -:  447:READY flag set. Now the '!' has the READY flag unset, while the 'a' has it set.
        -:  448:
        -:  449:   29 June 2011
        -:  450:Changed a few ints to long to get rid of type casts.
        -:  451:
        -:  452:   21 June 2011
        -:  453:Converted this source code to UTF-8.
        -:  454:
        -:  455:    5 May 2011
        -:  456:The expression ((==.lst$its).)' tried to list an object that was gone.
        -:  457:Now it works. The listed object is =.lst$its
        -:  458:Notice how recursion can be implemented with a 'lambda method' that has access
        -:  459:to itself ('its'):
        -:  460:
        -:  461:( (==a b.!arg:?a_?b&((its.)$!b)_((its.)$!a)|!arg) . ) ' (x y^g (z,8.L))
        -:  462:
        -:  463:This recursively swaps lhs and rhs of all operators in the argument
        -:  464:
        -:  465:    2 April 2011
        -:  466:An expression like (x=!x)&!x now results in an endless loop, not a stack
        -:  467:overflow as before.
        -:  468:
        -:  469:    31 March 2011
        -:  470:Stackoverflow occurred if an uninitialised variable was assigned to the
        -:  471:variable itself - directly or indirectly. The problem has been solved for
        -:  472:cases like
        -:  473:
        -:  474:    !y a:?x a
        -:  475:
        -:  476:where the atom !y has the READY flag set when the assignment is attempted.
        -:  477:
        -:  478:The problem can be solved completely, but at a price, namely if
        -:  479:
        -:  480:    (=!y):(=?x)
        -:  481:    
        -:  482:is made to fail. I consider this price as too high for now.
        -:  483:
        -:  484:    16 March 2011
        -:  485:Arithmetic more complex than adding is now done with much higher radix.
        -:  486:For small numbers compuations are a little bit slower, because of conversions
        -:  487:to and from character strings. For large numbers, timings are magnitudes
        -:  488:better. Multiplication of two 200000 digits numbers is about 100 times faster.
        -:  489:Computation of the first 1000 decimals of pi is about 20 times faster.
        -:  490:
        -:  491:For 32 bit systems, a radix of 10000 is chosen. For 64 bit systems
        -:  492:a radix of 100000000 is found to be appropriate.
        -:  493:
        -:  494:    27 February 2011
        -:  495:Removed a lot of dead wood and renamed a few variables to English.
        -:  496:
        -:  497:    21 February 2011
        -:  498:Rewrite of bmalloc, bfree and initialization of memory. Memory now expands
        -:  499:dynamically: when a there are no more free memory blocks of 1,2 or 3 (4, 5, 6)
        -:  500:words available, a new pool of memory blocks for the depleted size is created,
        -:  501:doubling the number of blocks in the already allocated pools for that size.
        -:  502:Removed a bug that caused (a=7)&!(a*1) to fail.
        -:  503:
        -:  504:    11 January 2011
        -:  505:The @ is again removed from non-nil atoms. Reason: the @ flag is used on a 
        -:  506:non-nil atom to indicate that backslashes in the atomstring must be
        -:  507:interpreted litterally, i.e. @"d:\bracmat" is equivalent to "d:\\bracmat"
        -:  508:
        -:  509:This change has no consequence for the stringmatch functionality 
        -:  510:introduced 20101122.
        -:  511:
        -:  512:     6 January 2011
        -:  513:Conditionally (NP) defined opbnowis()
        -:  514:Extra parentheses in line 6932
        -:  515:
        -:  516:    25 November 2010
        -:  517:Solved bug in merge().
        -:  518:
        -:  519:    22 November 2010
        -:  520:In stringmatch, the % can be used to force characterwise matching if the
        -:  521:pattern is a number. For that reason, the % and @ are no longer removed from
        -:  522:non-nil atoms as superfluous.
        -:  523:One has to take care with minusses: the patterns %"-20/5" and %-20/5 are
        -:  524:different. In %"-20/5", the % is superfluous and the pattern matches
        -:  525:characterwise. In %-20/5, the pattern matches 20/5 and the minus is ignored!
        -:  526:
        -:  527:    19 November 2010
        -:  528:Some tests to check that the position flag is followed by an integer number
        -:  529:and that the flag % doesn't occur.
        -:  530:Made sure that mod$ and div$ fail if second argument is zero.
        -:  531:
        -:  532:    15 November 2010
        -:  533:Evaluation of sums and products is now iterative instead of recursive.
        -:  534:Also, two sums or products are neatly merged instead of appended and thereafter
        -:  535:bubble sorted. Result: much faster processing of very large sums and products
        -:  536:and no danger of stack overflow.
        -:  537:For short sums, the implementation has become a little bit slower, because
        -:  538:I reverted to older, but simpler code that makes more allocations and
        -:  539:deallocations.
        -:  540:
        -:  541:    8 November 2010
        -:  542:Made some minor changes such as int -> size_t.
        -:  543:Most radical change is introduction of function Entry2 which is like Entry,
        -:  544:only with lower level of indirection. Entry2 replaces Entry in three places.
        -:  545:
        -:  546:    3 November 2010
        -:  547:Improved percolation of filter flags < > # / @ %
        -:  548:
        -:  549:    1 November 2010
        -:  550:The built-in function now returns IMPLIEDFENCE if the subject string in
        -:  551:a stringmatch is too long or if it cannot be grown to a valid UTF-8
        -:  552:multibyte sequence. Previously, the FENCE flag was set, but this had
        -:  553:the side effect that utf$ couldn't easily be used as the lhs of a match.
        -:  554:
        -:  555:Change to flt$ : flt$(0,...) now returns 0 instead of failing. Replaced
        -:  556:get$(...,MEM,VAP): ... with @(...:...).
        -:  557:
        -:  558:    27 October 2010
        -:  559:In bmalloc, all bytes are set to 0, not just the last one.
        -:  560:Reason: if all elements of size X are in use, bmalloc may return
        -:  561:a bigger sized element, of which the last four bytes will not be
        -:  562:used at all. Instead, some earlier bytes must be set to 0.
        -:  563:
        -:  564:    22 October 2010
        -:  565:Trailing closing parentheses were accepted on equal footing with '\0' bytes.
        -:  566:
        -:  567:   18 October 2010
        -:  568:The function expandProduct turned off the READY flag on all processed output,
        -:  569:even if the result was atomic and therefore ready.
        -:  570:Consequence: (1+i)*(1+-i) was evaluated to non-ready value 2, which could
        -:  571:not successfully be used in further computations.
        -:  572:
        -:  573:   10 September 2010
        -:  574:A function call in match context not only receives a function argument in
        -:  575:"arg", but also the current subject in "sjt" (from sujet or subject)
        -:  576:Example:
        -:  577:like=.out$!sjt&sim$(!arg,!sjt):>9/10&?|den$sim$(!sjt,):~<(den$sim$(!arg,0))&`~
        -:  578:@("Dogs and Cats are my enemies":? (like$mus:?animal) ?)&out$!animal
        -:  579:@("Dogs and Cats are my enemies":? (like$cat:?animal) ?)&out$!animal
        -:  580:
        -:  581:The return value from a failing function call in match context is not compared
        -:  582:to the subject.
        -:  583:
        -:  584:By returning `~ a function can indicate that further attempts with lenghtened
        -:  585:subjects with the same start position will fail.
        -:  586:
        -:  587:   6 August 2010
        -:  588:Previously, a pattern with an exponential only matched a subject with an
        -:  589:exponential. Now, the exponent in the pattern allowing, an exponent 1 is
        -:  590:assumed.
        -:  591:
        -:  592:   2 August 2010
        -:  593:Made variable v. So now
        -:  594:    bracmat put$!v
        -:  595:says:
        -:  596:    Bracmat version 4, build 72 (2 August 2010)
        -:  597:
        -:  598:   23 July 2010
        -:  599:a*b+u*(x+y) was not evaluated correctly in the previous version.
        -:  600:Now it works again.
        -:  601:
        -:  602:   30 June 2010
        -:  603:Improved error handling if BRACMATEMBEDDED is defined.
        -:  604:
        -:  605:   22 June 2010
        -:  606:If Bracmat is running embedded (e.g. as "native code" in a Java environment)
        -:  607:it may be desirable to make bracmat safer. Here are some defines that shut off
        -:  608:selected parts of Bracmat:
        -:  609:#define NO_C_INTERFACE no memory (de)allocation, peek and poke and C-function pointer API
        -:  610:#define NO_FILE_RENAME no file renaming
        -:  611:#define NO_FILE_REMOVE no file removal
        -:  612:#define NO_SYSTEM_CALL no system() call
        -:  613:#define NO_LOW_LEVEL_FILE_HANDLING
        -:  614:                       no file handling other than get$ put$ and lst$
        -:  615:#define NO_FOPEN       no calls to fopen(). (But you can still get$ put$ and lst$ to memory!)
        -:  616:#define NO_EXIT_ON_NON_SEVERE_ERRORS
        -:  617:
        -:  618:   11 June 2010
        -:  619:Had to conditionally introduce call to unlink() instead of remove() in case of Symbian (Epoc 5).
        -:  620:
        -:  621:   26 May 2010
        -:  622:Replaced sizeof(tflags) with offsetof(sk,u.obj), which may be (and normally are,
        -:  623:on 64 bit platforms at least) different, the latter taking padding into account.
        -:  624:
        -:  625:Removed ridiculous costly calls to expressionLength, perhaps using 3/4 of all
        -:  626:CPU time when repeatedly matching large data structures!
        -:  627:
        -:  628:   19 April 2010
        -:  629:Used gprof to find functions to optimize: opaf() (has become op() and af()), splits()
        -:  630:
        -:  631:   8 April 2010
        -:  632:The 'its'-member that has been missing since version 3.50 is back again.
        -:  633:
        -:  634:   6 April 2010
        -:  635:Pattern match like a b c:% c did not work as expected
        -:  636:(should be same as a b c:%? c). Solved. Same goes for @(abc:% c).
        -:  637:
        -:  638:   30 March 2010
        -:  639:Added built-in function rmv$ that removes a file.
        -:  640:
        -:  641:   26 March 2010
        -:  642:Changed code to make Bracmat compile and run in a 64-bit environment where
        -:  643:sizeof(int) == 4 and sizeof(long) == 8.
        -:  644:It is assumed that the platform is 64-bit if LONG_MAX > 2147483647L
        -:  645:In contrast to 32 bit platforms, the functions x2d and d2x handle
        -:  646:numbers up to FFFFFFFFFFFFFFFFF hexadecimal or 18446744073709551615 decimal
        -:  647:if compiled on 64-bit platforms.
        -:  648:Another noteworthy difference is that the 64-bit version finds bigger prime
        -:  649:numbers. Try 123465864564581765^1/2 Answer: 5^1/2*24693172912916353^1/2,
        -:  650:so 24693172912916353 is prime.
        -:  651:
        -:  652:   12 March 2010
        -:  653:errorStream is not kept open if it is not stderr or strout, so that other
        -:  654:processes also can write to the errorFile, if necessary. This also ensures
        -:  655:that the message is written an saved before the program ... uhm ... crashes.
        -:  656:
        -:  657:   10 March 2010
        -:  658:If run with command line options, bracmat's return value is the numerical
        -:  659:value of the last expression evaluated. If the last evaluated expression
        -:  660:is not atomic or not a string that can be scanned as an integer number
        -:  661:using strtol, the exit code is 0.
        -:  662:Built-in exit codes:
        -:  663:-1  out of memory
        -:  664:116 invalid function syntax
        -:  665:117 string match attempted with non-atomic argument
        -:  666:
        -:  667:   9 March 2010
        -:  668:New built-in function arg$. If Bracmat is started with any arguments (argc > 1)
        -:  669:every argument is evaluated from left to right, unless arguments are consumed
        -:  670:by calls to arg$. For example,
        -:  671:    bracmat get$myprog -i c:\documents\input.txt -o d:\html\index.html
        -:  672:would evaluate
        -:  673:    get$myprog
        -:  674:    -i
        -:  675:    c:\documents\input.txt
        -:  676:    -o
        -:  677:    d:\html\index.html
        -:  678:in that order. Evaluating the last four arguments is not very meaningful,
        -:  679:however: the backslashes are interpreted as escapes, which they are not.
        -:  680:Moreover, the colon and the dot are interpreted as operators. However, the
        -:  681:bracmat program "myprog" can call the function arg$ four times and in that way
        -:  682:empty the queue of arguments. arg$ returns an atom containing an exact copy of
        -:  683:the next program argument. Using string matching the arguments can be parsed,
        -:  684:if necessary.
        -:  685:Precautions must be taken if the path or name of the bracmat program contains
        -:  686:characters that can be mistakenly interpreted. E.g. (in Windows)
        -:  687:    bracmat "get$@\"c:Program Files\myprog.bra\"" -i c:\documents\input.txt -o d:\html\index.html
        -:  688:In *N*X the apostrophes surrounding the first argument must be replaced by
        -:  689:quotes.
        -:  690:A second form is arg$N, where 0 <= N < argc. arg$0 will normally return the
        -:  691:command name "bracmat" or a path leading to "bracmat".
        -:  692:
        -:  693:   23 February 2010
        -:  694:upp$ and low$ now handle UTF-8. upp$ is a bit tricky, as some characters
        -:  695:occupy more bytes when uppercased. A simple in-place replacement is tried
        -:  696:first, and is fine in 99% of all cases. If an overrun is imminent, more space
        -:  697:is allocated.
        -:  698:
        -:  699:   22 February 2010
        -:  700:sim$(s1,s2) accepts UTF-8. 8-bit Latin-1 is also ok.
        -:  701:chr$ fails if argument is > 255
        -:  702:
        -:  703:   21 February 2010
        -:  704:~<> are now effective on patterns headed by $ or ' operator
        -:  705:b:>(str$a)
        -:  706:b:~<>(str$A)
        -:  707:
        -:  708:   20 February 2010
        -:  709:~<> uses case insensitive compare on unicode
        -:  710:
        -:  711:   19 February 2010
        -:  712:x2d$   converts hexadecimal number to decimal
        -:  713:d2x$   converts decimal number to hexadecimal
        -:  714:Both routines are restricted to decimal numbers 0 ... 4294967295 (hex 0 ... ffffffff)
        -:  715:Failure if not all characters can be scanned.
        -:  716:
        -:  717:   12 February 2010 Simplified changeCase()
        -:  718:   10 February 2010
        -:  719:abc:?NN & @(!NN:!NN ?x)
        -:  720:!x evaluated to "abc", not to ""
        -:  721:
        -:  722:   2 February 2010
        -:  723:Input scanning stopped at 0x80, as in the utf-8 sequence e2 80 93 (8211 EN DASH )
        -:  724:
        -:  725:   27 January 2010
        -:  726:~@ matches non-atomic matter, both in stringmatch and now also in match.
        -:  727:
        -:  728:   26 January 2010
        -:  729:@ and % flags are not turned off if combined with < and/or >.
        -:  730:(Previously, they were seen as "superfluous" if in combination with non-empty object.)
        -:  731:Handy if you want to skip white space:
        -:  732:
        -:  733:@("  \r\n\t  xyz\r\n  ":?a (>@" " ?:?y) ~>%" " ?)
        -:  734:
        -:  735:Changed KILOKNOPEN back to 10000
        -:  736:
        -:  737:   16 September 2009
        -:  738:Changed KILOKNOPEN to 100000 (was 10000)
        -:  739:
        -:  740:   3 July 2009
        -:  741:
        -:  742:Setting #define CODEPAGE850 0 removes all reminiscenses of DOS-codepages.
        -:  743:
        -:  744:Unicode (UTF-8) support
        -:  745:chu$number returns a sequence of 1-6 bytes. The highest allowed value of the number is 2147483647 (7FFFFFFF hex)
        -:  746:            Notice that RFC 3629 restricts UTF-8 to 4 bytes and that the highest allowed code point 10FFFF hex.
        -:  747:utf$string returns the code point of the character represented by the UTF-8 sequence of bytes.
        -:  748:            If the string is too short or too long, or if the sequence is an invalid UTF-8 string, the function fails.
        -:  749:            It is safe to use utf$ in a pattern:
        -:  750:            @(!txt:(?%c & utf$!c) ?)
        -:  751:            If txt starts with an valid UTF-8 sequence, bracmat backtracks until c matches the UTF-8 sequence.
        -:  752:            If txt starts with a sequence that is not UTF-8, bracmat stops backtracking when that fact has been
        -:  753:            established.
        -:  754:
        -:  755:   30 June 2009
        -:  756:bracmat now evaluates all parameters given to it, from left to right.
        -:  757:
        -:  758:command line:bracmat a=1 b=14 out$(!a+!b)
        -:  759:output:15
        -:  760:
        -:  761:Previously, only the first parameter was evaluated.
        -:  762:As always, if no parameter is specified, bracmat enters interactive mode.
        -:  763:
        -:  764:   11 February 2009
        -:  765:Corrected error in flt$. All powers of ten were analysed to 1,
        -:  766:for example flt$(100,2) -> 1,00*10E0
        -:  767:
        -:  768:   13 November 2008
        -:  769:stop string also works when writing.
        -:  770:fil$("file.txt",w)
        -:  771:fil$(,STR," \n\r\t")
        -:  772:fil$(,,,"Workers go to strike/for higher wages
        -:  773:and for more kindergartens.")
        -:  774:fil$("file.txt",r)
        -:  775:fil$(outfile,w)
        -:  776:fil$("infile.txt",STR)
        -:  777:fil$(outfile,STR," \n\r\t")
        -:  778:fil$(,,,"Workers go to strike for higher wages")
        -:  779:
        -:  780:Stop string can also be specified when reading or writing
        -:  781:fil$(,,"/","Workers go to strike/for higher wages")
        -:  782:fil$("infile.txt",,".!?,;")
        -:  783:
        -:  784:An empty stop string means: write all of the string.
        -:  785:(Or read to end of file, if file mode is reading).
        -:  786:
        -:  787:   10 September 2008
        -:  788:x^(y*(a+b))+-1*x^(a*y+b*y) -> 0 Before, the exponents were regarded as
        -:  789:different. If, during comparison, a subtree of lhs has pattern ?*(?+?) and
        -:  790:the corresponding subtree of the rhs ?+?, the lhs subtree is expanded to
        -:  791:a sum (defactorised) and the comparison is done on the transformed lhs and
        -:  792:the rhs. Notice that the most expensive exponent survives:
        -:  793:x^(y*(a+b))+x^(a*y+b*y): 2*x^(y*(a+b))
        -:  794:
        -:  795:0^-1 succeeded and gave 0, now it fails. (0/7^-1 already failed)
        -:  796:
        -:  797:Strings starting with a zero and followed by another figure are not numbers
        -:  798:00/7, 098
        -:  799:
        -:  800:Input ()k went in endless loop, because the k was interpreted as an operator.
        -:  801:Now it says "malformed input".
        -:  802:
        -:  803:   11 February 2008
        -:  804:whl' now returns function_ok instead of function_fail. Although the
        -:  805:loop exits when the rhs fails and there therefore is nothing meaningful to
        -:  806:"return", it led to ugly code when a whl' loop always had to be negated
        -:  807:
        -:  808:    ... & ~(whl'(...)) & ...
        -:  809:
        -:  810:or put into the lhs of an OR
        -:  811:
        -:  812:    & ( whl'(...) |  ) &
        -:  813:
        -:  814:til' is commented out. It has no future.
        -:  815:
        -:  816:   28 January 2008
        -:  817:evalmacro did not unset the ready-bit on an inserted expression consisting of
        -:  818:a variable with exclamation mark. It does now.
        -:  819:
        -:  820:   27 January 2008
        -:  821:Introduction of flag [ for acquiring or requiring the current position during
        -:  822:a (string)match. Examples:
        -:  823:    a b c:? ([-1:[?endpos)
        -:  824:will assign the length of the subject, 3, to variable endpos.
        -:  825:    a b c d e:? [!endpos ?extramaterial
        -:  826:will assign d e to extramaterial.
        -:  827:Works in match and stringmatch alike, with some exceptions:
        -:  828:@(:[0) succeeds, but (:[0) fails. Reason: in the first case, the subject
        -:  829:is the nil element, but in the second case, the lhs is just an atom,
        -:  830:although a funny one. In a certain context, this atom plays the role
        -:  831:of nil element, but not in other contexts.
        -:  832:
        -:  833:Found out that stringmatch had a measurable side effect on the subject
        -:  834:
        -:  835:subject=abcdef
        -:  836:@(!subject:? (d & !subject:abcd) ?
        -:  837:
        -:  838:This would succeed, because the string had been temporarily cut off after
        -:  839:the 'd'.
        -:  840:Now match and string match are much more alike and the problem is solved.
        -:  841:
        -:  842:Introduction of two built-in functions: whl and til. whl repeatedly evaluates
        -:  843:its argument until it fails. whl always returns failure. til repeatedly
        -:  844:evaluates its argument until it succeeds and returns the result of the last
        -:  845:evaluation.
        -:  846:There are no plans to make if...else and switch equivalents in Bracmat.
        -:  847:It may be that whl and/or til are retracted later. They seem a bit superfluous.
        -:  848:
        -:  849:   13 January 2008
        -:  850:`~a:?b will now assign `~a to b
        -:  851:@(`~a:?b) will assign a to b. !a will succeed
        -:  852:As before, this will assign something failing to a variable:
        -:  853:dummy ~a:dummy ?m
        -:  854:!m fails
        -:  855:~!m gives ~a
        -:  856:
        -:  857:   3 January 2008
        -:  858:Better implementation of the evaluation of !(=a).
        -:  859:It is now possible to construct and run a loop as a datastructure with
        -:  860:a closed loop of pointers. Performance-wise nothing is gained, however.
        -:  861:  (loop= !i+1:<10000000:?i&!(=))
        -:  862:& '$loop:(=?(loop.)) {Make closed datastructure}
        -:  863:& ~!loop {loop 10.000.000 times}
        -:  864:& :?(loop.) {Open the datastructure.(Otherwise you'll have a memory leak when
        -:  865:             'loop' goes out of scope.)}
        -:  866:
        -:  867:Several functions have been factorised. evalueer() has been restructured.
        -:  868:
        -:  869:   2 January 2008
        -:  870:I've decided that a:(~@(a:a)) means about the same as a:(~@:(a:a)), i.e. it
        -:  871:fails because a is not not an atom. For the same reason a:(~@(a:b)) fails.
        -:  872:~@(a:a) in an evaluation context such as x&~@(a:a) succeeds. It merely means
        -:  873:a:a
        -:  874:
        -:  875:Use #define STRINGMATCH_CAN_BE_NEGATED 1 to allow ~@(<subject>:<pattern>)
        -:  876:as a stringmatch that has its result negated after evaluation.
        -:  877:
        -:  878:Use #define STRINGMATCH_CAN_BE_NEGATED 0 to interpret ~@(<subject>:<pattern>)
        -:  879:as the opposite of stringmatch, i.e. a normal match, the same as
        -:  880:(<subject>:<pattern>) with the additional condition that <subject> is not an
        -:  881:atom. Notice, however, that ~@#(abc:? b ?) succeeds, as the ~ negates #, not @
        -:  882:(priority /#<>@)
        -:  883:
        -:  884:Succeeding tests:
        -:  885:a b:(~@(? b:a %))
        -:  886:~@(a b:a ?)
        -:  887:~@(a:a)
        -:  888:12/34:@(?x:#?a (~#%@:?y) #?b)&!y:"/"
        -:  889:
        -:  890:Failing tests:
        -:  891:a:(~@(a:a))
        -:  892:~@(a:b)
        -:  893:12/34:@(#?a (~#%@:?y) #?b:?x)&!y:"/"
        -:  894:    (This fails because the pattern
        -:  895:        #?a (~#%@:?y) #?b
        -:  896:    is in the match context 12/34:<rhs>, not in a stringmatch context.
        -:  897:    Remember, the first @ says that subject is an atom, which it is in the
        -:  898:    match context, but not in a stringmatch context.)
        -:  899:@(12/34:@(#?a (~#%@:?y) #?b:?x)&!y:"/")
        -:  900:    (This fails because 12/34 is not an atom in a stringmatch context.)
        -:  901:
        -:  902:   29 December 2008
        -:  903:Compilation with Norcroft RISC OS ARM C vsn 3.00 [Jul 12 1989]
        -:  904:This resulted in some formal corrections (signed vs unsigned int,
        -:  905:int vs long, too many arguments for format in Printf,
        -:  906:#if _BRACMATEMBEDDED changed to #if defined _BRACMATEMBEDDED)
        -:  907:
        -:  908:The changes of 20071217 were undone, because the solution did not work for
        -:  909:    ~(&~@(a:a))
        -:  910:New solution:
        -:  911:In lex(), undo setting of
        -:  912:    success == FALSE
        -:  913:on : node if ~@ flags are attached to this operator.
        -:  914:This is a special case. In ~@(a:b) the ~ operator must
        -:  915:not negate the @ but the result of the string match.
        -:  916:
        -:  917:I am not convinced that this is the right decision. Perhaps we simply
        -:  918:should not allow other flags than @ on : if we want it to be interpreted
        -:  919:as a string match operation.
        -:  920:
        -:  921:   17 December 2007
        -:  922:~@(a:a) didn't fail and ~@(a:b) didn't succeed. Now they do.
        -:  923:
        -:  924:   9 October 2007
        -:  925:Removed test print from getObjectDef.
        -:  926:
        -:  927:   18 September 2007
        -:  928:    a b "" ""
        -:  929:evaluates to
        -:  930:    a b ()
        -:  931:instead of
        -:  932:    a b
        -:  933:Changed function handleLUCHT to correct this.
        -:  934:
        -:  935:   7 July 2007
        -:  936:Differentiation: Originally, to indicate that a variable x depends on another
        -:  937:variable p, one wrote x=p, or x=s and s=p. If one wrote (x=), then y\Dx
        -:  938:resulted in stack overflow. The appropriate way to indicate dependeny is
        -:  939:dep=(x.p) (....)
        -:  940:
        -:  941:The range function has been abolished. Originally the idea was that Bracmat
        -:  942:not only should handle numbers and symbols, but also ranges. Thus, 2^>3 would
        -:  943:give >16 and -5*>2 would give <-10. This had to be given up as ranges become
        -:  944:more and more complicated to express. (>4*~>3 = ?)
        -:  945:
        -:  946:Code implementing a string table (COMPILE==1) has been removed
        -:  947:COMPILE works not faster, but slower (about 10%) and uses more nodes.
        -:  948:
        -:  949:The unfinished attempt at implementing objects that can be saved and re-read
        -:  950:(serialization) has been given up (OBJECTS==1) Flag: [
        -:  951:
        -:  952:VAX-specific code removed.
        -:  953:
        -:  954:   5 July 2007:
        -:  955:There were problems with stringmatches:
        -:  956:@(aaab:((|a) aa) b)
        -:  957:This failed because the match
        -:  958:    aa:aa
        -:  959:prematurely ended the match with failure.
        -:  960:The cause was that this match ONCED the whole match
        -:  961:    aa:(|a) aa
        -:  962:
        -:  963:This partly undoes a change made in 200704
        -:  964:
        -:  965:new$hash:?h
        -:  966:(h..ISO)$
        -:  967:(h..insert)$(a.b)
        -:  968:
        -:  969:This made a division by zero, because (h..ISO) had rehashed the table
        -:  970:to a table with zero size. (hashes are born with non-zero size)
        -:  971:The computation of the loadfactor went wrong.
        -:  972:
        -:  973:    4 April 2007:
        -:  974:Tail recursion optimisation in complexiteit.
        -:  975:
        -:  976:Solved bug in handling of strings with characters > 0x80 in expressions like
        -:  977:    a √•
        -:  978:
        -:  979:Solved bug in handling of e^(i*pi)
        -:  980:
        -:  981:Solved bug in handling of i:-i
        -:  982:
        -:  983:Solved bug in handling of -1*i^1/3
        -:  984:
        -:  985:lst$ now lists ALL names. Previously, names starting with character above 0x7f
        -:  986:were hidden. Som hidden functions that were called from f0, f4 or f5 are
        -:  987:now declared inside these functions and therefore hidden.
        -:  988:
        -:  989:get$ and fil$ first try to open a file interpreting the file name as a path
        -:  990:relative to the current working directory. If that fails, and if the program
        -:  991:is started with a fully qualified path+file name, this path is prepended to the
        -:  992:name of the file to be opened. If opening the file also fails with the new
        -:  993:path, get$ and fil$ fail. This functionality requires that
        -:  994:1) the file mode is "reading"
        -:  995:2) the file name does not contain an absolute path
        -:  996:3) the program knows its path
        -:  997:If the program does not know its path, it may help to start the program with
        -:  998:a fully qualified path on the command line. This instruction can be put in
        -:  999:a shell script or batch file.
        -: 1000:This improvement is especially helpful for opening the "help"-file.
        -: 1001:
        -: 1002:In string matching the expression
        -: 1003:    @(abcd:?u (?:%@ %@) (?z & ~))
        -: 1004:now makes sure that the pattern (?:%@ %@) never is presented with more than two
        -: 1005:characters. Before, the @ flag did not really work with string matching and the
        -: 1006:: operator extinguished the cut condition that arises in its rhs.
        -: 1007:This works now within a reasonable time:
        -: 1008:(do=
        -: 1009:  get$(help,STR):?S
        -: 1010:& @( !S
        -: 1011:   :   ?
        -: 1012:       ( ?:(%@:~" ":~",") %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@ %@:?x
        -: 1013:       & '(? ()$x ?):(=?x)
        -: 1014:       )
        -: 1015:       !x
        -: 1016:   )
        -: 1017:& !x);
        -: 1018:!do
        -: 1019:
        -: 1020:
        -: 1021:In a string, characters that also have a meaning as an operator can be escaped:
        -: 1022:nsc\'ere
        -: 1023:is the same as
        -: 1024:"nsc'ere"
        -: 1025:
        -: 1026:The names of cat$'s local variables are now taken from the list of names of
        -: 1027:predefined functions. Consequently, cat$ does not list its own local variables.
        -: 1028:(Previously, listing of these names was circumvented by the rule that names
        -: 1029:starting with high-bit-set characters are kept hidden.)
        -: 1030:
        -: 1031:Defunct ego$ and goe$ are abolished.
        -: 1032:
        -: 1033:   22 February 2007:
        -: 1034:    Major change in match() that speeds up matching. Found also an error in the
        -: 1035:    handling of an alternating pattern with an alternating pattern in the lhs
        -: 1036:    and a FENCE flag in the leftmost node.
        -: 1037:    Similar changes in stringmatch() must yet be made.
        -: 1038:
        -: 1039:   20 February 2007:
        -: 1040:    Changed int and unsigned long to size_t in two places to stop warnings.
        -: 1041:
        -: 1042:
        -: 1043:   18 January 2007:
        -: 1044:    Added _CONSOLE to test for Windows API
        -: 1045:    @(:? ?) failed. Cause: Unmotivied test for subjectstring not being empty.
        -: 1046:
        -: 1047:    20060704 caseinsensitivehash fixed
        -: 1048:
        -: 1049:   23 June 2006
        -: 1050:caseinsensitivehash uses lowerEquivalent without converting array index to
        -: 1051:unsigned int!
        -: 1052:
        -: 1053:   12 October 2005:
        -: 1054:    Corrected error in flt$. During rounding, the variable m could become
        -: 1055:    > 10. Consequently, the exponent must be increased by one and m must
        -: 1056:    be divided by 10 in those cases.
        -: 1057:
        -: 1058:   5 September 2005:
        -: 1059:    Changed C++-style comments to old fashioned C-style comments.
        -: 1060:    Removed enum {NoIndication,AnInteger,NotAFraction,NotANumber,AFraction,ANumber};
        -: 1061:
        -: 1062:   5 april 2005:
        -: 1063:    flg$<flags><atom> now returns ((=<flags>).<atom>)
        -: 1064:    This protects the flags from evaluation.
        -: 1065:
        -: 1066:   17 november 2004:
        -: 1067:    clk$ returns 0 if clock() returns -1
        -: 1068:    bez$ returns (<nodes>.<max nodes>.<max ref>)
        -: 1069:    epoc version: delete key emits ascii 8 (back space). Now, ascii(8) moves
        -: 1070:    the input pointer one position back, deleting the previous entered
        -: 1071:    character. (see mygetc)
        -: 1072:
        -: 1073:   25 sep 2004: strrev rewritten for Epoc
        -: 1074:
        -: 1075:   6 June 2004:
        -: 1076:1) Started to make late binding in string matching
        -: 1077:2) Corrected errors in assignment to and listing of objects with late bound values
        -: 1078:
        -: 1079:   20040830
        -: 1080:This fails:
        -: 1081:(obj=x=)&dbg'@("abc":?(obj.x) "c") & out$!(obj.x);
        -: 1082:
        -: 1083:This works:
        -: 1084:dbg'@("abc":?x "c") & out$!x;
        -: 1085:*/
        -: 1086:/*
        -: 1087:NOTES
        -: 1088:=====
        -: 1089:
        -: 1090:2002.12.15
        -: 1091:----------
        -: 1092:This is the open source version of Bracmat.
        -: 1093:
        -: 1094:Originally, Bracmat was written in Basic for the Amstrad computer. Its sole
        -: 1095:purpose was to derive a simple expression for the curvature of a model
        -: 1096:space-time, starting from the components of the metric. The only operations
        -: 1097:the program was capable to perform were multiplications, exponentiations,
        -: 1098:logarithms, and partial derivatives. The expressions were a mix of numbers
        -: 1099:and symbolic variables, like "a+2*b". Thus, "a+a" was simplified to "2*a".
        -: 1100:
        -: 1101:The second version of Bracmat, about 1988, was developed in Ansi C and run
        -: 1102:on an Acorn Archimedes. Great care was taken to make the program portable to
        -: 1103:other hardware, such as Atari, VAX and even the PC. The PC architecture, with
        -: 1104:its limited memory, its 16 bit architecture and its limitation on the size of
        -: 1105:the program stack, posed some severe limitations on the program. Therefore
        -: 1106:great care was taken to limit the use of the stack to a minimum. This has
        -: 1107:lead to some rather large functions (to save stack-consuming function calls).
        -: 1108:
        -: 1109:The C version became a true programnming language, with program variables,
        -: 1110:logical operators and function calls. The syntax, however, was not changed.
        -: 1111:For example, instead of using "if...then...else...", I decided to write
        -: 1112:something like "...&...|...", using lazy evaluation of the infix binary
        -: 1113:logical operators "&" (AND) and "|" (OR) for program control.
        -: 1114:
        -: 1115:The logical operators, of course, should test for operands being "true" or
        -: 1116:"false". The main provider of interesting truth values became the pattern
        -: 1117:matching operator ":", which tests whether the pattern (the rhs-operand)
        -: 1118:matches the subject (the lhs-operand). The single outstanding feature of
        -: 1119:Bracmat is, in fact, its pattern recognition, which works on tree structures,
        -: 1120:not on strings of characters.
        -: 1121:
        -: 1122:Bracmat was also extended with a few operators that makes this programming
        -: 1123:language interesting in the field of computational linguistics, namely the
        -: 1124:blank " ", the comma "," and the full stop ".". (The interpunction symbols
        -: 1125:"?", "!" and ";" were already 'taken' to serve other purposes.)
        -: 1126:
        -: 1127:You may find the source code difficult to read at some places. You are best
        -: 1128:off if you understand English and Dutch (and perhaps Danish). Only if the
        -: 1129:program arises enough interest I will invest the effort to streamline the
        -: 1130:source text and make it more understandable for the general programmer.
        -: 1131:*/
        -: 1132:
        -: 1133:/*
        -: 1134:TODO list:
        -: 1135:20010103: Make > and < work on non-atomic stuff
        -: 1136:20010904: Issue warning if 'arg' is declared as a local variable
        -: 1137:*/
        -: 1138:/* 20001213, There is a need to improve documentation of fil$ */
        -: 1139:/* 20001213, rename a file ren$(oldname.newname) */
        -: 1140:/* >Bracmat 16-11-91 */
        -: 1141:/* 20010309 evalueer on LUCHT and KOMMA strings is now iterative on the
        -: 1142:   right descending (deep) branch, not recursive.
        -: 1143:   (It is now possible to read long lists, e.g. dictionairies, without causing
        -: 1144:   stack overflow when evaluating the list.)
        -: 1145:   20010821 a () () was evaluated to a (). Removed last ().
        -: 1146:   20010903 (a.) () was evaluated to a
        -: 1147:*/
        -: 1148:#define DEBUGBRACMAT 0 /* implement dbg'(expression), see DBGSRC macro */
        -: 1149:#define REFCOUNTSTRESSTEST 0
        -: 1150:#define DOSUMCHECK 0
        -: 1151:#define CHECKALLOCBOUNDS 0 /* only if NDEBUG is false */
        -: 1152:#define PVNAME 0 /* allocate strings of variable names separately from variable structure. */
        -: 1153:#define STRINGMATCH_CAN_BE_NEGATED 0 /* ~@(a:a) */
        -: 1154:#define CODEPAGE850 0
        -: 1155:#define MAXSTACK 0 /* 1: show max stack depth (eval function only)*/
        -: 1156:#define CUTOFFSUGGEST 1
        -: 1157:#define READMARKUPFAMILY 1 /* read SGML, HTML and XML files. (include xml.c in your project!) */
        -: 1158:
        -: 1159:/* 
        -: 1160:About reference counting.
        -: 1161:Most nodes can be shared by no more than 1024 referers. Copies must be made as needed.
        -: 1162:Objects (nodes with = ('WORDT' in Dutch) are objects and cane be shared by almost 2^40 referers.
        -: 1163:
        -: 1164:small refcounter       large refcounter              comment
        -: 1165:(10 bits, all nodes)   (30 bits, only objects)
        -: 1166:0                      0                             not shared, no test of large refcounter needed.
        -: 1167:1                      0                             shared with one, so totalling two
        -: 1168:2                      0                             shared with two
        -: 1169:..                     ..
        -: 1170:1022                   0
        -: 1171:1023                   0                             totalling 1024, *** max for normal nodes ***
        -: 1172:1                      1                             totalling 1025
        -: 1173:2                      1
        -: 1174:..                     ..
        -: 1175:m                      1
        -: 1176:..                     ..                            totalling 1024+(1-1)*1023+m
        -: 1177:1023                   1                             totalling 1024+1*1023
        -: 1178:..                     ..
        -: 1179:m                      n                             totalling 1024+(n-1)*1023+m or 1+n*1023+m
        -: 1180:1023                   2^30-1                        totalling 1024+(2^30-2)*1023+1023=1 098 437 885 953
        -: 1181:                                                         (or   1+2^30*1023)
        -: 1182:*/
        -: 1183:
        -: 1184:#if DEBUGBRACMAT
        -: 1185:#define DBGSRC(code)    if(debug){code}
        -: 1186:#else
        -: 1187:#define DBGSRC(code)
        -: 1188:#endif
        -: 1189:
        -: 1190:#if MAXSTACK
        -: 1191:static int maxstack = 0;
        -: 1192:static int stack = 0;
        -: 1193:#define ASTACK {++stack;if(stack > maxstack) maxstack = stack;}{
        -: 1194:#define ZSTACK }{--stack;}
        -: 1195:#else
        -: 1196:#define ASTACK
        -: 1197:#define ZSTACK
        -: 1198:#endif
        -: 1199:
        -: 1200:#include <assert.h>
        -: 1201:
        -: 1202:/*19980208
        -: 1203:Bug in match!!
        -: 1204:Removed 19971207
        -: 1205:*/
        -: 1206:/*
        -: 1207:sub must also accept . as separator between args
        -: 1208:*/
        -: 1209:/* wis: 18 Maart 1997, tail recursion optimization; delete deep structures*/
        -: 1210:/* bezig met modernisering getallen */
        -: 1211:/* 16 mei 1993: constante "-i" ingevoerd om evenwicht te brengen in gedrag
        -: 1212:   van complexe getallen en hun complex geconjugeerde. */
        -: 1213:/* Nog nodig: -n*i^iets -> n*-i^iets
        -: 1214:              n*i*a+m*-i*a  -> (n-m)*i*a
        -: 1215:   Goed doortesten !
        -: 1216:*/
        -: 1217:
        -: 1218:
        -: 1219:/* 24 april 1992: UNOPS uitgebreid met MINUS */
        -: 1220:/* 26 april 1992: fct aangepast voor (a+b)^-n */
        -: 1221:/* 24 maart 1993: function syntax veranderd:
        -: 1222:   met FUNC defined oude stijl: foo = fun$(loc'(x,y,z),!arg);
        -: 1223:   zonder FUNC define:          foo = x,y,z.!arg */
        -: 1224:
        -: 1225:/* 30 juli 1993: structure:
        -: 1226:   het is nu mogelijk om aan een expressie als naam=Bart een andere waarde
        -: 1227:   toe te kennen. In feite wordt de rechter operand van de = operator
        -: 1228:   stomweg vervangen door de nieuwe waarde, waardoor circulaire data-
        -: 1229:   structuren mogelijk worden! BJO 4 Jan 1996
        -: 1230:
        -: 1231:   voorbeeld:
        -: 1232:
        -: 1233:   {?} x==(name=Bart).(age=40)
        -: 1234:   {?} !x
        -: 1235:   {!} =(name=Bart).(age=40)
        -: 1236:   {?} !!x
        -: 1237:   {!} Bart.40
        -: 1238:   {?} !x:(=?naam.?leeftijd)
        -: 1239:   {?} Bart Jongejan:?!naam
        -: 1240:   {?} !!x
        -: 1241:   {!} Bart Jongejan.40
        -: 1242:   {?} x..age=veertig                          BJO 4 Jan 1996
        -: 1243:   {?} !!x
        -: 1244:   {!} Bart Jongejan.veertig
        -: 1245:
        -: 1246:   x..name.first=Bart vervangt Jan door Bart in
        -: 1247:
        -: 1248:   x==(name=(first=Jan).(family=Abbens)).(age=33)
        -: 1249:
        -: 1250:   Merk op dat de = operator z'n speciale betekenis in patterns kwijt is
        -: 1251:   ~=(% %) moet dus voortaan geschreven worden als ((% %) & `~|?)
        -: 1252:*/
        -: 1253:
        -: 1254:#if 0 && defined __GNUC__ && !defined sparc && !defined __hpux && !defined __hpux__
        -: 1255:/* TODO test must be changed to a positive list. Bart 20030704 */
        -: 1256:#define ARM /*1*/ /* assume it's an Acorn */
        -: 1257:#define os_swix os_swi /* different naming */
        -: 1258:typedef struct {
        -: 1259: int r[10];
        -: 1260:}os_regset;
        -: 1261:#else
        -: 1262:/*#define ARM 0*/ /* assume it isn't an Acorn */
        -: 1263:#endif
        -: 1264:
        -: 1265:
        -: 1266:#if (defined __TURBOC__ && !defined __WIN32__) || (defined ARM && !defined __SYMBIAN32__)
        -: 1267:#define O_S 1 /* 1 = with operating system interface swi$ (RISC_OS or TURBO-C), 0 = without  */
        -: 1268:#else
        -: 1269:#define O_S 0
        -: 1270:#endif
        -: 1271:
        -: 1272:/* aanwijzingen voor het compileren
        -: 1273:   (met een ANSI-C compiler of iets wat daar dichtbij in de buurt komt)
        -: 1274:
        -: 1275:Archimedes ANSI-C release 3:
        -: 1276:*up
        -: 1277:*del. :0.$.c.clog
        -: 1278:*spool :0.$.c.clog
        -: 1279:*cc bracmat
        -: 1280:*spool
        -: 1281:
        -: 1282:Met RISC_OS functies:
        -: 1283:
        -: 1284:cc bracmat
        -: 1285:
        -: 1286:file cc (in directory c):
        -: 1287:
        -: 1288:| >cc
        -: 1289:up
        -: 1290:delete $.c.clog
        -: 1291:spool $.c.clog
        -: 1292:cc -c %0 -IRAM:$.RISC_OSLib
        -: 1293:if Sys$ReturnCode = 0 then run c.li %0 else spool
        -: 1294:
        -: 1295:file li (in directory c):
        -: 1296:
        -: 1297:| >li
        -: 1298:link -o %0 o.%0 RAM:$.RISC_OSLib.o.RISC_OSLib RAM:$.Clib.o.Stubs
        -: 1299:||G
        -: 1300:spool
        -: 1301:if Sys$ReturnCode = 0 then squeeze %0 else echo |G
        -: 1302:
        -: 1303:Microsoft QUICKC (MS-DOS) (compact en large model kunnen allebei)
        -: 1304:qcl /Ox /AC /F D000 bracmat.c
        -: 1305:Microsoft optimizing compiler V5.1
        -: 1306:cl /Ox /AC /F D000 bracmat.c
        -: 1307:
        -: 1308:Borland TURBOC (MS-DOS) V2.0
        -: 1309:tcc -w -f- -r- -mc -K- bracmat
        -: 1310:
        -: 1311:Atari : definieer -DATARI i.v.m. BIGENDIAN en extern int _stksize = -1;
        -: 1312:               en -DW32   doch alleen als (int)==(long)
        -: 1313:*/
        -: 1314:
        -: 1315:/* optionele #defines voor debuggen en aanpassing aan machine */
        -: 1316:
        -: 1317:#define TELMAX  1 /* maximaal aantal gealloceerde nodes laten zien */
        -: 1318:#define TELLING 0 /* idem,uitgebreid met huidige allocatie, per groep van
        -: 1319:                       4,8,12 en >12 bytes */
        -: 1320:#if TELLING
        -: 1321:#if TELMAX == 0
        -: 1322:#undef TELMAX
        -: 1323:#define TELMAX 1
        -: 1324:#endif
        -: 1325:#ifndef TELMAX
        -: 1326:#define TELMAX 1
        -: 1327:#endif
        -: 1328:#endif
        -: 1329:
        -: 1330:/*#define reslt hreslt  om in resultaat ALLE haakjes te laten zien*/
        -: 1331:#define INTSCMP 0   /* linke manier om strings te vergelijken */
        -: 1332:#define ICPY 0      /* woord voor woord copieren, i.p.v. byte voor byte */
        -: 1333:
        -: 1334:/* hieronder zijn geen optionele #defines meer */
        -: 1335:#if defined __BYTE_ORDER && defined __LITTLE_ENDIAN /* gcc on linux defines these */
        -: 1336:#if __BYTE_ORDER == __LITTLE_ENDIAN
        -: 1337:#define BIGENDIAN 0
        -: 1338:#else
        -: 1339:#define BIGENDIAN 1
        -: 1340:#endif
        -: 1341:#endif
        -: 1342:
        -: 1343:#ifndef BIGENDIAN
        -: 1344:
        -: 1345:#if defined mc68000 || defined MC68000 || defined mc68010 || defined mc68020 || defined mc68030 || defined ATARI || defined sparc || defined __hpux || defined __hpux__
        -: 1346:#define BIGENDIAN 1
        -: 1347:#endif
        -: 1348:
        -: 1349:#endif
        -: 1350:
        -: 1351:#ifndef BIGENDIAN
        -: 1352:#define BIGENDIAN     0
        -: 1353:#endif
        -: 1354:
        -: 1355:#if defined BRACMATEMBEDDED
        -: 1356:#define _BRACMATEMBEDDED 1
        -: 1357:#else
        -: 1358:#define _BRACMATEMBEDDED 0
        -: 1359:#endif
        -: 1360:
        -: 1361:#if (defined _Windows || defined _MT /*multithreaded, VC6.0*/)&& (!defined _CONSOLE /*18 January 2007*/ && !defined __CONSOLE__ || defined NOTCONSOLE || _BRACMATEMBEDDED)
        -: 1362:/* _CONSOLE defined by Visual C++ and __CONSOLE__ seems always to be defined in C++Builder */
        -: 1363:#define MICROSOFT_WINDOWS_API 1
        -: 1364:#else
        -: 1365:#define MICROSOFT_WINDOWS_API 0
        -: 1366:#endif
        -: 1367:
        -: 1368:#if MICROSOFT_WINDOWS_API && defined POLL /*Bart 20030410: Often no need for polling in multithreaded apps.*/
        -: 1369:#define JMP 1 /* 1: listen to WM_QUIT message. 0: Do not listen to WM_QUIT message. */
        -: 1370:#else
        -: 1371:#define JMP 0
        -: 1372:#endif
        -: 1373:
        -: 1374:#if _BRACMATEMBEDDED
        -: 1375:#include "bracmat.h"
        -: 1376:#endif
        -: 1377:
        -: 1378:
        -: 1379:#if defined sun && !defined __GNUC__
        -: 1380:#include <unistd.h> /* SEEK_SET, SEEK_CUR */
        -: 1381:#define ALERT 7
        -: 1382:#define strtoul(a,b,c) strtol(a,b,c)
        -: 1383:#else
        -: 1384:#include <stddef.h>
        -: 1385:#endif
        -: 1386:
        -: 1387:#include <stdlib.h>
        -: 1388:
        -: 1389:#ifndef ALERT
        -: 1390:#define ALERT '\a'
        -: 1391:#endif
        -: 1392:
        -: 1393:#include <limits.h>
        -: 1394:
        -: 1395:#if defined _WIN64 || defined _WIN32
        -: 1396:typedef unsigned __int32 UINT32_T; /* pre VS2010 has no int32_t */
        -: 1397:#endif
        -: 1398:
        -: 1399:#if defined _WIN64
        -: 1400:/*Microsoft*/
        -: 1401:#define WORD32  0
        -: 1402:#define _4      1
        -: 1403:#define _5_6    1
        -: 1404:#define LONG long long
        -: 1405:#define STRTOUL _strtoui64
        -: 1406:#define STRTOL _strtoi64
        -: 1407:#define FSEEK _fseeki64
        -: 1408:#define FTELL _ftelli64
        -: 1409:#else
        -: 1410:#if !defined NO_C_INTERFACE && !defined _WIN32
        -: 1411:#if UINT_MAX == 4294967295
        -: 1412:typedef unsigned int UINT32_T;
        -: 1413:#elif ULONG_MAX == 4294967295
        -: 1414:typedef unsigned long UINT32_T;
        -: 1415:#endif
        -: 1416:#endif
        -: 1417:#if LONG_MAX <= 2147483647L
        -: 1418:#define WORD32  1
        -: 1419:#define _4      1
        -: 1420:#define _5_6    1
        -: 1421:#else
        -: 1422:#define WORD32  0
        -: 1423:#define _4      1
        -: 1424:#define _5_6    1
        -: 1425:#endif
        -: 1426:#define LONG long
        -: 1427:#define STRTOUL strtoul
        -: 1428:#define STRTOL strtol
        -: 1429:#define FSEEK fseek
        -: 1430:#define FTELL ftell
        -: 1431:#endif
        -: 1432:
        -: 1433:
        -: 1434:#if defined __TURBOC__ || defined __MSDOS__ || defined _WIN32 || defined __GNUC__
        -: 1435:#define DELAY_DUE_TO_INPUT
        -: 1436:#endif
        -: 1437:
        -: 1438:#include <time.h>
        -: 1439:#ifndef CLOCKS_PER_SEC
        -: 1440:#ifdef CLK_TCK  /* pre-ANSI-C */
        -: 1441:#define CLOCKS_PER_SEC CLK_TCK
        -: 1442:#else
        -: 1443:#if defined sun
        -: 1444:#define CLOCKS_PER_SEC 1000000 /* ??? */
        -: 1445:#endif
        -: 1446:#endif
        -: 1447:#endif
        -: 1448:
        -: 1449:#define LOGWORDLENGTH 2
        -: 1450:/* vlaggen in knoop */
        -: 1451:#define NOT              1      /* ~ */
        -: 1452:     /* zo houden ivm vermenging logische en bit operatoren && || | ^ & */
        -: 1453:#define SUCCESS         (1<< 1)
        -: 1454:#define READY           (1<< 2)
        -: 1455:#define POSITION        (1<< 3) /* [ */
        -: 1456:#define INDIRECT        (1<< 4) /* ! */
        -: 1457:#define DOUBLY_INDIRECT (1<< 5) /* !! */
        -: 1458:#define FENCE           (1<< 6) /* `   (within same byte as ATOM and NOT) */
        -: 1459:#define ATOM            (1<< 7) /* @ */
        -: 1460:#define NONIDENT        (1<< 8) /* % */
        -: 1461:#define GREATER_THAN    (1<< 9) /* > */
        -: 1462:#define SMALLER_THAN    (1<<10) /* < */
        -: 1463:#define NUMBER          (1<<11) /* # */
        -: 1464:#define BREUK           (1<<12) /* / */
        -: 1465:#define UNIFY           (1<<13) /* ? */
        -: 1466:#define IDENT           (1<<14)
        -: 1467:#define IMPLIEDFENCE    (1<<15) /* 20070222 */
        -: 1468:
        -: 1469:#define VISIBLE_FLAGS_WEAK      (INDIRECT|DOUBLY_INDIRECT|FENCE|UNIFY)
        -: 1470:#define VISIBLE_FLAGS_NON_COMP  (INDIRECT|DOUBLY_INDIRECT|ATOM|NONIDENT|NUMBER|BREUK|UNIFY) /* allows < > ~< and ~> as flags on numbers */
        -: 1471:#define VISIBLE_FLAGS_POS0      (INDIRECT|DOUBLY_INDIRECT|NONIDENT|QBREUK|UNIFY|QGETAL)
        -: 1472:#define VISIBLE_FLAGS_POS       (INDIRECT|DOUBLY_INDIRECT|NONIDENT|QBREUK|UNIFY|QGETAL|NOT|GREATER_THAN|SMALLER_THAN)
        -: 1473:#define VISIBLE_FLAGS           (INDIRECT|DOUBLY_INDIRECT|ATOM|NONIDENT|NUMBER|BREUK|UNIFY|NOT|GREATER_THAN|SMALLER_THAN|FENCE|POSITION)
        -: 1474:
        -: 1475:#define HAS_VISIBLE_FLAGS_OR_MINUS(psk) ((psk)->ops & (VISIBLE_FLAGS|MINUS))
        -: 1476:#define RATIONAAL(psk)      (((psk)->ops & (QGETAL|IS_OPERATOR|VISIBLE_FLAGS)) == QGETAL)
        -: 1477:#define RATIONAAL_COMP(psk) (((psk)->ops & (QGETAL|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP)) == QGETAL)
        -: 1478:#define RATIONAAL_COMP_NOT_NUL(psk) (((psk)->ops & (QGETAL|QNUL|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP)) == QGETAL)
        -: 1479:#define RATIONAAL_WEAK(psk) (((psk)->ops & (QGETAL|IS_OPERATOR|INDIRECT|DOUBLY_INDIRECT|FENCE|UNIFY)) == QGETAL)/* allows < > ~< and ~> as flags on numbers */
        -: 1480:#define       LESS(psk)    (((psk)->v.fl & (VISIBLE_FLAGS_POS)) == (QGETAL|SMALLER_THAN))
        -: 1481:#define LESS_EQUAL(psk)    (((psk)->v.fl & (VISIBLE_FLAGS_POS)) == (QGETAL|NOT|GREATER_THAN))
        -: 1482:#define MORE_EQUAL(psk)    (((psk)->v.fl & (VISIBLE_FLAGS_POS)) == (QGETAL|NOT|SMALLER_THAN))
        -: 1483:#define       MORE(psk)    (((psk)->v.fl & (VISIBLE_FLAGS_POS)) == (QGETAL|GREATER_THAN))
        -: 1484:#define    UNEQUAL(psk)    (((psk)->v.fl & (VISIBLE_FLAGS_POS)) == (QGETAL|NOT))
        -: 1485:#define LESSORMORE(psk)    (((psk)->v.fl & (VISIBLE_FLAGS_POS)) == (QGETAL|SMALLER_THAN|GREATER_THAN)) /*20111102*/
        -: 1486:#define      EQUAL(psk)    (((psk)->v.fl & (VISIBLE_FLAGS_POS)) == QGETAL)
        -: 1487:#define NOTLESSORMORE(psk) (((psk)->v.fl & (VISIBLE_FLAGS_POS)) == (QGETAL|NOT|SMALLER_THAN|GREATER_THAN))
        -: 1488:
        -: 1489:#define INTEGER(kn)               (((kn)->ops & (QGETAL|QBREUK|IS_OPERATOR|VISIBLE_FLAGS))                      == QGETAL)
        -: 1490:#define INTEGER_COMP(kn)          (((kn)->ops & (QGETAL|QBREUK|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP))             == QGETAL)
        -: 1491:
        -: 1492:#define INTEGER_NIET_NEG(kn)      (((kn)->ops & (QGETAL|MINUS|QBREUK|IS_OPERATOR|VISIBLE_FLAGS))                == QGETAL)
        -: 1493:#define INTEGER_NIET_NEG_COMP(kn) (((kn)->ops & (QGETAL|MINUS|QBREUK|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP))       == QGETAL)
        -: 1494:
        -: 1495:#define INTEGER_POS(kn)           (((kn)->ops & (QGETAL|MINUS|QNUL|QBREUK|IS_OPERATOR|VISIBLE_FLAGS))           == QGETAL)
        -: 1496:#define INTEGER_POS_COMP(kn)      (((kn)->ops & (QGETAL|MINUS|QNUL|QBREUK|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP))  == QGETAL)
        -: 1497:
        -: 1498:#define INTEGER_NIET_NUL_COMP(kn) (((kn)->ops & (QGETAL|QNUL|QBREUK|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP))        == QGETAL)
        -: 1499:#define HAS_MINUS_SIGN(kn)         (((kn)->ops & (MINUS|IS_OPERATOR)) == MINUS)
        -: 1500:
        -: 1501:#define RAT_NUL(kn) (((kn)->v.fl & (QNUL|IS_OPERATOR|VISIBLE_FLAGS)) == QNUL)
        -: 1502:#define RAT_NUL_COMP(kn) (((kn)->v.fl & (QNUL|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP)) == QNUL)
        -: 1503:#define RAT_NEG(kn) (((kn)->ops & (QGETAL|MINUS|IS_OPERATOR|VISIBLE_FLAGS)) \
        -: 1504:                                == (QGETAL|MINUS))
        -: 1505:#define RAT_NEG_COMP(kn) (((kn)->ops & (QGETAL|MINUS|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP)) \
        -: 1506:                                == (QGETAL|MINUS))
        -: 1507:
        -: 1508:#define RAT_RAT(kn) (((kn)->ops & (QGETAL|QBREUK|IS_OPERATOR|VISIBLE_FLAGS))\
        -: 1509:                                == (QGETAL|QBREUK))
        -: 1510:
        -: 1511:#define RAT_RAT_COMP(kn) (((kn)->ops & (QGETAL|QBREUK|IS_OPERATOR|VISIBLE_FLAGS_NON_COMP))\
        -: 1512:                                == (QGETAL|QBREUK))
        -: 1513:#define IS_EEN(kn) ((kn)->u.lobj == EEN && !((kn)->ops & (MINUS | VISIBLE_FLAGS)))
        -: 1514:
        -: 1515:
        -: 1516:#include <string.h>
        -: 1517:#include <stdio.h>
        -: 1518:#include <ctype.h>
        -: 1519:#include <errno.h>
        -: 1520:
        -: 1521:#if INTSCMP
        -: 1522:#define STRCMP(a,b) intscmp((LONG*)(a),(LONG*)(b))
        -: 1523:#else
        -: 1524:#define STRCMP(a,b) strcmp((char *)(a),(char *)(b))
        -: 1525:#endif
        -: 1526:#if ICPY
        -: 1527:#define MEMCPY(a,b,n) icpy((LONG*)(a),(LONG*)(b),n)
        -: 1528:#else
        -: 1529:#define MEMCPY(a,b,n) memcpy((char *)(a),(char *)(b),n)
        -: 1530:#endif
        -: 1531:
        -: 1532:#ifdef ATARI
        -: 1533:extern int _stksize = -1;
        -: 1534:#endif
        -: 1535:
        -: 1536:#if defined ARM
        -: 1537:#if O_S /*20010827, was #ifdef O_S */
        -: 1538:#if defined __GNUC__ && !defined sparc
        -: 1539:#include "sys/os.h"
        -: 1540:#else
        -: 1541:#include "os.h"
        -: 1542:#endif
        -: 1543:#endif
        -: 1544:#endif
        -: 1545:
        -: 1546:#define SHL 16
        -: 1547:
        -: 1548:#define ops v.fl
        -: 1549:#define flgs v.fl
        -: 1550:
        -: 1551:#ifdef __TURBOC__
        -: 1552:#if O_S
        -: 1553:typedef struct
        -: 1554:    {
        -: 1555:    int r[10];
        -: 1556:    } os_regset;
        -: 1557:#endif
        -: 1558:#endif
        -: 1559:
        -: 1560:#define RIGHT u.p.rechts
        -: 1561:#define LEFT  u.p.links
        -: 1562:#define TRUE 1
        -: 1563:#define FALSE 0
        -: 1564:#define PRISTINE (1<<2)
        -: 1565:#define ONCE (1<<3)
        -: 1566:#define POSITION_ONCE (1<<4)
        -: 1567:#define POSITION_MAX_REACHED (1<<5)
        -: 1568:#define OBJ(p) &((p).u.obj)
        -: 1569:#define LOBJ(p) ((p).u.lobj)
        -: 1570:#define POBJ(p) &((p)->u.obj)
        -: 1571:#define SPOBJ(p) &((p)->u.sobj)
        -: 1572:/*#define PIOBJ(p) ((p)->u.iobj)*/ /* Added. Bart 20031110 */
        -: 1573:#define PLOBJ(p) ((p)->u.lobj)
        -: 1574:
        -: 1575:#define QOBJ(p) &(p)
        -: 1576:#define QPOBJ(p) p
        -: 1577:
        -: 1578:#if BIGENDIAN
        -: 1579:#define iobj lobj
        -: 1580:#define O(a,b,c) (a*0x1000000L+b*0x10000L+c*0x100)
        -: 1581:#else
        -: 1582:#if !WORD32
        -: 1583:#define iobj lobj
        -: 1584:#endif
        -: 1585:#define O(a,b,c) (a+b*0x100+c*0x10000L)
        -: 1586:#endif
        -: 1587:
        -: 1588:#if TELMAX
        -: 1589:#define BEZ O('b','e','z')
        -: 1590:#endif
        -: 1591:
        -: 1592:#if O_S
        -: 1593:#define SWI O('s','w','i')
        -: 1594:#endif
        -: 1595:
        -: 1596:#if !defined NO_C_INTERFACE
        -: 1597:#define ALC O('a','l','c')
        -: 1598:#define FRE O('f','r','e')
        -: 1599:#define PEE O('p','e','e')
        -: 1600:#define POK O('p','o','k')
        -: 1601:#define FNC O('f','n','c')
        -: 1602:#endif
        -: 1603:
        -: 1604:#if !defined NO_FILE_RENAME
        -: 1605:#define REN O('r','e','n') /* 20001213, rename a file */
        -: 1606:#endif
        -: 1607:
        -: 1608:#if !defined NO_FILE_REMOVE
        -: 1609:#define RMV O('r','m','v') /* 20100330, remove a file */
        -: 1610:#endif
        -: 1611:
        -: 1612:#if !defined NO_SYSTEM_CALL
        -: 1613:#define SYS O('s','y','s')
        -: 1614:#endif
        -: 1615:
        -: 1616:#if !defined NO_LOW_LEVEL_FILE_HANDLING
        -: 1617:#define FIL O('f','i','l')
        -: 1618:#define CHR O('C','H','R')
        -: 1619:#define DEC O('D','E','C')
        -: 1620:#define CUR O('C','U','R')
        -: 1621:#define END O('E','N','D')/*SEEK_END hoeft niet te werken voor binary file !!*/
        -: 1622:#define SET O('S','E','T')
        -: 1623:#define STRt O('S','T','R')
        -: 1624:#define TEL O('T','E','L')
        -: 1625:#endif
        -: 1626:
        -: 1627:#define ARG O('a','r','g') /*20100308 arg$ returns next program argument*/
        -: 1628:#define APP O('A','P','P')
        -: 1629:#define ASC O('a','s','c')
        -: 1630:#define CLK O('c','l','k')
        -: 1631:#define CON O('C','O','N')
        -: 1632:#if DEBUGBRACMAT
        -: 1633:#define DBG O('d','b','g')
        -: 1634:#endif
        -: 1635:#define DEN O('d','e','n')
        -: 1636:#define DIV O('d','i','v')
        -: 1637:#if CODEPAGE850
        -: 1638:#define DOS O('D','O','S')
        -: 1639:#endif
        -: 1640:#define ECH O('E','C','H')
        -: 1641:#define EEN O('1', 0 , 0 )
        -: 1642:/* err$foo redirects error messages to foo */
        -: 1643:#define ERR O('e','r','r')
        -: 1644:#define EXT O('E','X','T')
        -: 1645:#define FLG O('f','l','g')
        -: 1646:#define GLF O('g','l','f') /* 20050405 The opposite of flg */
        -: 1647:#define GET O('g','e','t')
        -: 1648:/*#define HUM O('H','U','M')*/
        -: 1649:#define HT  O('H','T', 0 )
        -: 1650:#define IM  O('i', 0 , 0 )
        -: 1651:#define KAR O('c','h','r')
        -: 1652:#define KAU O('c','h','u')
        -: 1653:#define LIN O('L','I','N')
        -: 1654:#define LOW O('l','o','w')
        -: 1655:#define REV O('r','e','v') /* 20040830 strrev */
        -: 1656:#define LST O('l','s','t')
        -: 1657:#define MEM O('M','E','M')
        -: 1658:#define ML  O('M','L',0)
        -: 1659:#define MINEEN O('-','1',0)
        -: 1660:#define MMF O('m','e','m')
        -: 1661:#define MOD O('m','o','d')
        -: 1662:#define NEW O('N','E','W')
        -: 1663:#define New O('n','e','w')
        -: 1664:#define PI  O('p','i', 0 )
        -: 1665:#define PUT O('p','u','t')
        -: 1666:#define PRV O('?', 0 , 0 )
        -: 1667:#define STR O('s','t','r')
        -: 1668:#define SIM O('s','i','m')
        -: 1669:#define STG O('S','T','R')
        -: 1670:#define TBL O('t','b','l')
        -: 1671:#define TRM O('T','R','M')
        -: 1672:#define TWEE O('2', 0 , 0 )
        -: 1673:#define TXT O('E','X','P')
        -: 1674:#define UPP O('u','p','p')
        -: 1675:#define UTF O('u','t','f')
        -: 1676:#define VAP O('V','A','P')
        -: 1677:#define WHL O('w','h','l')
        -: 1678:#define X2D O('x','2','d') /*20100219 hex -> dec*/
        -: 1679:#define D2X O('d','2','x') /*20100219 dec -> hex*/
        -: 1680:#define XX  O('e', 0 , 0 )
        -: 1681:
        -: 1682:
        -: 1683:#define SHIFT_STR 0
        -: 1684:#define SHIFT_VAP 1
        -: 1685:#define SHIFT_MEM 2
        -: 1686:#define SHIFT_ECH 3
        -: 1687:#define SHIFT_ML  4
        -: 1688:#define SHIFT_TRM 5
        -: 1689:#define SHIFT_HT  6
        -: 1690:#define OPT_STR 1
        -: 1691:#define OPT_VAP 2
        -: 1692:#define OPT_MEM 4
        -: 1693:#define OPT_ECH 8
        -: 1694:
        -: 1695:#if READMARKUPFAMILY
        -: 1696:#define OPT_ML 16
        -: 1697:#define OPT_TRM 32
        -: 1698:#define OPT_HT  64
        -: 1699:extern void XMLtext(FILE * fpi,char * bron,int trim,int html);
        -: 1700:#endif
        -: 1701:
        -: 1702:#if REFCOUNTSTRESSTEST
        -: 1703:#define REF_COUNT_BITS 1
        -: 1704:#else
        -: 1705:#define REF_COUNT_BITS 10 /* 1 - 10, 5 - 8 is very nice */
        -: 1706:#endif
        -: 1707:/*#define REF_COUNT_BITS 1 stress test!*/
        -: 1708:#define NON_REF_COUNT_BITS (16-REF_COUNT_BITS)
        -: 1709:
        -: 1710:#define FILTERS     (BREUK | NUMBER | SMALLER_THAN | GREATER_THAN | ATOM | NONIDENT)
        -: 1711:#define ATOMFILTERS (BREUK | NUMBER | SMALLER_THAN | GREATER_THAN | ATOM | FENCE | IDENT)
        -: 1712:#define SATOMFILTERS (/*ATOM | */FENCE | IDENT)
        -: 1713:
        -: 1714:#define FLGS (FILTERS | FENCE | DOUBLY_INDIRECT | INDIRECT | /*20111221*/POSITION)
        -: 1715:
        -: 1716:#define ONTKENNING(Flgs,flag)  ((Flgs & NOT ) && \
        -: 1717:                                (Flgs & FILTERS) >= (flag) && \
        -: 1718:                                (Flgs & FILTERS) < ((flag) << 1))
        -: 1719:#define ANYNEGATION(Flgs)  ((Flgs & NOT ) && (Flgs & FILTERS)) /* 20101103 */
        -: 1720:#define ASSERTIVE(Flgs,flag) ((Flgs & flag) && !ONTKENNING(Flgs,flag))
        -: 1721:#define FAAL (pat->v.fl & NOT)
        -: 1722:#define NIKS(p) (((p)->v.fl & NOT) && !((p)->v.fl & FILTERS))
        -: 1723:#define NIKSF(Flgs) ((Flgs & NOT) && !(Flgs & FILTERS))
        -: 1724:#define ERFENIS (FILTERS | FENCE | UNIFY) /* 20101103 added ATOM | NONIDENT | BREUK | NUMBER | UNIFY */
        -: 1725:#define UNOPS (UNIFY | FLGS | NOT | MINUS)
        -: 1726:#define HAS_UNOPS(a) ((a)->v.fl & UNOPS)
        -: 1727:#define HAS__UNOPS(a) (is_op(a) && (a)->v.fl & (UNIFY | FLGS | NOT))
        -: 1728:#define IS_VARIABLE(a) (/*is_op(a) && 19970831*/ (a)->v.fl & (UNIFY | INDIRECT | DOUBLY_INDIRECT))
        -: 1729:#define IS_BANG_VARIABLE(a) ((a)->v.fl & (INDIRECT | DOUBLY_INDIRECT))
        -: 1730:
        -: 1731:/*#define SUBJECTNOTNIL(sub,pat) (is_op(sub) || HAS_UNOPS(sub) || (PIOBJ(sub) != PIOBJ(nil(pat))))*/
        -: 1732:#define SUBJECTNOTNIL(sub,pat) (is_op(sub) || HAS_UNOPS(sub) || (PLOBJ(sub) != PLOBJ(nil(pat))))
        -: 1733:
        -: 1734:
        -: 1735:typedef int Boolean;
        -: 1736:typedef struct Vars vars;
        -: 1737:
        -: 1738:typedef union
        -: 1739:        {
        -: 1740:#ifndef NDEBUG
        -: 1741:        struct
        -: 1742:            {
        -: 1743:            unsigned int Not             :1; /* ~ */ /* 20110225 not -> Not, because 'not' is a C++ keyword */
        -: 1744:            unsigned int success         :1;
        -: 1745:            unsigned int ready           :1;
        -: 1746:            unsigned int position        :1; /* [ */
        -: 1747:
        -: 1748:            unsigned int indirect        :1; /* ! */
        -: 1749:            unsigned int doubly_indirect :1; /* !! */
        -: 1750:            unsigned int fence           :1; /* `   (within same byte as ATOM and NOT) */
        -: 1751:            unsigned int atom            :1; /* @ */
        -: 1752:
        -: 1753:            unsigned int nonident        :1; /* % */
        -: 1754:            unsigned int greater_than    :1; /* > */
        -: 1755:            unsigned int smaller_than    :1; /* < */
        -: 1756:            unsigned int number          :1; /* # */
        -: 1757:
        -: 1758:            unsigned int breuk           :1; /* / */
        -: 1759:            unsigned int unify           :1; /* ? */
        -: 1760:            unsigned int ident           :1;
        -: 1761:            unsigned int impliedfence    :1;
        -: 1762:
        -: 1763:            unsigned int IS_OPERATOR     :1;
        -: 1764:            unsigned int binop           :4;
        -: 1765:            /* WORDT DOT KOMMA OF EN MATCH LUCHT PLUS MAAL EXP LOG DIF FUU FUN STREEP */
        -: 1766:            unsigned int latebind        :1;
        -: 1767:            unsigned int refcount        :10;
        -: 1768:            } node;
        -: 1769:        struct
        -: 1770:            {
        -: 1771:            unsigned int Not             :1; /* ~ */
        -: 1772:            unsigned int success         :1;
        -: 1773:            unsigned int ready           :1;
        -: 1774:            unsigned int position        :1; /* [ */
        -: 1775:
        -: 1776:            unsigned int indirect        :1; /* ! */
        -: 1777:            unsigned int doubly_indirect :1; /* !! */
        -: 1778:            unsigned int fence           :1; /* `   (within same byte as ATOM and NOT) */
        -: 1779:            unsigned int atom            :1; /* @ */
        -: 1780:
        -: 1781:            unsigned int nonident        :1; /* % */
        -: 1782:            unsigned int greater_than    :1; /* > */
        -: 1783:            unsigned int smaller_than    :1; /* < */
        -: 1784:            unsigned int number          :1; /* # */
        -: 1785:
        -: 1786:            unsigned int breuk           :1; /* / */
        -: 1787:            unsigned int unify           :1; /* ? */
        -: 1788:            unsigned int ident           :1;
        -: 1789:            unsigned int impliedfence    :1;
        -: 1790:
        -: 1791:            unsigned int is_operator     :1;
        -: 1792:            unsigned int qgetal          :1;
        -: 1793:            unsigned int minus           :1;
        -: 1794:            unsigned int qnul            :1;
        -: 1795:            unsigned int qbreuk          :1;
        -: 1796:
        -: 1797:            unsigned int latebind        :1;
        -: 1798:            unsigned int refcount        :10;
        -: 1799:            } leaf;
        -: 1800:#endif
        -: 1801:        unsigned int fl;
        -: 1802:        } tFlags;
        -: 1803:
        -: 1804:
        -: 1805:typedef struct sk
        -: 1806:    {
        -: 1807:    tFlags v;
        -: 1808:
        -: 1809:    union
        -: 1810:        {
        -: 1811:        struct
        -: 1812:            {
        -: 1813:            struct sk *links,*rechts;
        -: 1814:            } p;
        -: 1815:        LONG lobj; /* This part of the structure can be used for comparisons
        -: 1816:                      with short strings that fit into one word in one machine
        -: 1817:                      operation, like "\0\0\0\0" or "1\0\0\0" */
        -: 1818:        unsigned char obj;
        -: 1819:        char sobj;
        -: 1820:        } u;
        -: 1821:    } sk;
        -: 1822:
        -: 1823:static sk nilk,nulk,eenk,argk,selfkn,Selfkn,mintweek,mineenk,tweek,minvierk,vierk
        -: 1824:,sjt/*20100910*/;
        -: 1825:
        -: 1826:#if !defined NO_FOPEN
        -: 1827:static char * targetPath = NULL; /* 20070402. Path that can be prepended to filenames. */
        -: 1828:#endif
        -: 1829:
        -: 1830:typedef  sk * psk;
        -: 1831:typedef psk * ppsk;
        -: 1832:
        -: 1833:static psk adr[7],m0 = NULL,m1 = NULL,f0 = NULL,f1 = NULL,f4 = NULL,f5 = NULL;
        -: 1834:
        -: 1835:/*
        -: 1836:
        -: 1837:0:?n&whl'(1+!n:<100000:?n&57265978465924376578234566767834625978465923745729775787627876873875436743934786450097*53645235643259824350824580457283955438957043287250857432895703498700987123454567897656:?T)&!T
        -: 1838:NEWMULT
        -: 1839:{!} 3072046909146355923036506564192345471346475055611123765430367260576556764424411699428134904701221896786418686608674094452972067252677279867454597742488128986716908647272632
        -: 1840:    S   3,41 sec  (1437.1457.2)
        -: 1841:!NEWMULT
        -: 1842:{!} 3072046909146355923036506564192345471346475055611123765430367260576556764424411699428134904701221896786418686608674094452972067252677279867454597742488128986716908647272632
        -: 1843:    S   26,60 sec  (1437.1453.2)
        -: 1844:
        -: 1845:0:?n&whl'(1+!n:<1000000:?n&57265978465627876873875436743934786450097*53645235643259824350824987123454567897656:?T)&!T
        -: 1846:NEWMULT
        -: 1847:{!} 3072046909130450126528027450054726559442406960607487886384944156986716908647272632
        -: 1848:    S   18,53 sec  (1437.1457.2)!NEWMULT
        -: 1849:{!} 3072046909130450126528027450054726559442406960607487886384944156986716908647272632
        -: 1850:    S   67,78 sec  (1437.1456.2)
        -: 1851:    
        -: 1852:0:?n&whl'(1+!n:<1000000:?n&75436743934786450097*53645235643259824350:?T)&!T
        -: 1853:NEWMULT
        -: 1854:{!} 4046821904541870443295997539156260461950
        -: 1855:    S   10,52 sec  (1437.1457.2)
        -: 1856:!NEWMULT
        -: 1857:{!} 4046821904541870443295997539156260461950
        -: 1858:    S   17,06 sec  (1437.1453.2)
        -: 1859:
        -: 1860:0:?n&whl'(1+!n:<1000000:?n&4350*2073384975284367439375369802:?T)&!T
        -: 1861:NEWMULT
        -: 1862:{!} 9019224642486998361282858638700
        -: 1863:    S   8,93 sec  (1437.1456.2)
        -: 1864:!NEWMULT
        -: 1865:{!} 9019224642486998361282858638700
        -: 1866:    S   5,59 sec  (1437.1456.2)
        -: 1867:
        -: 1868:0:?n&whl'(1+!n:<1000000:?n&43500273*384975284367439375369802:?T)&!T
        -: 1869:NEWMULT
        -: 1870:{!} 16746529968236245139535862955946
        -: 1871:    S   9,51 sec  (1437.1456.2)
        -: 1872:!NEWMULT
        -: 1873:{!} 16746529968236245139535862955946
        -: 1874:    S   8,53 sec  (1437.1456.2)
        -: 1875:
        -: 1876:0:?n&whl'(1+!n:<1000000:?n&384975284367439375369802*43500273:?T)&!T
        -: 1877:NEWMULT
        -: 1878:{!} 16746529968236245139535862955946
        -: 1879:    S   9,12 sec  (1437.1456.2)
        -: 1880:!NEWMULT
        -: 1881:{!} 16746529968236245139535862955946
        -: 1882:    S   8,10 sec  (1437.1456.2)
        -: 1883:
        -: 1884:0:?n&whl'(1+!n:<1000000:?n&38497528436743937536*980243500273:?T)&!T
        -: 1885:NEWMULT
        -: 1886:{!} 37736952026693231197301110947328
        -: 1887:    S   9,38 sec  (1437.1456.2)
        -: 1888:!NEWMULT
        -: 1889:{!} 37736952026693231197301110947328
        -: 1890:    S   8,80 sec  (1437.1454.2)
        -: 1891:    S   9,95 sec  (1437.1456.2)
        -: 1892:    S   9,58 sec  (1437.1453.2)
        -: 1893:
        -: 1894:0:?n&whl'(1+!n:<1000000:?n&3849752843674393*7536980243500273:?T)&!T
        -: 1895:NEWMULT
        -: 1896:{!} 29015511125132894970381018609289
        -: 1897:    S   9,60 sec  (1437.1454.2)
        -: 1898:!NEWMULT
        -: 1899:{!} 29015511125132894970381018609289
        -: 1900:    S   10,86 sec  (1437.1453.2)
        -: 1901:
        -: 1902:0:?n&whl'(1+!n:<10000000:?n&752843674393*753698024350:?T)&!T
        -: 1903:NEWMULT
        -: 1904:{!} 567416790034398785469550
        -: 1905:    S   71,22 sec  (1437.1457.2)
        -: 1906:!NEWMULT
        -: 1907:{!} 567416790034398785469550
        -: 1908:    S   66,63 sec  (1437.1453.2)
        -: 1909:
        -: 1910:0:?n&whl'(1+!n:<10000000:?n&7543674393*5369824350:?T)&!T
        -: 1911:NEWMULT
        -: 1912:{!} 40508206444002869550
        -: 1913:    S   62,38 sec  (1437.1456.2)
        -: 1914:!NEWMULT
        -: 1915:{!} 40508206444002869550
        -: 1916:    S   51,77 sec  (1437.1463.2)
        -: 1917:
        -: 1918:*/
        -: 1919:#if WORD32
        -: 1920:#define RADIX 10000L
        -: 1921:#define TEN_LOG_RADIX 4L
        -: 1922:#define HEADROOM 20L
        -: 1923:#else
        -: 1924:#if defined _WIN64
        -: 1925:#define RADIX 100000000LL
        -: 1926:#define HEADROOM 800LL
        -: 1927:#else
        -: 1928:#define RADIX 100000000L
        -: 1929:#define HEADROOM 800L
        -: 1930:#endif
        -: 1931:#define TEN_LOG_RADIX 8L
        -: 1932:#endif
        -: 1933:
        -: 1934:#define RADIX2 (RADIX * RADIX)
        -: 1935:
        -: 1936:typedef struct ngetal
        -: 1937:    {
        -: 1938:    int sign; /* 0: positive, QNUL: zero, MINUS: negative number */
        -: 1939:    ptrdiff_t length;
        -: 1940:    void * alloc;
        -: 1941:    char * number;
        -: 1942:    size_t allocated;
        -: 1943:    ptrdiff_t ilength;
        -: 1944:    void * ialloc;
        -: 1945:    LONG * inumber;
        -: 1946:    size_t iallocated;
        -: 1947:    } ngetal;
        -: 1948:
        -: 1949:#define NGETALIS1(x) ((x)->sign == 0 && (x)->length == 1 && ((char*)((x)->number))[0] == '1')
        -: 1950:
        -: 1951:#define Qgetal psk
        -: 1952:
        -: 1953:typedef struct varia
        -: 1954:    {
        -: 1955:    struct varia *prev; /* verdi[-1] */
        -: 1956:    psk verdi[1];       /* verdi[0], arraysize wordt door psh aangepast */
        -: 1957:    } varia;
        -: 1958:
        -: 1959:struct Vars /* sizeof(vars) = n * 4 bytes */
        -: 1960:    {
        -: 1961:#if PVNAME
        -: 1962:    unsigned char *vname;
        -: 1963:#define VARNAME(x) x->vname
        -: 1964:#endif
        -: 1965:    vars *next;
        -: 1966:    int n;
        -: 1967:    int selector;
        -: 1968:    varia *pvaria; /* kan ook entry[0] bevatten (als n == 0) */
        -: 1969:#if PVNAME
        -: 1970:/*    unsigned char *vname;*/
        -: 1971:#else
        -: 1972:    union
        -: 1973:        {
        -: 1974:        LONG Lobj;
        -: 1975:        unsigned char Obj;
        -: 1976:        } u;
        -: 1977:#define VARNAME(x) &x->u.Obj
        -: 1978:#endif
        -: 1979:    };
        -: 1980:
        -: 1981:/*typedef struct Vars vars;*/
        -: 1982:
        -: 1983:static vars * variabelen[256];
        -: 1984:
        -: 1985:static int ARGC = 0;
        -: 1986:static char ** ARGV = NULL;
        -: 1987:
        -: 1988:typedef struct kknoop
        -: 1989:    {
        -: 1990:    tFlags v;
        -: 1991:    psk links,rechts;
        -: 1992:    } kknoop;
        -: 1993:
        -: 1994:#define BUILTIN (1 << 30)
        -: 1995:
        -: 1996:typedef struct objectknoop /* createdWithNew == 0 */
        -: 1997:    {
        -: 1998:    tFlags v;
        -: 1999:    psk links,rechts;
        -: 2000:#ifdef BUILTIN
        -: 2001:    union
        -: 2002:        {
        -: 2003:        struct
        -: 2004:            {
        -: 2005:            unsigned int refcount : 30;
        -: 2006:            unsigned int built_in:1;
        -: 2007:            unsigned int createdWithNew:1;
        -: 2008:            } s;
        -: 2009:        int Int:32;
        -: 2010:        } u;
        -: 2011:#else
        -: 2012:    unsigned int refcount : 30;
        -: 2013:    unsigned int built_in:1;
        -: 2014:    unsigned int createdWithNew:1;
        -: 2015:#endif
        -: 2016:    } objectknoop;
        -: 2017:
        -: 2018:typedef struct stringrefknoop /* 20040606 */
        -: 2019:    {
        -: 2020:    tFlags v;
        -: 2021:    psk kn;
        -: 2022:    char * str;
        -: 2023:    /*unsigned long length;*/
        -: 2024:    size_t length; /*Bart 20070220 unsigned long -> size_t*/
        -: 2025:    } stringrefknoop;
        -: 2026:
        -: 2027:/*typedef typedObjectknoop;*/
        -: 2028:typedef psk function_return_type;
        -: 2029:
        -: 2030:#define functionFail(x) ((x)->v.fl ^= SUCCESS,(x))
        -: 2031:#define functionOk(x) (x)
        -: 2032:
        -: 2033:struct typedObjectknoop;
        -: 2034:typedef Boolean (*method_pnt)(struct typedObjectknoop * This,ppsk pkn);
        -: 2035:
        -: 2036:typedef struct method
        -: 2037:    {
        -: 2038:    char * name;
        -: 2039:    method_pnt func;
        -: 2040:    } method;
        -: 2041:
        -: 2042:/*
        -: 2043:typedef union method_or_data
        -: 2044:    {
        -: 2045:    method m;
        -: 2046:    objectdata d;
        -: 2047:    } method_or_data;
        -: 2048:*/
        -: 2049:struct Hash;
        -: 2050:
        -: 2051:typedef struct /**/ typedObjectknoop /**/ /* createdWithNew == 1 */
        -: 2052:    {
        -: 2053:    tFlags v;
        -: 2054:    psk links,rechts; /* links == nil, rechts == data (if vtab == NULL)
        -: 2055:            or name of object type, e.g. [set], [hash], [file], [float] (if vtab != NULL)*/
        -: 2056:#ifdef BUILTIN
        -: 2057:    union
        -: 2058:        {
        -: 2059:        struct
        -: 2060:            {
        -: 2061:            unsigned int refcount : 30;
        -: 2062:            unsigned int built_in:1;
        -: 2063:            unsigned int createdWithNew:1;
        -: 2064:            } s;
        -: 2065:        int Int:32;
        -: 2066:        } u;
        -: 2067:#else
        -: 2068:    unsigned int refcount : 30; /* Always 0L */
        -: 2069:    unsigned int built_in:1;
        -: 2070:    unsigned int createdWithNew:1;
        -: 2071:#endif
        -: 2072:    /*void * voiddata;*/
        -: 2073:    struct Hash * voiddata; /*20120702*/
        -: 2074:    #define HASH(x) (Hash*)x->voiddata
        -: 2075:    #define VOID(x) x->voiddata
        -: 2076:    #define PHASH(x) (Hash**)&(x->voiddata)
        -: 2077:    method * vtab; /* The last element n of the array must have vtab[n].name == NULL */
        -: 2078:    } typedObjectknoop;
        -: 2079:
        -: 2080:#ifdef BUILTIN
        -: 2081:#define INCREFCOUNT(a) { ((objectknoop*)a)->u.s.refcount++;(a)->ops &= ((~ALL_REFCOUNT_BITS_SET)|ONE); }
        -: 2082:#define DECREFCOUNT(a) { ((objectknoop*)a)->u.s.refcount--;(a)->ops |= ALL_REFCOUNT_BITS_SET; }
        -: 2083:#define REFCOUNTNONZERO(a) ((a)->u.s.refcount)
        -: 2084:#define ISBUILTIN(a) ((a)->u.s.built_in)
        -: 2085:#define ISCREATEDWITHNEW(a) ((a)->u.s.createdWithNew)
        -: 2086:#define SETCREATEDWITHNEW(a) (a)->u.s.createdWithNew = 1
        -: 2087:#else
        -: 2088:#define INCREFCOUNT(a) { (a)->refcount++;(a)->ops &= ((~ALL_REFCOUNT_BITS_SET)|ONE); }
        -: 2089:#define DECREFCOUNT(a) { (a)->refcount--;(a)->ops |= ALL_REFCOUNT_BITS_SET; }
        -: 2090:#define REFCOUNTNONZERO(a) ((a)->refcount)
        -: 2091:#define ISBUILTIN(a) ((a)->built_in)
        -: 2092:#define SETBUILTIN(a) (a)->built_in = 1
        -: 2093:#define UNSETBUILTIN(a) (a)->built_in = 0
        -: 2094:#define ISCREATEDWITHNEW(a) ((a)->createdWithNew)
        -: 2095:#define SETCREATEDWITHNEW(a) (a)->createdWithNew = 1
        -: 2096:#define UNSETCREATEDWITHNEW(a) (a)->createdWithNew = 0
        -: 2097:#endif
        -: 2098:
        -: 2099:/*#if !_BRACMATEMBEDDED*/
        -: 2100:#if !defined NO_FOPEN
        -: 2101:static char * errorFileName = NULL;
        -: 2102:#endif
        -: 2103:static FILE * errorStream = NULL;
        -: 2104:/*#endif*/
        -: 2105:
        -: 2106:#if !defined NO_FOPEN
        -: 2107:typedef struct filehendel
        -: 2108:    {
        -: 2109:    char *naam;
        -: 2110:    FILE *fp;
        -: 2111:    struct filehendel *next;
        -: 2112:#if !defined NO_LOW_LEVEL_FILE_HANDLING
        -: 2113:    LONG filepos; /* Normally -1. If >= 0, then the file is closed.
        -: 2114:                When reopening, filepos is used to find the position
        -: 2115:                before the file was closed. */
        -: 2116:    LONG mode;
        -: 2117:    LONG type;
        -: 2118:    LONG size;
        -: 2119:    LONG getal;
        -: 2120:    LONG tijd;
        -: 2121:    int written;
        -: 2122:    char * stop; /* contains characters to stop reading at, default NULL */
        -: 2123:#endif
        -: 2124:    } filehendel;
        -: 2125:
        -: 2126:static filehendel *fh0 = NULL;
        -: 2127:#endif
        -: 2128:
        -: 2129:typedef LONG refCountType;
        -: 2130:
        -: 2131:typedef struct indexType
        -: 2132:    {
        -: 2133:    LONG offset;
        -: 2134:    refCountType refCnt;
        -: 2135:    size_t size;
        -: 2136:    } indexType;
        -: 2137:
        -: 2138:typedef struct handleType
        -: 2139:    {
        -: 2140:    LONG number;
        -: 2141:    char *fileName;
        -: 2142:    } handleType;
        -: 2143:
        -: 2144:typedef struct objectType
        -: 2145:    {
        -: 2146:    handleType handle;
        -: 2147:    refCountType refCnt;
        -: 2148:    LONG offset;
        -: 2149:    psk obj;
        -: 2150:    LONG size;
        -: 2151:    } objectType;
        -: 2152:
        -: 2153:#define NOT_STORED -1L
        -: 2154:
        -: 2155:typedef struct freeStoreType
        -: 2156:    {
        -: 2157:    LONG nextFree;
        -: 2158:    LONG size;
        -: 2159:    } freeStoreType;
        -: 2160:
        -: 2161:/*          operator              leaf                optab
        -: 2162:Flgs 0                   NOT
        -: 2163:     1                  SUCCESS
        -: 2164:     2                  READY
        -: 2165:     3                  POSITION
        -: 2166:     4                 INDIRECT
        -: 2167:     5              DOUBLY_INDIRECT
        -: 2168:     6                  FENCE
        -: 2169:     7                  ATOM
        -: 2170:     8                 NONIDENT
        -: 2171:     9                GREATER_THAN
        -: 2172:    10                SMALLER_THAN
        -: 2173:    11                  NUMBER
        -: 2174:    12                  BREUK
        -: 2175:    13                  UNIFY
        -: 2176:    14                  IDENT
        -: 2177:    15               IMPLIEDFENCE
        -: 2178:ops 16  0             IS_OPERATOR
        -: 2179:    17  1   (operators 0-14)      QGETAL
        -: 2180:    18  2       "                 MINUS
        -: 2181:    19  3       "                 QNUL
        -: 2182:    20  4       "                 QBREUK
        -: 2183:    21  5             LATEBIND                        NOOP
        -: 2184:    22  6          (reference count)
        -: 2185:    23  7                 "
        -: 2186:    24  8                 "
        -: 2187:    25  9                 "
        -: 2188:    26 10                 "
        -: 2189:    27 11                 "
        -: 2190:    28 12                 "
        -: 2191:    29 13                 "
        -: 2192:    30 14                 "
        -: 2193:    31 15                 "
        -: 2194:
        -: 2195:Reference count starts with 0, not 1
        -: 2196:*/
        -: 2197:
        -: 2198:#define OPSH (SHL+1)
        -: 2199:#define IS_OPERATOR (1 << SHL)
        -: 2200:#define WORDT   (( 0<<OPSH) + IS_OPERATOR)
        -: 2201:#define DOT     (( 1<<OPSH) + IS_OPERATOR)
        -: 2202:#define KOMMA   (( 2<<OPSH) + IS_OPERATOR)
        -: 2203:#define OF      (( 3<<OPSH) + IS_OPERATOR)
        -: 2204:#define EN      (( 4<<OPSH) + IS_OPERATOR)
        -: 2205:#define MATCH   (( 5<<OPSH) + IS_OPERATOR)
        -: 2206:#define LUCHT   (( 6<<OPSH) + IS_OPERATOR)
        -: 2207:#define PLUS    (( 7<<OPSH) + IS_OPERATOR)
        -: 2208:#define MAAL    (( 8<<OPSH) + IS_OPERATOR)
        -: 2209:#define EXP     (( 9<<OPSH) + IS_OPERATOR)
        -: 2210:#define LOG     ((10<<OPSH) + IS_OPERATOR)
        -: 2211:#define DIF     ((11<<OPSH) + IS_OPERATOR)
        -: 2212:#define FUU     ((12<<OPSH) + IS_OPERATOR)
        -: 2213:#define FUN     ((13<<OPSH) + IS_OPERATOR)
        -: 2214:#define STREEP  ((14<<OPSH) + IS_OPERATOR) /* dummy */
        -: 2215:
        -: 2216:static const psk knil[16] =
        -: 2217:{NULL,NULL,NULL,NULL,NULL,NULL,&nilk,&nulk,
        -: 2218:&eenk,NULL,NULL,NULL,NULL,NULL,NULL,NULL};
        -: 2219:
        -: 2220:static const char opchar[16] =
        -: 2221:{'=','.',',','|','&',':',' ','+','*','^','\016','\017','\'','$','_','?'};
        -: 2222:
        -: 2223:#define OPERATOR ((0xF<<OPSH) + IS_OPERATOR)
        -: 2224:
        -: 2225:#define kop(kn) ((kn)->ops & OPERATOR)
        -: 2226:#define kopo(kn) ((kn).ops & OPERATOR)
        -: 2227:#define is_op(kn) ((kn)->ops & IS_OPERATOR)
        -: 2228:#define is_object(kn) (((kn)->ops & OPERATOR) == WORDT)
        -: 2229:#define klopcode(kn) (kop(kn) >> OPSH)
        -: 2230:
        -: 2231:#define nil(p) knil[klopcode(p)]
        -: 2232:
        -: 2233:
        -: 2234:#define NOOP                (OPERATOR+1)
        -: 2235:#define QGETAL              (1 << (SHL+1))
        -: 2236:#define MINUS               (1 << (SHL+2))
        -: 2237:#define QNUL                (1 << (SHL+3))
        -: 2238:#define QBREUK              (1 << (SHL+4))
        -: 2239:#define LATEBIND            (1 << (SHL+5))
        -: 2240:#define DEFINITELYNONUMBER  (1 << (SHL+6)) /* this is not stored in a node! */
        -: 2241:#define ONE   (unsigned int)(1 << (SHL+NON_REF_COUNT_BITS))
        -: 2242:
        -: 2243:#define ALL_REFCOUNT_BITS_SET \
        -: 2244:       ((((unsigned int)(~0)) >> (SHL+NON_REF_COUNT_BITS)) << (SHL+NON_REF_COUNT_BITS))
        -: 2245:
        -: 2246:#define shared(kn) ((kn)->ops & ALL_REFCOUNT_BITS_SET)
        -: 2247:#define sharedo(kn) ((kn).ops & ALL_REFCOUNT_BITS_SET)
        -: 2248:
        -: 2249:
    11267: 2250:static int all_refcount_bits_set(psk kn)
        -: 2251:    {
    11267: 2252:    return (shared(kn) == ALL_REFCOUNT_BITS_SET) && !is_object(kn);
        -: 2253:    }
        -: 2254:
  5139499: 2255:static void dec_refcount(psk kn)
        -: 2256:    {
        -: 2257:    assert(kn->ops & ALL_REFCOUNT_BITS_SET);
  5139499: 2258:    kn->ops -= ONE;
  5139499: 2259:    if((kn->ops & (OPERATOR|ALL_REFCOUNT_BITS_SET)) == WORDT)
        -: 2260:        {
    10556: 2261:        if(REFCOUNTNONZERO((objectknoop*)kn))
        -: 2262:            {
        2: 2263:            DECREFCOUNT(kn);
        -: 2264:            }
        -: 2265:        }
  5139499: 2266:    }
        -: 2267:
        -: 2268:#define STRING    1
        -: 2269:#define VAPORIZED 2
        -: 2270:#define MEMORY    4
        -: 2271:#define ECHO      8
        -: 2272:
        -: 2273:#include <stdarg.h>
        -: 2274:static va_list ap;
        -: 2275:static unsigned char *startPos;
        -: 2276:
        -: 2277:static const char
        -: 2278:hekje1[] = "\1",
        -: 2279:hekje5[] = "\5",
        -: 2280:hekje6[] = "\6",
        -: 2281:unbalanced[] =
        -: 2282:"unbalanced",
        -: 2283:
        -: 2284:fct[] = "(fct=f G T P C V I B W H J O.(T=m Z a p r R Q.!arg:(?m.?Z)&0:?R:?Q&"
        -: 2285:"whl'(!Z:?a+?p*!m*?r+?Z&!R+!a:?R&!Q+!p*!r:?Q)&(!Q.!R+!Z))&(P=M E.!arg:(?M.?E)&"
        -: 2286:"whl'(!E:?*(!M|!M^((#%:~<1)+?))*?+?E)&!E:0)&(G=f e r a.!arg:(?e.?f)&0:?r&whl'("
        -: 2287:"!e:%?a+?e&!a*!f:?a&!a+!r:?r)&!r)&(C=f r A Z M.!arg:%+%:(?+?*(?M^((#<%0:?f)+?r"
        -: 2288:")&!M^!f:?M)*?+?|?+?*(?M^(#>%1+?)&P$(!M.!arg))*?+?|%?f+?r&!f:?A*~#%?`M*(?Z&P$("
        -: 2289:"!M.!r)))&!M*C$(G$(!arg.!M^-1))|!arg)&(W=n A Z M s.C$!arg:?arg:?A*((~-1:#%?n)*"
        -: 2290:"?+?:?M)*?Z&(!n:<0&-1|1):?s&!s*!n*!A*(1+!s*!n^-1*!M+-1)*!Z|!arg)&(V=n A Z M.C$"
        -: 2291:"!arg:?arg:?A*(#%?n*?+?:?M)*?Z&!n*!A*(1+!n^-1*!M+-1)*!Z|!arg)&(I=f v l r.!arg:"
        -: 2292:"(?f.?v)&!v:?l_?r&I$(!f.!l)&I$(!f.!r)|!v:#|!v\017!f:0)&(O=a f e.!arg:?a*?f^(%*"
        -: 2293:"%:?e)*?arg&!a*!f^J$(1+!e+-1)*O$!arg|!arg)&(J=t.!arg:%?t+%?arg&O$!t+(!arg:%+%&"
        -: 2294:"J|O)$!arg|!arg)&(f=L R A Z a m z S Q r q t F h N D.(D=R Q S t x r X ax zx M."
        -: 2295:"!arg:(?R.?Q)&!Q:?+%`(?*(~#%?`M&T$(!M.!Q):(?x.?r)&I$(!r.!M))*?)+?&N$!x:?x&sub$"
        -: 2296:"(!R.!M.(VAR+-1*!r)*!x^-1):?S&(!x:?ax*(%+%:?X)*?zx&T$(!X^-1.!S):(?t.?S)&1+!ax*"
        -: 2297:"!zx*(!S*!X+!t)+-1:?S|1:?x)&T$(VAR.!S):(?t.0)&N$!t*!x^-1)&!arg:(?arg.(=?N))&N$"
        -: 2298:"!arg:?arg&(!arg:%?L*%?R&f$(!L.'$N)*f$(!R.'$N)|!arg:%?L^%?R&f$(!L.!R:~/#&'$V|'"
        -: 2299:"$W)^J$(1+!R+-1)|J$!arg:?arg:#?+~#%?A+%?Z&!A:?a*~#%?`m*?z&T$(!m.!Z):(~0:?Q.?)&"
        -: 2300:"!a*!z+!Q:?t:?r&!arg:?S&1:?Q&1:?F&whl'(!r:%?q*?r&N$!q:?h*(%+%:?q)&D$(!S.!q):?S"
        -: 2301:"&!h*!F:?F&!Q*!q:?Q)&!Q+-1*!F^-1*!t:0&f$(!Q.'$N)*f$(!S.'$N)|!arg))&(B=A E M Z "
        -: 2302:"a b e m n y z.!arg:?A*%?`M^?E*(?Z&!A*!Z:?a*%?`m^?e*(?z&!a*!z:?b*?n^!e*?y&!M+"
        -: 2303:"!m:0))&B$(!b*(1+-1*!n+-1)^!e*!y*!M^(!E+!e))|!arg)&(H=A Z a b e z w x n m o."
        -: 2304:"!arg:?A*(%?b+%?z:?m)*(?Z&!b:?*?a^%?e*(?&!z:?w&whl'(!w:?*!a^?*?+?w)&!w:0&!e:?+"
        -: 2305:"#?n*(~#%@*?:?x)+(?&!z:?w&whl'(!w:?*!a^(?+#?o*(!x&(!o:<!n:?n|))+?)*?+?w)&!w:0)"
        -: 2306:"))&fct$(!A*!a^(!n*!x)*(1+!a^(-1*!n*!x)*!m+-1)*!Z)|!arg)&H$(B$(f$(!arg.'$V))))";
        -: 2307:
        -: 2308:static size_t telling = 0;
        -: 2309:
        -: 2310:#if TELMAX
        -: 2311:static size_t globalloc = 0, maxgloballoc = 0;
        -: 2312:#endif
        -: 2313:
        -: 2314:#if TELLING
        -: 2315:static size_t cnts[256],alloc_cnt = 0,totcnt = 0;
        -: 2316:#endif
        -: 2317:
        -: 2318:/*
        -: 2319:After running valid.bra  on 32 bit platform
        -: 2320:1     8           32
        -: 2321:2 16384       131072
        -: 2322:3 32696       392352
        -: 2323:4  1024        16384
        -: 2324:5  256          5120
        -: 2325:6 2048         49152
        -: 2326:              ------+
        -: 2327:total bytes = 594112
        -: 2328:*/
        -: 2329:#if WORD32
        -: 2330:#define MEM1SIZE 8
        -: 2331:#define MEM2SIZE 16384
        -: 2332:#define MEM3SIZE 32696
        -: 2333:#define MEM4SIZE 1024
        -: 2334:#define MEM5SIZE 256
        -: 2335:#define MEM6SIZE 2048
        -: 2336:#else
        -: 2337:/*
        -: 2338:After running valid.bra  on 64 bit platform
        -: 2339:1     8            64
        -: 2340:2 16384        262144
        -: 2341:3 32768        786432
        -: 2342:4  1024         32768
        -: 2343:5  2048         81920
        -: 2344:6    64          3072
        -: 2345:              -------+
        -: 2346:total bytes = 1166400
        -: 2347:*/
        -: 2348:#define MEM1SIZE 8
        -: 2349:#define MEM2SIZE 16384
        -: 2350:#define MEM3SIZE 32768
        -: 2351:#define MEM4SIZE 1024
        -: 2352:#define MEM5SIZE 2048
        -: 2353:#define MEM6SIZE 64
        -: 2354:#endif
        -: 2355:
        -: 2356:static int hum = 1;
        -: 2357:static int mooi = TRUE;
        -: 2358:static int optab[256];
        -: 2359:static int dummy_op = LUCHT;
        -: 2360:#if DEBUGBRACMAT
        -: 2361:static int debug = 0;
        -: 2362:#endif
        -: 2363:
        -: 2364:#if TELMAX
        -: 2365:static unsigned int maxbez = 0;
        -: 2366:#endif
        -: 2367:
        -: 2368:static FILE * fpi;
        -: 2369:static FILE * fpo;
        -: 2370:
        -: 2371:#if 0
        -: 2372:/*20111214 Based on http://unicode.org/Public/UNIDATA/UnicodeData.txt 2011-11-08 */
        -: 2373:/* structures created with uni.bra */
        -: 2374:struct cletter {int L:21;int range:11;};
        -: 2375:struct cletter Cletters[]={{0x41,25},{0x61,25},{0xAA,0},
        -: 2376:{0xB5,0},{0xBA,0},{0xC0,22},{0xD8,30},{0xF8,457},{0x2C6,11},{0x2E0,4},{0x2EC,0},
        -: 2377:{0x2EE,0},{0x370,4},{0x376,1},{0x37A,3},{0x386,0},{0x388,2},{0x38C,0},{0x38E,19},
        -: 2378:{0x3A3,82},{0x3F7,138},{0x48A,157},{0x531,37},{0x559,0},{0x561,38},{0x5D0,26},{0x5F0,2},
        -: 2379:{0x620,42},{0x66E,1},{0x671,98},{0x6D5,0},{0x6E5,1},{0x6EE,1},{0x6FA,2},{0x6FF,0},
        -: 2380:{0x710,0},{0x712,29},{0x74D,88},{0x7B1,0},{0x7CA,32},{0x7F4,1},{0x7FA,0},{0x800,21},
        -: 2381:{0x81A,0},{0x824,0},{0x828,0},{0x840,24},{0x8A0,0},{0x8A2,10},{0x904,53},{0x93D,0},
        -: 2382:{0x950,0},{0x958,9},{0x971,6},{0x979,6},{0x985,7},{0x98F,1},{0x993,21},{0x9AA,6},
        -: 2383:{0x9B2,0},{0x9B6,3},{0x9BD,0},{0x9CE,0},{0x9DC,1},{0x9DF,2},{0x9F0,1},{0xA05,5},
        -: 2384:{0xA0F,1},{0xA13,21},{0xA2A,6},{0xA32,1},{0xA35,1},{0xA38,1},{0xA59,3},{0xA5E,0},
        -: 2385:{0xA72,2},{0xA85,8},{0xA8F,2},{0xA93,21},{0xAAA,6},{0xAB2,1},{0xAB5,4},{0xABD,0},
        -: 2386:{0xAD0,0},{0xAE0,1},{0xB05,7},{0xB0F,1},{0xB13,21},{0xB2A,6},{0xB32,1},{0xB35,4},
        -: 2387:{0xB3D,0},{0xB5C,1},{0xB5F,2},{0xB71,0},{0xB83,0},{0xB85,5},{0xB8E,2},{0xB92,3},
        -: 2388:{0xB99,1},{0xB9C,0},{0xB9E,1},{0xBA3,1},{0xBA8,2},{0xBAE,11},{0xBD0,0},{0xC05,7},
        -: 2389:{0xC0E,2},{0xC12,22},{0xC2A,9},{0xC35,4},{0xC3D,0},{0xC58,1},{0xC60,1},{0xC85,7},
        -: 2390:{0xC8E,2},{0xC92,22},{0xCAA,9},{0xCB5,4},{0xCBD,0},{0xCDE,0},{0xCE0,1},{0xCF1,1},
        -: 2391:{0xD05,7},{0xD0E,2},{0xD12,40},{0xD3D,0},{0xD4E,0},{0xD60,1},{0xD7A,5},{0xD85,17},
        -: 2392:{0xD9A,23},{0xDB3,8},{0xDBD,0},{0xDC0,6},{0xE01,47},{0xE32,1},{0xE40,6},{0xE81,1},
        -: 2393:{0xE84,0},{0xE87,1},{0xE8A,0},{0xE8D,0},{0xE94,3},{0xE99,6},{0xEA1,2},{0xEA5,0},
        -: 2394:{0xEA7,0},{0xEAA,1},{0xEAD,3},{0xEB2,1},{0xEBD,0},{0xEC0,4},{0xEC6,0},{0xEDC,3},
        -: 2395:{0xF00,0},{0xF40,7},{0xF49,35},{0xF88,4},{0x1000,42},{0x103F,0},{0x1050,5},{0x105A,3},
        -: 2396:{0x1061,0},{0x1065,1},{0x106E,2},{0x1075,12},{0x108E,0},{0x10A0,37},{0x10C7,0},{0x10CD,0},
        -: 2397:{0x10D0,42},{0x10FC,332},{0x124A,3},{0x1250,6},{0x1258,0},{0x125A,3},{0x1260,40},{0x128A,3},
        -: 2398:{0x1290,32},{0x12B2,3},{0x12B8,6},{0x12C0,0},{0x12C2,3},{0x12C8,14},{0x12D8,56},{0x1312,3},
        -: 2399:{0x1318,66},{0x1380,15},{0x13A0,84},{0x1401,619},{0x166F,16},{0x1681,25},{0x16A0,74},{0x1700,12},
        -: 2400:{0x170E,3},{0x1720,17},{0x1740,17},{0x1760,12},{0x176E,2},{0x1780,51},{0x17D7,0},{0x17DC,0},
        -: 2401:{0x1820,87},{0x1880,40},{0x18AA,0},{0x18B0,69},{0x1900,28},{0x1950,29},{0x1970,4},{0x1980,43},
        -: 2402:{0x19C1,6},{0x1A00,22},{0x1A20,52},{0x1AA7,0},{0x1B05,46},{0x1B45,6},{0x1B83,29},{0x1BAE,1},
        -: 2403:{0x1BBA,43},{0x1C00,35},{0x1C4D,2},{0x1C5A,35},{0x1CE9,3},{0x1CEE,3},{0x1CF5,1},{0x1D00,191},
        -: 2404:{0x1E00,277},{0x1F18,5},{0x1F20,37},{0x1F48,5},{0x1F50,7},{0x1F59,0},{0x1F5B,0},{0x1F5D,0},
        -: 2405:{0x1F5F,30},{0x1F80,52},{0x1FB6,6},{0x1FBE,0},{0x1FC2,2},{0x1FC6,6},{0x1FD0,3},{0x1FD6,5},
        -: 2406:{0x1FE0,12},{0x1FF2,2},{0x1FF6,6},{0x2071,0},{0x207F,0},{0x2090,12},{0x2102,0},{0x2107,0},
        -: 2407:{0x210A,9},{0x2115,0},{0x2119,4},{0x2124,0},{0x2126,0},{0x2128,0},{0x212A,3},{0x212F,10},
        -: 2408:{0x213C,3},{0x2145,4},{0x214E,0},{0x2183,1},{0x2C00,46},{0x2C30,46},{0x2C60,132},{0x2CEB,3},
        -: 2409:{0x2CF2,1},{0x2D00,37},{0x2D27,0},{0x2D2D,0},{0x2D30,55},{0x2D6F,0},{0x2D80,22},{0x2DA0,6},
        -: 2410:{0x2DA8,6},{0x2DB0,6},{0x2DB8,6},{0x2DC0,6},{0x2DC8,6},{0x2DD0,6},{0x2DD8,6},{0x2E2F,0},
        -: 2411:{0x3005,1},{0x3031,4},{0x303B,1},{0x3041,85},{0x309D,2},{0x30A1,89},{0x30FC,3},{0x3105,40},
        -: 2412:{0x3131,93},{0x31A0,26},{0x31F0,15},{0x3400,0},{0x4DB5,0},{0x4E00,0},{0x9FCC,0},{0xA000,1164},
        -: 2413:{0xA4D0,45},{0xA500,268},{0xA610,15},{0xA62A,1},{0xA640,46},{0xA67F,24},{0xA6A0,69},{0xA717,8},
        -: 2414:{0xA722,102},{0xA78B,3},{0xA790,3},{0xA7A0,10},{0xA7F8,9},{0xA803,2},{0xA807,3},{0xA80C,22},
        -: 2415:{0xA840,51},{0xA882,49},{0xA8F2,5},{0xA8FB,0},{0xA90A,27},{0xA930,22},{0xA960,28},{0xA984,46},
        -: 2416:{0xA9CF,0},{0xAA00,40},{0xAA40,2},{0xAA44,7},{0xAA60,22},{0xAA7A,0},{0xAA80,47},{0xAAB1,0},
        -: 2417:{0xAAB5,1},{0xAAB9,4},{0xAAC0,0},{0xAAC2,0},{0xAADB,2},{0xAAE0,10},{0xAAF2,2},{0xAB01,5},
        -: 2418:{0xAB09,5},{0xAB11,5},{0xAB20,6},{0xAB28,6},{0xABC0,34},{0xAC00,0},{0xD7A3,0},{0xD7B0,22},
        -: 2419:{0xD7CB,48},{0xF900,365},{0xFA70,105},{0xFB00,6},{0xFB13,4},{0xFB1D,0},{0xFB1F,9},{0xFB2A,12},
        -: 2420:{0xFB38,4},{0xFB3E,0},{0xFB40,1},{0xFB43,1},{0xFB46,107},{0xFBD3,362},{0xFD50,63},{0xFD92,53},
        -: 2421:{0xFDF0,11},{0xFE70,4},{0xFE76,134},{0xFF21,25},{0xFF41,25},{0xFF66,88},{0xFFC2,5},{0xFFCA,5},
        -: 2422:{0xFFD2,5},{0xFFDA,2},{0x10000,11},{0x1000D,25},{0x10028,18},{0x1003C,1},{0x1003F,14},{0x10050,13},
        -: 2423:{0x10080,122},{0x10280,28},{0x102A0,48},{0x10300,30},{0x10330,16},{0x10342,7},{0x10380,29},{0x103A0,35},
        -: 2424:{0x103C8,7},{0x10400,157},{0x10800,5},{0x10808,0},{0x1080A,43},{0x10837,1},{0x1083C,0},{0x1083F,22},
        -: 2425:{0x10900,21},{0x10920,25},{0x10980,55},{0x109BE,1},{0x10A00,0},{0x10A10,3},{0x10A15,2},{0x10A19,26},
        -: 2426:{0x10A60,28},{0x10B00,53},{0x10B40,21},{0x10B60,18},{0x10C00,72},{0x11003,52},{0x11083,44},{0x110D0,24},
        -: 2427:{0x11103,35},{0x11183,47},{0x111C1,3},{0x11680,42},{0x12000,878},{0x13000,1070},{0x16800,568},{0x16F00,68},
        -: 2428:{0x16F50,0},{0x16F93,12},{0x1B000,1},{0x1D400,84},{0x1D456,70},{0x1D49E,1},{0x1D4A2,0},{0x1D4A5,1},
        -: 2429:{0x1D4A9,3},{0x1D4AE,11},{0x1D4BB,0},{0x1D4BD,6},{0x1D4C5,64},{0x1D507,3},{0x1D50D,7},{0x1D516,6},
        -: 2430:{0x1D51E,27},{0x1D53B,3},{0x1D540,4},{0x1D546,0},{0x1D54A,6},{0x1D552,339},{0x1D6A8,24},{0x1D6C2,24},
        -: 2431:{0x1D6DC,30},{0x1D6FC,24},{0x1D716,30},{0x1D736,24},{0x1D750,30},{0x1D770,24},{0x1D78A,30},{0x1D7AA,24},
        -: 2432:{0x1D7C4,7},{0x1EE00,3},{0x1EE05,26},{0x1EE21,1},{0x1EE24,0},{0x1EE27,0},{0x1EE29,9},{0x1EE34,3},
        -: 2433:{0x1EE39,0},{0x1EE3B,0},{0x1EE42,0},{0x1EE47,0},{0x1EE49,0},{0x1EE4B,0},{0x1EE4D,2},{0x1EE51,1},
        -: 2434:{0x1EE54,0},{0x1EE57,0},{0x1EE59,0},{0x1EE5B,0},{0x1EE5D,0},{0x1EE5F,0},{0x1EE61,1},{0x1EE64,0},
        -: 2435:{0x1EE67,3},{0x1EE6C,6},{0x1EE74,3},{0x1EE79,3},{0x1EE7E,0},{0x1EE80,9},{0x1EE8B,16},{0x1EEA1,2},
        -: 2436:{0x1EEA5,4},{0x1EEAB,16},{0x20000,0},{0x2A6D6,0},{0x2A700,0},{0x2B734,0},{0x2B740,0},{0x2B81D,0},
        -: 2437:{0x2F800,541},{0x1FFFFF,0}};
        -: 2438:
        -: 2439:static int isLetter(int a)
        -: 2440:    {
        -: 2441:    int i;
        -: 2442:    for(i=0;;++i)
        -: 2443:        {
        -: 2444:        if(a < Cletters[i].L)
        -: 2445:            {
        -: 2446:            --i;
        -: 2447:            return a <= Cletters[i].L+Cletters[i].range;
        -: 2448:            }
        -: 2449:        }
        -: 2450:    }
        -: 2451:#endif
        -: 2452:
        -: 2453:/*20111214 Based on http://unicode.org/Public/UNIDATA/UnicodeData.txt 2011-11-08 */
        -: 2454:/* structures created with uni.bra */
        -: 2455:struct ccaseconv {unsigned int L:21;int range:11;unsigned int inc:2;int dif:20;};
        -: 2456:struct ccaseconv l2u[]={
        -: 2457:{0x61,25,1,-32},
        -: 2458:{0xB5,0,0,743},
        -: 2459:{0xE0,22,1,-32},
        -: 2460:{0xF8,6,1,-32},
        -: 2461:{0xFF,0,0,121},
        -: 2462:{0x101,46,2,-1},
        -: 2463:{0x131,0,0,-232},
        -: 2464:{0x133,4,2,-1},
        -: 2465:{0x13A,14,2,-1},
        -: 2466:{0x14B,44,2,-1},
        -: 2467:{0x17A,4,2,-1},
        -: 2468:{0x17F,0,0,-300},
        -: 2469:{0x180,0,0,195},
        -: 2470:{0x183,2,2,-1},
        -: 2471:{0x188,0,0,-1},
        -: 2472:{0x18C,0,0,-1},
        -: 2473:{0x192,0,0,-1},
        -: 2474:{0x195,0,0,97},
        -: 2475:{0x199,0,0,-1},
        -: 2476:{0x19A,0,0,163},
        -: 2477:{0x19E,0,0,130},
        -: 2478:{0x1A1,4,2,-1},
        -: 2479:{0x1A8,0,0,-1},
        -: 2480:{0x1AD,0,0,-1},
        -: 2481:{0x1B0,0,0,-1},
        -: 2482:{0x1B4,2,2,-1},
        -: 2483:{0x1B9,0,0,-1},
        -: 2484:{0x1BD,0,0,-1},
        -: 2485:{0x1BF,0,0,56},
        -: 2486:{0x1C5,0,0,-1},
        -: 2487:{0x1C6,0,0,-2},
        -: 2488:{0x1C8,0,0,-1},
        -: 2489:{0x1C9,0,0,-2},
        -: 2490:{0x1CB,0,0,-1},
        -: 2491:{0x1CC,0,0,-2},
        -: 2492:{0x1CE,14,2,-1},
        -: 2493:{0x1DD,0,0,-79},
        -: 2494:{0x1DF,16,2,-1},
        -: 2495:{0x1F2,0,0,-1},
        -: 2496:{0x1F3,0,0,-2},
        -: 2497:{0x1F5,0,0,-1},
        -: 2498:{0x1F9,38,2,-1},
        -: 2499:{0x223,16,2,-1},
        -: 2500:{0x23C,0,0,-1},
        -: 2501:{0x23F,1,1,10815},
        -: 2502:{0x242,0,0,-1},
        -: 2503:{0x247,8,2,-1},
        -: 2504:{0x250,0,0,10783},
        -: 2505:{0x251,0,0,10780},
        -: 2506:{0x252,0,0,10782},
        -: 2507:{0x253,0,0,-210},
        -: 2508:{0x254,0,0,-206},
        -: 2509:{0x256,1,1,-205},
        -: 2510:{0x259,0,0,-202},
        -: 2511:{0x25B,0,0,-203},
        -: 2512:{0x260,0,0,-205},
        -: 2513:{0x263,0,0,-207},
        -: 2514:{0x265,0,0,42280},
        -: 2515:{0x266,0,0,42308},
        -: 2516:{0x268,0,0,-209},
        -: 2517:{0x269,0,0,-211},
        -: 2518:{0x26B,0,0,10743},
        -: 2519:{0x26F,0,0,-211},
        -: 2520:{0x271,0,0,10749},
        -: 2521:{0x272,0,0,-213},
        -: 2522:{0x275,0,0,-214},
        -: 2523:{0x27D,0,0,10727},
        -: 2524:{0x280,0,0,-218},
        -: 2525:{0x283,0,0,-218},
        -: 2526:{0x288,0,0,-218},
        -: 2527:{0x289,0,0,-69},
        -: 2528:{0x28A,1,1,-217},
        -: 2529:{0x28C,0,0,-71},
        -: 2530:{0x292,0,0,-219},
        -: 2531:{0x345,0,0,84},
        -: 2532:{0x371,2,2,-1},
        -: 2533:{0x377,0,0,-1},
        -: 2534:{0x37B,2,1,130},
        -: 2535:{0x3AC,0,0,-38},
        -: 2536:{0x3AD,2,1,-37},
        -: 2537:{0x3B1,16,1,-32},
        -: 2538:{0x3C2,0,0,-31},
        -: 2539:{0x3C3,8,1,-32},
        -: 2540:{0x3CC,0,0,-64},
        -: 2541:{0x3CD,1,1,-63},
        -: 2542:{0x3D0,0,0,-62},
        -: 2543:{0x3D1,0,0,-57},
        -: 2544:{0x3D5,0,0,-47},
        -: 2545:{0x3D6,0,0,-54},
        -: 2546:{0x3D7,0,0,-8},
        -: 2547:{0x3D9,22,2,-1},
        -: 2548:{0x3F0,0,0,-86},
        -: 2549:{0x3F1,0,0,-80},
        -: 2550:{0x3F2,0,0,7},
        -: 2551:{0x3F5,0,0,-96},
        -: 2552:{0x3F8,0,0,-1},
        -: 2553:{0x3FB,0,0,-1},
        -: 2554:{0x430,31,1,-32},
        -: 2555:{0x450,15,1,-80},
        -: 2556:{0x461,32,2,-1},
        -: 2557:{0x48B,52,2,-1},
        -: 2558:{0x4C2,12,2,-1},
        -: 2559:{0x4CF,0,0,-15},
        -: 2560:{0x4D1,86,2,-1},
        -: 2561:{0x561,37,1,-48},
        -: 2562:{0x1D79,0,0,35332},
        -: 2563:{0x1D7D,0,0,3814},
        -: 2564:{0x1E01,148,2,-1},
        -: 2565:{0x1E9B,0,0,-59},
        -: 2566:{0x1EA1,94,2,-1},
        -: 2567:{0x1F00,7,1,8},
        -: 2568:{0x1F10,5,1,8},
        -: 2569:{0x1F20,7,1,8},
        -: 2570:{0x1F30,7,1,8},
        -: 2571:{0x1F40,5,1,8},
        -: 2572:{0x1F51,6,2,8},
        -: 2573:{0x1F60,7,1,8},
        -: 2574:{0x1F70,1,1,74},
        -: 2575:{0x1F72,3,1,86},
        -: 2576:{0x1F76,1,1,100},
        -: 2577:{0x1F78,1,1,128},
        -: 2578:{0x1F7A,1,1,112},
        -: 2579:{0x1F7C,1,1,126},
        -: 2580:{0x1F80,7,1,8},
        -: 2581:{0x1F90,7,1,8},
        -: 2582:{0x1FA0,7,1,8},
        -: 2583:{0x1FB0,1,1,8},
        -: 2584:{0x1FB3,0,0,9},
        -: 2585:{0x1FBE,0,0,-7205},
        -: 2586:{0x1FC3,0,0,9},
        -: 2587:{0x1FD0,1,1,8},
        -: 2588:{0x1FE0,1,1,8},
        -: 2589:{0x1FE5,0,0,7},
        -: 2590:{0x1FF3,0,0,9},
        -: 2591:{0x214E,0,0,-28},
        -: 2592:{0x2170,15,1,-16},
        -: 2593:{0x2184,0,0,-1},
        -: 2594:{0x24D0,25,1,-26},
        -: 2595:{0x2C30,46,1,-48},
        -: 2596:{0x2C61,0,0,-1},
        -: 2597:{0x2C65,0,0,-10795},
        -: 2598:{0x2C66,0,0,-10792},
        -: 2599:{0x2C68,4,2,-1},
        -: 2600:{0x2C73,0,0,-1},
        -: 2601:{0x2C76,0,0,-1},
        -: 2602:{0x2C81,98,2,-1},
        -: 2603:{0x2CEC,2,2,-1},
        -: 2604:{0x2CF3,0,0,-1},
        -: 2605:{0x2D00,36,1,-7264},
        -: 2606:{0x2D25,2,2,-7264},
        -: 2607:{0x2D2D,0,0,-7264},
        -: 2608:{0xA641,44,2,-1},
        -: 2609:{0xA681,22,2,-1},
        -: 2610:{0xA723,12,2,-1},
        -: 2611:{0xA733,60,2,-1},
        -: 2612:{0xA77A,2,2,-1},
        -: 2613:{0xA77F,8,2,-1},
        -: 2614:{0xA78C,0,0,-1},
        -: 2615:{0xA791,2,2,-1},
        -: 2616:{0xA7A1,8,2,-1},
        -: 2617:{0xFF41,25,1,-32},
        -: 2618:{0x10428,39,1,-40},
        -: 2619:{0x1FFFFF,0,0,0}};
        -: 2620:
        -: 2621:struct ccaseconv u2l[]={
        -: 2622:{0x41,25,1,32},
        -: 2623:{0xC0,22,1,32},
        -: 2624:{0xD8,6,1,32},
        -: 2625:{0x100,46,2,1},
        -: 2626:{0x130,0,0,-199},
        -: 2627:{0x132,4,2,1},
        -: 2628:{0x139,14,2,1},
        -: 2629:{0x14A,44,2,1},
        -: 2630:{0x178,0,0,-121},
        -: 2631:{0x179,4,2,1},
        -: 2632:{0x181,0,0,210},
        -: 2633:{0x182,2,2,1},
        -: 2634:{0x186,0,0,206},
        -: 2635:{0x187,0,0,1},
        -: 2636:{0x189,1,1,205},
        -: 2637:{0x18B,0,0,1},
        -: 2638:{0x18E,0,0,79},
        -: 2639:{0x18F,0,0,202},
        -: 2640:{0x190,0,0,203},
        -: 2641:{0x191,0,0,1},
        -: 2642:{0x193,0,0,205},
        -: 2643:{0x194,0,0,207},
        -: 2644:{0x196,0,0,211},
        -: 2645:{0x197,0,0,209},
        -: 2646:{0x198,0,0,1},
        -: 2647:{0x19C,0,0,211},
        -: 2648:{0x19D,0,0,213},
        -: 2649:{0x19F,0,0,214},
        -: 2650:{0x1A0,4,2,1},
        -: 2651:{0x1A6,0,0,218},
        -: 2652:{0x1A7,0,0,1},
        -: 2653:{0x1A9,0,0,218},
        -: 2654:{0x1AC,0,0,1},
        -: 2655:{0x1AE,0,0,218},
        -: 2656:{0x1AF,0,0,1},
        -: 2657:{0x1B1,1,1,217},
        -: 2658:{0x1B3,2,2,1},
        -: 2659:{0x1B7,0,0,219},
        -: 2660:{0x1B8,0,0,1},
        -: 2661:{0x1BC,0,0,1},
        -: 2662:{0x1C4,0,0,2},
        -: 2663:{0x1C5,0,0,1},
        -: 2664:{0x1C7,0,0,2},
        -: 2665:{0x1C8,0,0,1},
        -: 2666:{0x1CA,0,0,2},
        -: 2667:{0x1CB,16,2,1},
        -: 2668:{0x1DE,16,2,1},
        -: 2669:{0x1F1,0,0,2},
        -: 2670:{0x1F2,2,2,1},
        -: 2671:{0x1F6,0,0,-97},
        -: 2672:{0x1F7,0,0,-56},
        -: 2673:{0x1F8,38,2,1},
        -: 2674:{0x220,0,0,-130},
        -: 2675:{0x222,16,2,1},
        -: 2676:{0x23A,0,0,10795},
        -: 2677:{0x23B,0,0,1},
        -: 2678:{0x23D,0,0,-163},
        -: 2679:{0x23E,0,0,10792},
        -: 2680:{0x241,0,0,1},
        -: 2681:{0x243,0,0,-195},
        -: 2682:{0x244,0,0,69},
        -: 2683:{0x245,0,0,71},
        -: 2684:{0x246,8,2,1},
        -: 2685:{0x370,2,2,1},
        -: 2686:{0x376,0,0,1},
        -: 2687:{0x386,0,0,38},
        -: 2688:{0x388,2,1,37},
        -: 2689:{0x38C,0,0,64},
        -: 2690:{0x38E,1,1,63},
        -: 2691:{0x391,16,1,32},
        -: 2692:{0x3A3,8,1,32},
        -: 2693:{0x3CF,0,0,8},
        -: 2694:{0x3D8,22,2,1},
        -: 2695:{0x3F4,0,0,-60},
        -: 2696:{0x3F7,0,0,1},
        -: 2697:{0x3F9,0,0,-7},
        -: 2698:{0x3FA,0,0,1},
        -: 2699:{0x3FD,2,1,-130},
        -: 2700:{0x400,15,1,80},
        -: 2701:{0x410,31,1,32},
        -: 2702:{0x460,32,2,1},
        -: 2703:{0x48A,52,2,1},
        -: 2704:{0x4C0,0,0,15},
        -: 2705:{0x4C1,12,2,1},
        -: 2706:{0x4D0,86,2,1},
        -: 2707:{0x531,37,1,48},
        -: 2708:{0x10A0,36,1,7264},
        -: 2709:{0x10C5,2,2,7264},
        -: 2710:{0x10CD,0,0,7264},
        -: 2711:{0x1E00,148,2,1},
        -: 2712:{0x1E9E,0,0,-7615},
        -: 2713:{0x1EA0,94,2,1},
        -: 2714:{0x1F08,7,1,-8},
        -: 2715:{0x1F18,5,1,-8},
        -: 2716:{0x1F28,7,1,-8},
        -: 2717:{0x1F38,7,1,-8},
        -: 2718:{0x1F48,5,1,-8},
        -: 2719:{0x1F59,6,2,-8},
        -: 2720:{0x1F68,7,1,-8},
        -: 2721:{0x1F88,7,1,-8},
        -: 2722:{0x1F98,7,1,-8},
        -: 2723:{0x1FA8,7,1,-8},
        -: 2724:{0x1FB8,1,1,-8},
        -: 2725:{0x1FBA,1,1,-74},
        -: 2726:{0x1FBC,0,0,-9},
        -: 2727:{0x1FC8,3,1,-86},
        -: 2728:{0x1FCC,0,0,-9},
        -: 2729:{0x1FD8,1,1,-8},
        -: 2730:{0x1FDA,1,1,-100},
        -: 2731:{0x1FE8,1,1,-8},
        -: 2732:{0x1FEA,1,1,-112},
        -: 2733:{0x1FEC,0,0,-7},
        -: 2734:{0x1FF8,1,1,-128},
        -: 2735:{0x1FFA,1,1,-126},
        -: 2736:{0x1FFC,0,0,-9},
        -: 2737:{0x2126,0,0,-7517},
        -: 2738:{0x212A,0,0,-8383},
        -: 2739:{0x212B,0,0,-8262},
        -: 2740:{0x2132,0,0,28},
        -: 2741:{0x2160,15,1,16},
        -: 2742:{0x2183,0,0,1},
        -: 2743:{0x24B6,25,1,26},
        -: 2744:{0x2C00,46,1,48},
        -: 2745:{0x2C60,0,0,1},
        -: 2746:{0x2C62,0,0,-10743},
        -: 2747:{0x2C63,0,0,-3814},
        -: 2748:{0x2C64,0,0,-10727},
        -: 2749:{0x2C67,4,2,1},
        -: 2750:{0x2C6D,0,0,-10780},
        -: 2751:{0x2C6E,0,0,-10749},
        -: 2752:{0x2C6F,0,0,-10783},
        -: 2753:{0x2C70,0,0,-10782},
        -: 2754:{0x2C72,0,0,1},
        -: 2755:{0x2C75,0,0,1},
        -: 2756:{0x2C7E,1,1,-10815},
        -: 2757:{0x2C80,98,2,1},
        -: 2758:{0x2CEB,2,2,1},
        -: 2759:{0x2CF2,0,0,1},
        -: 2760:{0xA640,44,2,1},
        -: 2761:{0xA680,22,2,1},
        -: 2762:{0xA722,12,2,1},
        -: 2763:{0xA732,60,2,1},
        -: 2764:{0xA779,2,2,1},
        -: 2765:{0xA77D,0,0,-35332},
        -: 2766:{0xA77E,8,2,1},
        -: 2767:{0xA78B,0,0,1},
        -: 2768:{0xA78D,0,0,-42280},
        -: 2769:{0xA790,2,2,1},
        -: 2770:{0xA7A0,8,2,1},
        -: 2771:{0xA7AA,0,0,-42308},
        -: 2772:{0xFF21,25,1,32},
        -: 2773:{0x10400,39,1,40},
        -: 2774:{0x1FFFFF,0,0,0}};
        -: 2775:
   226697: 2776:static int convertLetter(int a,struct ccaseconv * T)
        -: 2777:    {
        -: 2778:    int i;
   226697: 2779:    if(a > 0x10FFFF)
        1: 2780:        return a;
 28204226: 2781:    for(i=0;;++i)
        -: 2782:        {
 28204226: 2783:        if((unsigned int)a < T[i].L)
        -: 2784:            {
   226696: 2785:            if(i == 0)
    18355: 2786:                return a;
   208341: 2787:            --i;
   208341: 2788:            if  (   (unsigned int)a <= T[i].L+T[i].range
    11115: 2789:                &&  (   T[i].inc < 2
     3437: 2790:                    ||  !((a - T[i].L) & 1)
        -: 2791:                    )
        -: 2792:                )
        -: 2793:                {
    10179: 2794:                return a + T[i].dif;
        -: 2795:                }
        -: 2796:            else
        -: 2797:                {
        -: 2798:                break;
        -: 2799:                }
        -: 2800:            }
 27977530: 2801:        }
   198162: 2802:    return a;
        -: 2803:    }
        -: 2804:/*
        -: 2805:static int toUpperUnicode(int a)
        -: 2806:    {
        -: 2807:    return convertLetter(a,l2u);
        -: 2808:    }
        -: 2809:*/
    18989: 2810:static int toLowerUnicode(int a)
        -: 2811:    {
    18989: 2812:    return convertLetter(a,u2l);
        -: 2813:    }
        -: 2814:
        -: 2815:static const char quote[256] = {
        -: 2816:/*
        -: 2817:   1 : quote if first character;
        -: 2818:   3 : quote always
        -: 2819:   4 : quote if \t and \n must be expanded
        -: 2820:*/
        -: 2821:0,0,0,0,0,0,0,0,0,4,4,0,0,0,3,3, /* \L \D */
        -: 2822:0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        -: 2823:3,1,0,1,3,1,3,3,3,3,3,3,3,1,3,1, /* SP ! # $ % & ' ( ) * + , - . / */
        -: 2824:0,0,0,0,0,0,0,0,0,0,3,3,1,3,1,1, /* : < = > ? */
        -: 2825:1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* @ */
        -: 2826:0,0,0,0,0,0,0,0,0,0,0,1,3,1,3,3, /* [ \ ] ^ _ */
        -: 2827:1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, /* ` */
        -: 2828:0,0,0,0,0,0,0,0,0,0,0,3,3,3,1,0};/* { | } ~ */
        -: 2829:
        -: 2830:/*#define LATIN_1*/
        -: 2831:#ifdef LATIN_1 /* ISO8859 */ /* NOT DOS compatible! */
        -: 2832:static const unsigned char lowerEquivalent[256] =
        -: 2833:{
        -: 2834:      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
        -: 2835:     16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
        -: 2836:    ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        -: 2837:    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',
        -: 2838:    '@', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
        -: 2839:    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '[', '\\', ']', '^', '_',
        -: 2840:    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
        -: 2841:    'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z', '{', '|', '}', '~', 127,
        -: 2842:    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
        -: 2843:    144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
        -: 2844:    160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
        -: 2845:    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
        -: 2846:    224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
        -: 2847:    240, 241, 242, 243, 244, 245, 246, 215, 248, 249, 250, 251, 252, 253, 254, 223 /*ringel s*/,
        -: 2848:    224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239,
        -: 2849:    240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255
        -: 2850:};
        -: 2851:
        -: 2852:static const unsigned char upperEquivalent[256] =
        -: 2853:{
        -: 2854:      0,   1,   2,   3,   4,   5,   6,   7,   8,   9,  10,  11,  12,  13,  14,  15,
        -: 2855:     16,  17,  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,  28,  29,  30,  31,
        -: 2856:    ' ', '!', '"', '#', '$', '%', '&', '\'', '(', ')', '*', '+', ',', '-', '.', '/',
        -: 2857:    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', ':', ';', '<', '=', '>', '?',
        -: 2858:    '@', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
        -: 2859:    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '[', '\\', ']', '^', '_',
        -: 2860:    '`', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O',
        -: 2861:    'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z', '{', '|', '}', '~', 127,
        -: 2862:    128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143,
        -: 2863:    144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,
        -: 2864:    160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
        -: 2865:    176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191,
        -: 2866:    192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
        -: 2867:    208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223,
        -: 2868:    192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207,
        -: 2869:    208, 209, 210, 211, 212, 213, 214, 247, 216, 217, 218, 219, 220, 221, 222, 255 /* ij */
        -: 2870:};
        -: 2871:#endif
        -: 2872:
        -: 2873:#if CODEPAGE850
        -: 2874:static unsigned char ISO8859toCodePage850(unsigned char kar)
        -: 2875:
        -: 2876:{
        -: 2877:    static unsigned char translationTable[] =
        -: 2878:    {
        -: 2879:    0xBA,0xCD,0xC9,0xBB,0xC8,0xBC,0xCC,0xB9,0xCB,0xCA,0xCE,0xDF,0xDC,0xDB,0xFE,0xF2,
        -: 2880:    0xB3,0xC4,0xDA,0xBF,0xC0,0xD9,0xC3,0xB4,0xC2,0xC1,0xC5,0xB0,0xB1,0xB2,0xD5,0x9F,
        -: 2881:    0xFF,0xAD,0xBD,0x9C,0xCF,0xBE,0xDD,0xF5,0xF9,0xB8,0xA6,0xAE,0xAA,0xF0,0xA9,0xEE,
        -: 2882:    0xF8,0xF1,0xFD,0xFC,0xEF,0xE6,0xF4,0xFA,0xF7,0xFB,0xA7,0xAF,0xAC,0xAB,0xF3,0xA8,
        -: 2883:    0xB7,0xB5,0xB6,0xC7,0x8E,0x8F,0x92,0x80,0xD4,0x90,0xD2,0xD3,0xDE,0xD6,0xD7,0xD8,
        -: 2884:    0xD1,0xA5,0xE3,0xE0,0xE2,0xE5,0x99,0x9E,0x9D,0xEB,0xE9,0xEA,0x9A,0xED,0xE8,0xE1,
        -: 2885:    0x85,0xA0,0x83,0xC6,0x84,0x86,0x91,0x87,0x8A,0x82,0x88,0x89,0x8D,0xA1,0x8C,0x8B,
        -: 2886:    0xD0,0xA4,0x95,0xA2,0x93,0xE4,0x94,0xF6,0x9B,0x97,0xA3,0x96,0x81,0xEC,0xE7,0x98
        -: 2887:    };
        -: 2888:
        -: 2889:    if(kar & 0x80)
        -: 2890:        return translationTable[kar & 0x7F];
        -: 2891:    else
        -: 2892:        return kar;
        -: 2893:/*    return kar & 0x80 ? (unsigned char)translationTable[kar & 0x7F] : kar;*/
        -: 2894:}
        -: 2895:
        -: 2896:static unsigned char CodePage850toISO8859(unsigned char kar)
        -: 2897:{
        -: 2898:    static unsigned char translationTable[] =
        -: 2899:    {
        -: 2900:    0xC7,0xFC,0xE9,0xE2,0xE4,0xE0,0xE5,0xE7,0xEA,0xEB,0xE8,0xEF,0xEE,0xEC,0xC4,0xC5,
        -: 2901:    0xC9,0xE6,0xC6,0xF4,0xF6,0xF2,0xFB,0xF9,0xFF,0xD6,0xDC,0xF8,0xA3,0xD8,0xD7,0x9F,
        -: 2902:    0xE1,0xED,0xF3,0xFA,0xF1,0xD1,0xAA,0xBA,0xBF,0xAE,0xAC,0xBD,0xBC,0xA1,0xAB,0xBB,
        -: 2903:    0x9B,0x9C,0x9D,0x90,0x97,0xC1,0xC2,0xC0,0xA9,0x87,0x80,0x83,0x85,0xA2,0xA5,0x93,
        -: 2904:    0x94,0x99,0x98,0x96,0x91,0x9A,0xE3,0xC3,0x84,0x82,0x89,0x88,0x86,0x81,0x8A,0xA4,
        -: 2905:    0xF0,0xD0,0xCA,0xCB,0xC8,0x9E,0xCD,0xCE,0xCF,0x95,0x92,0x8D,0x8C,0xA6,0xCC,0x8B,
        -: 2906:    0xD3,0xDF,0xD4,0xD2,0xF5,0xD5,0xB5,0xFE,0xDE,0xDA,0xDB,0xD9,0xFD,0xDD,0xAF,0xB4,
        -: 2907:    0xAD,0xB1,0x8F,0xBE,0xB6,0xA7,0xF7,0xB8,0xB0,0xA8,0xB7,0xB9,0xB3,0xB2,0x8E,0xA0,
        -: 2908:    };
        -: 2909:
        -: 2910:    /* 0x7F = 127, 0xFF = 255 */
        -: 2911:    /* delete bit-7 before search in tabel (0-6 is unchanged) */
        -: 2912:    /* delete bit 15-8 */
        -: 2913:
        -: 2914:    if(kar & 0x80)
        -: 2915:        return translationTable[kar & 0x7F];
        -: 2916:    else
        -: 2917:        return kar;
        -: 2918:/*    return kar & 0x80 ? (unsigned char)translationTable[kar & 0x7F] : kar;*/
        -: 2919:}
        -: 2920:#endif
        -: 2921:
        -: 2922:
        -: 2923:
        -: 2924:#ifdef DELAY_DUE_TO_INPUT
        -: 2925:static clock_t delayDueToInput = 0;
        -: 2926:#endif
        -: 2927:
        -: 2928:#ifdef __SYMBIAN32__
        -: 2929:/* #define DEFAULT_INPUT_BUFFER_SIZE 0x100*/ /* If too high you get __chkstk error. Stack = 8K only! */
        -: 2930:/* #define DEFAULT_INPUT_BUFFER_SIZE 0x7F00*/
        -: 2931:#define DEFAULT_INPUT_BUFFER_SIZE 0x2000
        -: 2932:#else
        -: 2933:#ifdef _MSC_VER
        -: 2934:#define DEFAULT_INPUT_BUFFER_SIZE 0x7F00 /* Microsoft C staat 32k automatic data toe */
        -: 2935:
        -: 2936:#else
        -: 2937:#ifdef __BORLANDC__
        -: 2938:#if __BORLANDC__ >= 0x500
        -: 2939:#define DEFAULT_INPUT_BUFFER_SIZE 0x7000
        -: 2940:#else
        -: 2941:#define DEFAULT_INPUT_BUFFER_SIZE 0x7FFC
        -: 2942:#endif
        -: 2943:#else
        -: 2944:#define DEFAULT_INPUT_BUFFER_SIZE 0x7FFC
        -: 2945:#endif
        -: 2946:#endif
        -: 2947:#endif
        -: 2948:
        -: 2949:#ifndef UNREFERENCED_PARAMETER /* 20080102 */
        -: 2950:#if defined _MSC_VER
        -: 2951:#define UNREFERENCED_PARAMETER(P) (P)
        -: 2952:#else
        -: 2953:#define UNREFERENCED_PARAMETER(P)
        -: 2954:#endif
        -: 2955:#endif
        -: 2956:
        -: 2957:static psk anker;
        -: 2958:
        -: 2959:typedef struct inputBuffer
        -: 2960:    {
        -: 2961:    unsigned char * buffer;
        -: 2962:    unsigned int cutoff:1;    /* Set to true if very long string does not fit in buffer of size DEFAULT_INPUT_BUFFER_SIZE */
        -: 2963:    unsigned int mallocallocated:1; /* True if allocated with malloc. Otherwise on stack (except EPOC). */
        -: 2964:    } inputBuffer;
        -: 2965:
        -: 2966:static inputBuffer * InputArray;
        -: 2967:static inputBuffer * InputElement; /* Points to member of InputArray */
        -: 2968:static unsigned char *start,**pstart,*bron;
        -: 2969:static unsigned char * wijzer;
        -: 2970:static unsigned char * maxwijzer; /* wijzer <= maxwijzer,
        -: 2971:                            if wijzer == maxwijzer, don't assign to *wijzer */
        -: 2972:
        -: 2973:
        -: 2974:/* FUNCTIONS */
        -: 2975:
        -: 2976:static void hreslt(psk wortel,int nivo,int ind,int space);
        -: 2977:#if DEBUGBRACMAT
        -: 2978:static void hreslts(psk wortel,int nivo,int ind,int space,psk snijaf);
        -: 2979:#endif
        -: 2980:
        -: 2981:static psk eval(psk pkn);
        -: 2982:#define evalueer(x) \
        -: 2983:(    ( ((x) = eval(x))->v.fl \
        -: 2984:     & SUCCESS\
        -: 2985:     ) \
        -: 2986:   ? TRUE\
        -: 2987:   : ((x)->v.fl & FENCE)\
        -: 2988:)
        -: 2989:
        -: 2990:#define isSUCCESS(x) ((x)->v.fl & SUCCESS)
        -: 2991:#define isFENCE(x) (((x)->v.fl & (SUCCESS|FENCE)) == FENCE)
        -: 2992:#define isSUCCESSorFENCE(x) ((x)->v.fl & (SUCCESS|FENCE))
        -: 2993:#define isFailed(x) (((x)->v.fl & (SUCCESS|FENCE)) == 0)
        -: 2994:
        -: 2995:static psk subboomcopie(psk src);
        -: 2996:
        -: 2997:#if _BRACMATEMBEDDED
        -: 2998:
        -: 2999:static int (*WinIn)(void) = NULL;
        -: 3000:static void (*WinOut)(int c) = NULL;
        -: 3001:static void (*WinFlush)(void) = NULL;
        -: 3002:
        -: 3003:static int mygetc(FILE * fpi)
        -: 3004:    {
        -: 3005:    if(WinIn && fpi == stdin)
        -: 3006:        {
        -: 3007:        return WinIn();
        -: 3008:        }
        -: 3009:    else
        -: 3010:        return fgetc(fpi);
        -: 3011:    }
        -: 3012:
        -: 3013:
        -: 3014:static void myputc(int c)
        -: 3015:    {
        -: 3016:    if(WinOut && (fpo == stdout || fpo == stderr))
        -: 3017:        {
        -: 3018:        WinOut(c);
        -: 3019:        }
        -: 3020:    else
        -: 3021:        fputc(c,fpo);
        -: 3022:    }
        -: 3023:#else
   618947: 3024:static void myputc(int c)
        -: 3025:    {
   618947: 3026:    fputc(c,fpo);
   618947: 3027:    }
        -: 3028:
   754129: 3029:static int mygetc(FILE * fpi)
        -: 3030:    {
        -: 3031:#ifdef __SYMBIAN32__
        -: 3032:    if(fpi == stdin)
        -: 3033:        {
        -: 3034:        static unsigned char inputbuffer[256] = {0};
        -: 3035:        static unsigned char * out = inputbuffer;
        -: 3036:        if(!*out)
        -: 3037:            {
        -: 3038:            static unsigned char * in = inputbuffer;
        -: 3039:            static int kar;
        -: 3040:            while(  in < inputbuffer + sizeof(inputbuffer) - 2
        -: 3041:                 && (kar = fgetc(fpi)) != '\n'
        -: 3042:                 )
        -: 3043:                {
        -: 3044:                switch(kar)
        -: 3045:                    {
        -: 3046:                    case '\r':
        -: 3047:                        break;
        -: 3048:                    case 8:
        -: 3049:                        if(in > inputbuffer)
        -: 3050:                            {
        -: 3051:                            --in;
        -: 3052:                            putchar(' ');
        -: 3053:                            putchar(8);
        -: 3054:                            }
        -: 3055:                        break;
        -: 3056:                    default:
        -: 3057:                        *in++ = kar;
        -: 3058:                    }
        -: 3059:                }
        -: 3060:            *in = kar;
        -: 3061:            *++in = '\0';
        -: 3062:            out = in = inputbuffer;
        -: 3063:            }
        -: 3064:        return *out++;
        -: 3065:        }
        -: 3066:#endif
   754129: 3067:    return fgetc(fpi);
        -: 3068:    }
        -: 3069:#endif
        -: 3070:
        -: 3071:static void (*verwerk)(int c) = myputc;
        -: 3072:
       44: 3073:static void myprintf(char *string,...)
        -: 3074:{
        -: 3075:char *i,*j;
        -: 3076:va_list ap;
       44: 3077:va_start(ap,string);
       44: 3078:i = string;
      150: 3079:while(i)
        -: 3080:    {
      154: 3081:    for(j = i;*j;j++)
       92: 3082:        (*verwerk)(*j);
       62: 3083:    i = va_arg(ap,char *);
        -: 3084:    }
       44: 3085:va_end(ap);
       44: 3086:}
        -: 3087:
        -: 3088:
        -: 3089:#if _BRACMATEMBEDDED && !defined _MT
        -: 3090:static int Printf(const char *fmt, ...)
        -: 3091:    {
        -: 3092:    char buffer[1000];
        -: 3093:    int ret;
        -: 3094:    va_list ap;
        -: 3095:    va_start(ap,fmt);
        -: 3096:    ret = vsprintf(buffer,fmt,ap);
        -: 3097:    myprintf(buffer,NULL);
        -: 3098:    va_end(ap);
        -: 3099:    return ret;
        -: 3100:    }
        -: 3101:#else
        -: 3102:#define Printf printf
        -: 3103:#endif
        -: 3104:
    #####: 3105:static int errorprintf(const char *fmt, ...)
        -: 3106:    {
        -: 3107:    char buffer[1000];
        -: 3108:    int ret;
    #####: 3109:    FILE * save = fpo;
        -: 3110:    va_list ap;
    #####: 3111:    va_start(ap,fmt);
    #####: 3112:    ret = vsprintf(buffer,fmt,ap);
    #####: 3113:    fpo = errorStream;
        -: 3114:#if !defined NO_FOPEN
    #####: 3115:    if(fpo == NULL && errorFileName != NULL)
    #####: 3116:        fpo = fopen(errorFileName,"a");
        -: 3117:#endif
        -: 3118:/*#endif*/
    #####: 3119:    if(fpo)
    #####: 3120:        myprintf(buffer,NULL);
        -: 3121:    else
    #####: 3122:        ret = 0;
        -: 3123:/*#if !_BRACMATEMBEDDED*/
        -: 3124:#if !defined NO_FOPEN
    #####: 3125:    if(errorStream == NULL && fpo != NULL)
    #####: 3126:        fclose(fpo); /* 20100312 */
        -: 3127:#endif
        -: 3128:/*#endif*/
    #####: 3129:    fpo = save;
    #####: 3130:    va_end(ap);
    #####: 3131:    return ret;
        -: 3132:    }
        -: 3133:
        -: 3134:struct memblock
        -: 3135:    {
        -: 3136:    void * lowestAddress;
        -: 3137:    void * highestAddress;
        -: 3138:    void * firstFreeElementBetweenAddresses; /* if NULL : no more free elements */
        -: 3139:    struct memblock * previousOfSameLength; /* address of older ands smaller block with same sized elements */ 
        -: 3140:    size_t sizeOfElement;
        -: 3141:#if TELMAX
        -: 3142:    size_t numberOfFreeElementsBetweenAddresses; /* optional field. */
        -: 3143:    size_t numberOfElementsBetweenAddresses; /* optional field. */
        -: 3144:    size_t minimumNumberOfFreeElementsBetweenAddresses;
        -: 3145:#endif
        -: 3146:    };
        -: 3147:
        -: 3148:struct allocation
        -: 3149:    {
        -: 3150:    size_t elementSize;
        -: 3151:    int numberOfElements;
        -: 3152:    struct memblock * memoryBlock;
        -: 3153:    };
        -: 3154:
        -: 3155:static struct allocation * allocations;
        -: 3156:static int nallocations = 0;
        -: 3157:
        -: 3158:
        -: 3159:struct memoryElement
        -: 3160:    {
        -: 3161:    void * next;
        -: 3162:    };
        -: 3163:
        -: 3164:struct pointerStruct
        -: 3165:    {
        -: 3166:    struct pointerStruct * lp;
        -: 3167:    } *p, *ep;
        -: 3168:
        -: 3169:/*struct memblock * MemBlocks = 0;*/
        -: 3170:struct memblock ** pMemBlocks = 0; /* list of memblock, sorted
        -: 3171:                                      according to memory address */
        -: 3172:static int NumberOfMemBlocks = 0;
        -: 3173:#if TELMAX
        -: 3174:static int malloced = 0;
        -: 3175:#endif
        -: 3176:
        -: 3177:#if DOSUMCHECK
        -: 3178:
        -: 3179:static int LineNo;
        -: 3180:static int N;
        -: 3181:
        -: 3182:static int getchecksum(void)
        -: 3183:    {
        -: 3184:    int i;
        -: 3185:    int sum = 0;
        -: 3186:    for(i = 0; i < NumberOfMemBlocks;++i)
        -: 3187:        {
        -: 3188:        struct memoryElement * me;
        -: 3189:        struct memblock * mb = pMemBlocks[i];
        -: 3190:        me = mb->firstFreeElementBetweenAddresses;
        -: 3191:        while(me)
        -: 3192:            {
        -: 3193:            sum += (LONG)me;
        -: 3194:            me = me->next;
        -: 3195:            }
        -: 3196:        }
        -: 3197:    return sum;
        -: 3198:    }
        -: 3199:
        -: 3200:static int Checksum = 0;
        -: 3201:
        -: 3202:static void setChecksum(int lineno,int n)
        -: 3203:    {
        -: 3204:    if(lineno)
        -: 3205:        {
        -: 3206:        LineNo = lineno;
        -: 3207:        N = n;
        -: 3208:        }
        -: 3209:    Checksum = getchecksum();
        -: 3210:    }
        -: 3211:
        -: 3212:static void checksum(int line)
        -: 3213:    {
        -: 3214:    static int nChecksum = 0;
        -: 3215:    nChecksum = getchecksum();
        -: 3216:    if(Checksum && Checksum != nChecksum)
        -: 3217:        {
        -: 3218:        Printf("Line %d: Illegal write after bmalloc(%d) on line %d",line,N,LineNo);
        -: 3219:        getchar();
        -: 3220:        exit(1);
        -: 3221:        }
        -: 3222:    }
        -: 3223:#else
        -: 3224:#define setChecksum(a,b)
        -: 3225:#define bmalloc(LINENO,N) bmalloc(N)
        -: 3226:#define checksum(a)
        -: 3227:#endif
        -: 3228:
        -: 3229:#if CHECKALLOCBOUNDS
        -: 3230:static int isFree(void * p)
        -: 3231:    {
        -: 3232:    LONG * q;
        -: 3233:    int i;
        -: 3234:    struct memoryElement * I;
        -: 3235:    q = (LONG *)p - 2;
        -: 3236:    I = (struct memoryElement *) q;
        -: 3237:    for(i = 0; i < NumberOfMemBlocks;++i)
        -: 3238:        {
        -: 3239:        struct memoryElement * me;
        -: 3240:        struct memblock * mb = pMemBlocks[i];
        -: 3241:        me = (struct memoryElement *) mb->firstFreeElementBetweenAddresses;
        -: 3242:        while(me)
        -: 3243:            {
        -: 3244:            if(I == me)
        -: 3245:                return 1;
        -: 3246:            me = (struct memoryElement *) me->next;
        -: 3247:            }
        -: 3248:        }
        -: 3249:    return 0;
        -: 3250:    }
        -: 3251:
        -: 3252:static void result(psk wortel);
        -: 3253:static int rfree(psk p)
        -: 3254:    {
        -: 3255:    int r = 0;
        -: 3256:    if(isFree(p))
        -: 3257:        {
        -: 3258:        printf(" [");
        -: 3259:        result(p);
        -: 3260:        printf("] ");
        -: 3261:        r = 1;
        -: 3262:        }
        -: 3263:    if(is_op(p))
        -: 3264:        {
        -: 3265:        r |= rfree(p->LEFT);
        -: 3266:        r |= rfree(p->RIGHT);
        -: 3267:        }
        -: 3268:    return r;
        -: 3269:    }
        -: 3270:
        -: 3271:static int POINT = 0;
        -: 3272:
        -: 3273:static int areFree(char * t,psk p)
        -: 3274:    {
        -: 3275:    if(rfree(p))
        -: 3276:        {
        -: 3277:        POINT = 1;
        -: 3278:        printf("%s:areFree(",t);
        -: 3279:        result(p);
        -: 3280:        POINT = 0;
        -: 3281:        printf("\n");
        -: 3282:        return 1;
        -: 3283:        }
        -: 3284:    return 0;
        -: 3285:    }
        -: 3286:
        -: 3287:static void checkMem(void * p)
        -: 3288:    {
        -: 3289:    LONG * q;
        -: 3290:    q = (LONG *)p - 2;
        -: 3291:    if(q[0] == ('s'<<24)+('t'<<16)+('a'<<8)+('r')
        -: 3292:        && q[q[1]] == ('t'<<24)+('e'<<16)+('n'<<8)+('d')
        -: 3293:        )
        -: 3294:        {
        -: 3295:        ;
        -: 3296:        }
        -: 3297:    else
        -: 3298:        {
        -: 3299:        char * s = (char *)q;
        -: 3300:        printf("s:[");
        -: 3301:        for(;s < (char *)(q + q[1] + 1);++s)
        -: 3302:            {
        -: 3303:            if((((int)s) % 4) == 0)
        -: 3304:                printf("|");
        -: 3305:            if(' ' <= *s && *s <= 127)
        -: 3306:                printf(" %c",*s);
        -: 3307:            else
        -: 3308:                printf("%.2x",(int)((unsigned char)*s));
        -: 3309:            }
        -: 3310:        printf("] %p\n",p);
        -: 3311:        }
        -: 3312:    assert(q[0] == ('s'<<24)+('t'<<16)+('a'<<8)+('r'));
        -: 3313:    assert(q[q[1]] == ('t'<<24)+('e'<<16)+('n'<<8)+('d'));
        -: 3314:    }
        -: 3315:
        -: 3316:
        -: 3317:static void checkBounds(void * p)
        -: 3318:    {
        -: 3319:    struct memblock ** q;
        -: 3320:    LONG * lp = (LONG *)p;
        -: 3321:    assert(p != 0);
        -: 3322:    checkMem(p);
        -: 3323:    lp = lp - 2;
        -: 3324:    p = lp;
        -: 3325:    assert(lp[0] == ('s'<<24)+('t'<<16)+('a'<<8)+('r'));
        -: 3326:    assert(lp[lp[1]] == ('t'<<24)+('e'<<16)+('n'<<8)+('d'));
        -: 3327:    for(q = pMemBlocks+NumberOfMemBlocks; --q >= pMemBlocks ;)
        -: 3328:        {
        -: 3329:        size_t stepSize = (*q)->sizeOfElement / sizeof(struct pointerStruct);
        -: 3330:        if((*q)->lowestAddress <= p && p < (*q)->highestAddress)
        -: 3331:            {
        -: 3332:            assert(lp[stepSize - 1] == ('t'<<24)+('e'<<16)+('n'<<8)+('d'));
        -: 3333:            return;
        -: 3334:            }
        -: 3335:        }
        -: 3336:    }
        -: 3337:
        -: 3338:static void checkAllBounds()
        -: 3339:    {
        -: 3340:    struct memblock ** q;
        -: 3341:    for(q = pMemBlocks+NumberOfMemBlocks; --q >= pMemBlocks ;)
        -: 3342:        {
        -: 3343:        size_t stepSize = (*q)->sizeOfElement / sizeof(struct pointerStruct);
        -: 3344:
        -: 3345:        struct pointerStruct * p = (struct pointerStruct *)(*q)->lowestAddress;
        -: 3346:        struct pointerStruct * e = (struct pointerStruct *)(*q)->highestAddress;
        -: 3347:        size_t L = (*q)->sizeOfElement - 1;
        -: 3348:        struct pointerStruct * x;
        -: 3349:        for(x = p;x < e;x += stepSize)
        -: 3350:            {
        -: 3351:            struct pointerStruct * a = ((struct memoryElement *)x)->next;
        -: 3352:            if(a == 0 || (p <= a && a < e))
        -: 3353:                ;
        -: 3354:            else
        -: 3355:                {
        -: 3356:                if((((LONG *)x)[0] == ('s'<<24)+('t'<<16)+('a'<<8)+('r'))
        -: 3357:                    &&(((LONG *)x)[stepSize - 1] == ('t'<<24)+('e'<<16)+('n'<<8)+('d')))
        -: 3358:                    ;
        -: 3359:                else
        -: 3360:                    {
        -: 3361:                    char * s = (char *)x;
        -: 3362:                    printf("s:[");
        -: 3363:                    for(;s <= (char *)x + L;++s)
        -: 3364:                        if(' ' <= *s && *s <= 127)
        -: 3365:                            printf("%c",*s);
        -: 3366:                        else if(*s == 0)
        -: 3367:                            printf("√ò");
        -: 3368:                        else
        -: 3369:                            printf("-",*s);
        -: 3370:                    printf("] %p\n",x);
        -: 3371:                    }
        -: 3372:                assert(((LONG *)x)[0] == ('s'<<24)+('t'<<16)+('a'<<8)+('r'));
        -: 3373:                assert(((LONG *)x)[stepSize - 1] == ('t'<<24)+('e'<<16)+('n'<<8)+('d'));
        -: 3374:                }
        -: 3375:            }
        -: 3376:        }
        -: 3377:    }
        -: 3378:#endif
        -: 3379:
  2367637: 3380:static void bfree(void *p)
        -: 3381:    {
        -: 3382:    struct memblock ** q;
        -: 3383:#if CHECKALLOCBOUNDS
        -: 3384:    LONG * lp = (LONG *)p;
        -: 3385:#endif
        -: 3386:    assert(p != 0);
        -: 3387:    checksum(__LINE__);
        -: 3388:#if CHECKALLOCBOUNDS
        -: 3389:    checkBounds(p);
        -: 3390:    lp = lp - 2;
        -: 3391:    p = lp;
        -: 3392:#endif
        -: 3393:#if TELMAX
  2367637: 3394:    globalloc--;
        -: 3395:#endif
  9695143: 3396:    for(q = pMemBlocks+NumberOfMemBlocks; --q >= pMemBlocks ;)
        -: 3397:        {
  7197379: 3398:        if((*q)->lowestAddress <= p && p < (*q)->highestAddress)
        -: 3399:            {
        -: 3400:#if TELMAX
  2237510: 3401:            ++((*q)->numberOfFreeElementsBetweenAddresses);
        -: 3402:#endif
  2237510: 3403:            ((struct memoryElement *)p)->next = (*q)->firstFreeElementBetweenAddresses;
  2237510: 3404:            (*q)->firstFreeElementBetweenAddresses = p;
        -: 3405:            setChecksum(LineNo,N);
  4605147: 3406:            return;
        -: 3407:            }
        -: 3408:        }
   130127: 3409:    free(p);
        -: 3410:#if TELMAX
   130127: 3411:    --malloced;
        -: 3412:#endif
        -: 3413:    setChecksum(LineNo,N);
        -: 3414:    }
        -: 3415:
        -: 3416:#if TELLING
        -: 3417:static void bezetting(void)
        -: 3418:    {
        -: 3419:    struct memblock * mb = 0;
        -: 3420:    size_t words = 0;
        -: 3421:    int i;
        -: 3422:    Printf("\noccupied (promilles)\n");
        -: 3423:    for(i = 0; i < NumberOfMemBlocks;++i)
        -: 3424:        {
        -: 3425:        mb = pMemBlocks[i];
        -: 3426:        Printf("%d word : %lu\n",mb->sizeOfElement/sizeof(struct pointerStruct),1000UL-(1000UL * mb->numberOfFreeElementsBetweenAddresses)/mb->numberOfElementsBetweenAddresses);
        -: 3427:        }
        -: 3428:    Printf("\nmax occupied (promilles)\n");
        -: 3429:    for(i = 0; i < NumberOfMemBlocks;++i)
        -: 3430:        {
        -: 3431:        mb = pMemBlocks[i];
        -: 3432:        Printf("%d word : %lu\n",mb->sizeOfElement/sizeof(struct pointerStruct),1000UL-(1000UL * mb->minimumNumberOfFreeElementsBetweenAddresses)/mb->numberOfElementsBetweenAddresses);
        -: 3433:        }
        -: 3434:    Printf("\noccupied (absolute)\n");
        -: 3435:    for(i = 0; i < NumberOfMemBlocks;++i)
        -: 3436:        {
        -: 3437:        mb = pMemBlocks[i];
        -: 3438:        words = mb->sizeOfElement/sizeof(struct pointerStruct);
        -: 3439:        Printf("%d word : %lu\n",words,(mb->numberOfElementsBetweenAddresses - mb->numberOfFreeElementsBetweenAddresses));
        -: 3440:        }
        -: 3441:    Printf("more than %d words : %lu\n",words,malloced);
        -: 3442:    }
        -: 3443:#endif
        -: 3444:
       11: 3445:static struct memblock * initializeMemBlock(size_t elementSize, size_t numberOfElements)
        -: 3446:    {
        -: 3447:    size_t nlongpointers;
        -: 3448:    size_t stepSize;
        -: 3449:    struct memblock * mb;
       11: 3450:    mb = (struct memblock *)malloc(sizeof(struct memblock));
       11: 3451:    mb->sizeOfElement = elementSize;
       11: 3452:    mb->previousOfSameLength = 0;
       11: 3453:    stepSize = elementSize / sizeof(struct pointerStruct);
       11: 3454:    nlongpointers = elementSize * numberOfElements / sizeof(struct pointerStruct);
       11: 3455:    mb->firstFreeElementBetweenAddresses = mb->lowestAddress = malloc(sizeof(struct pointerStruct) * nlongpointers);
        -: 3456:#if TELMAX
       11: 3457:    mb->numberOfElementsBetweenAddresses = numberOfElements;
        -: 3458:#endif
       11: 3459:    if(mb->lowestAddress == 0)
        -: 3460:        {
        -: 3461:#if _BRACMATEMBEDDED
        -: 3462:        return 0;
        -: 3463:#else
    #####: 3464:        exit(-1);
        -: 3465:#endif
        -: 3466:        }
       11: 3467:    p = (struct pointerStruct *)mb->lowestAddress;
       11: 3468:    ep = p + nlongpointers;
       11: 3469:    mb->highestAddress = (void*)ep;
        -: 3470:#if TELMAX
       11: 3471:    mb->numberOfFreeElementsBetweenAddresses = numberOfElements;
        -: 3472:#endif
       11: 3473:    ep -= stepSize;
   297939: 3474:    for (
   297928: 3475:        ;p < ep
   297917: 3476:        ;p = p->lp
        -: 3477:        )
   297917: 3478:        p->lp = p+stepSize;
       11: 3479:    p->lp = 0;
       11: 3480:    return mb;
        -: 3481:    }
        -: 3482:/*
        -: 3483:static void showMemBlocks()
        -: 3484:    {
        -: 3485:    int totalbytes;
        -: 3486:    int i;
        -: 3487:    for(i = 0;i < NumberOfMemBlocks;++i)
        -: 3488:        {
        -: 3489:        printf  ("%p %d %p <= %p <= %p [%p] %lu\n"
        -: 3490:            ,pMemBlocks[i]
        -: 3491:        ,i
        -: 3492:            ,pMemBlocks[i]->lowestAddress
        -: 3493:            ,pMemBlocks[i]->firstFreeElementBetweenAddresses
        -: 3494:            ,pMemBlocks[i]->highestAddress
        -: 3495:            ,pMemBlocks[i]->previousOfSameLength
        -: 3496:            ,pMemBlocks[i]->sizeOfElement
        -: 3497:            );
        -: 3498:        }
        -: 3499:    totalbytes = 0;
        -: 3500:    for(i = 0;i < nallocations;++i)
        -: 3501:        {
        -: 3502:        printf  ("%d %d %lu\n"
        -: 3503:            ,i+1
        -: 3504:            ,allocations[i].numberOfElements
        -: 3505:            ,allocations[i].numberOfElements * (i+1) * sizeof(struct pointerStruct)
        -: 3506:            );
        -: 3507:        totalbytes += allocations[i].numberOfElements * (i+1) * sizeof(struct pointerStruct);
        -: 3508:        }
        -: 3509:    printf("total bytes = %d\n",totalbytes);
        -: 3510:    }
        -: 3511:*/
        -: 3512:
        -: 3513:/* 20120702 The newMemBlocks function is introduced because the same code,
        -: 3514:if in-line in bmalloc, and if compiled with -O3, doesn't run. */
        5: 3515:static struct memblock * newMemBlocks(size_t n)
        -: 3516:    {
        -: 3517:    struct memblock * mb;
        5: 3518:    int i,j = 0;
        -: 3519:    struct memblock ** npMemBlocks;
        5: 3520:    mb = initializeMemBlock(allocations[n].elementSize, allocations[n].numberOfElements);
        5: 3521:    if(!mb)
    #####: 3522:        return 0;
        5: 3523:    allocations[n].numberOfElements *= 2;
        5: 3524:    mb->previousOfSameLength = allocations[n].memoryBlock;
        5: 3525:    allocations[n].memoryBlock = mb;
        -: 3526:
        5: 3527:    ++NumberOfMemBlocks;
        5: 3528:    npMemBlocks = (struct memblock **)malloc((NumberOfMemBlocks)*sizeof(struct memblock *));
       40: 3529:    for(i = 0;i < NumberOfMemBlocks - 1;++i)
        -: 3530:        {
       39: 3531:        if(mb < pMemBlocks[i])
        -: 3532:            {
        4: 3533:            npMemBlocks[j++] = mb;
        9: 3534:            for(;i < NumberOfMemBlocks - 1;++i)
        -: 3535:                {
        5: 3536:                npMemBlocks[j++] = pMemBlocks[i];
        -: 3537:                }
        4: 3538:            free(pMemBlocks);
        4: 3539:            pMemBlocks = npMemBlocks;
        -: 3540:            /** /
        -: 3541:            showMemBlocks();
        -: 3542:            / **/
        4: 3543:            return mb;
        -: 3544:            }
       35: 3545:        npMemBlocks[j++] = pMemBlocks[i];
        -: 3546:        }
        1: 3547:    npMemBlocks[j] = mb;
        1: 3548:    free(pMemBlocks);
        1: 3549:    pMemBlocks = npMemBlocks;
        -: 3550:    /** /
        -: 3551:    showMemBlocks();
        -: 3552:    / **/
        1: 3553:    return mb;
        -: 3554:    }
        -: 3555:
        -: 3556:
  2393360: 3557:static void * bmalloc(int lineno,size_t n)
        -: 3558:    {
        -: 3559:    void * ret;
        -: 3560:#if DOSUMCHECK
        -: 3561:    size_t nn = n;
        -: 3562:#endif
        -: 3563:#if TELLING
        -: 3564:    int tel;
        -: 3565:    alloc_cnt++;
        -: 3566:    if(n < 256)
        -: 3567:        cnts[n]++;
        -: 3568:    totcnt += n;
        -: 3569:#endif
        -: 3570:#if TELMAX
  2393360: 3571:    globalloc++;
  2393360: 3572:    if(maxgloballoc < globalloc)
   232484: 3573:        maxgloballoc = globalloc;
        -: 3574:#endif
        -: 3575:#if CHECKALLOCBOUNDS
        -: 3576:    n += 3 * sizeof(LONG);
        -: 3577:#endif
        -: 3578:    checksum(__LINE__);
  2393360: 3579:    n = (n - 1) / sizeof(struct pointerStruct);
  2393360: 3580:    if  (n <
        -: 3581:#if _5_6
        -: 3582:             6
        -: 3583:#elif _4
        -: 3584:             4
        -: 3585:#else
        -: 3586:             3
        -: 3587:#endif
        -: 3588:        )
        -: 3589:        {
  2263021: 3590:        struct memblock * mb = allocations[n].memoryBlock;
  2263021: 3591:        ret = mb->firstFreeElementBetweenAddresses;
  4526050: 3592:        while(ret == 0)
        -: 3593:            {
        8: 3594:            mb = mb->previousOfSameLength;
        8: 3595:            if(!mb)
        5: 3596:                mb = newMemBlocks(n);
        8: 3597:            if(!mb)
    #####: 3598:                break; /* 20120702 */
        8: 3599:            ret = mb->firstFreeElementBetweenAddresses;
        -: 3600:            }
  2263021: 3601:        if(ret != 0)
        -: 3602:            {
        -: 3603:#if TELMAX
  2263021: 3604:            --(mb->numberOfFreeElementsBetweenAddresses);
  2263021: 3605:            if(mb->numberOfFreeElementsBetweenAddresses < mb->minimumNumberOfFreeElementsBetweenAddresses)
   104770: 3606:                mb->minimumNumberOfFreeElementsBetweenAddresses = mb->numberOfFreeElementsBetweenAddresses;
        -: 3607:#endif
  2263021: 3608:            mb->firstFreeElementBetweenAddresses = ((struct memoryElement *)mb->firstFreeElementBetweenAddresses)->next;
        -: 3609:            /** /
        -: 3610:            memset(ret,0,(n+1) * sizeof(struct pointerStruct));
        -: 3611:            / **/
  2263021: 3612:            ((LONG*)ret)[n] = 0;
  2263021: 3613:            ((LONG*)ret)[0] = 0;
        -: 3614:            setChecksum(lineno,nn);
        -: 3615:#if CHECKALLOCBOUNDS
        -: 3616:            ((LONG*)ret)[n-1] = 0;
        -: 3617:            ((LONG*)ret)[2] = 0;
        -: 3618:            ((LONG*)ret)[1] = n;
        -: 3619:            ((LONG*)ret)[n] = ('t'<<24)+('e'<<16)+('n'<<8)+('d');
        -: 3620:            ((LONG*)ret)[0] = ('s'<<24)+('t'<<16)+('a'<<8)+('r');
        -: 3621:               /* {
        -: 3622:                FILE * f = fopen("bmalloc","a");
        -: 3623:                fprintf(f,"line %d: %p %d\n",lineno,ret,n);
        -: 3624:                fclose(f);
        -: 3625:                }*/
        -: 3626:            return (void *)(((LONG*)ret) + 2);
        -: 3627:#else
  2263021: 3628:            return ret;
        -: 3629:#endif
        -: 3630:            }
        -: 3631:        }
   130339: 3632:    ret = malloc((n+1) * sizeof(struct pointerStruct));
   130339: 3633:    if(!ret)
        -: 3634:        {
        -: 3635:#if TELLING
        -: 3636:        errorprintf(
        -: 3637:        "MEMORY FULL AFTER %lu ALLOCATIONS WITH MEAN LENGTH %lu\n",
        -: 3638:            globalloc,totcnt/alloc_cnt);
        -: 3639:        for(tel = 0;tel<16;tel++)
        -: 3640:            {
        -: 3641:            int tel1;
        -: 3642:            for(tel1 = 0;tel1<256;tel1 += 16)
        -: 3643:                errorprintf("%lu ",(cnts[tel+tel1]*1000UL+500UL)/alloc_cnt);
        -: 3644:            errorprintf("\n");
        -: 3645:            }
        -: 3646:        bezetting();
        -: 3647:#endif
    #####: 3648:        errorprintf(
        -: 3649:            "memory full (requested block of %d bytes could not be allocated)",
    #####: 3650:            (n<<2)+4);
        -: 3651:
    #####: 3652:        exit(1);
        -: 3653:        }
        -: 3654:
        -: 3655:#if TELMAX
   130339: 3656:    ++malloced;
        -: 3657:#endif
   130339: 3658:    ((LONG*)ret)[n] = 0;
   130339: 3659:    ((LONG*)ret)[0] = 0;
        -: 3660:    setChecksum(lineno,n);
        -: 3661:#if CHECKALLOCBOUNDS
        -: 3662:    ((LONG*)ret)[n-1] = 0;
        -: 3663:    ((LONG*)ret)[2] = 0;
        -: 3664:    ((LONG*)ret)[1] = n;
        -: 3665:    ((LONG*)ret)[n] = ('t'<<24)+('e'<<16)+('n'<<8)+('d');
        -: 3666:    ((LONG*)ret)[0] = ('s'<<24)+('t'<<16)+('a'<<8)+('r');
        -: 3667:                /*{
        -: 3668:                FILE * f = fopen("bmalloc","a");
        -: 3669:                fprintf(f,"line %d: %p %d\n",lineno,ret,n);
        -: 3670:                fclose(f);
        -: 3671:                }*/
        -: 3672:    return (void *)(((LONG*)ret) + 2);
        -: 3673:#else
   130339: 3674:    return ret;
        -: 3675:#endif
        -: 3676:    }
        -: 3677:
        6: 3678:int addAllocation(size_t size,int number,int nallocations,struct allocation * allocations)
        -: 3679:    {
        -: 3680:    int i;
       21: 3681:    for(i = 0;i < nallocations;++i)
        -: 3682:        {
       15: 3683:        if(allocations[i].elementSize == size)
        -: 3684:            {
    #####: 3685:            allocations[i].numberOfElements += number;
    #####: 3686:            return nallocations;
        -: 3687:            }
        -: 3688:        }
        6: 3689:    allocations[nallocations].elementSize = size;
        6: 3690:    allocations[nallocations].numberOfElements = number;
        6: 3691:    return nallocations + 1;
        -: 3692:    }
        -: 3693:
        9: 3694:int memblocksort(const void * a, const void * b)
        -: 3695:    {
        9: 3696:    struct memblock * A = *(struct memblock **)a;
        9: 3697:    struct memblock * B = *(struct memblock **)b;
        9: 3698:    if(A->lowestAddress < B->lowestAddress)
        6: 3699:        return -1;
        3: 3700:    return 1;
        -: 3701:    }
        -: 3702:
        1: 3703:static int init_ruimte(void)
        -: 3704:    {
        -: 3705:    int i;
        1: 3706:    allocations = (struct allocation *)malloc( sizeof(struct allocation)
        -: 3707:                        *
        -: 3708:#if _5_6
        -: 3709:                            6
        -: 3710:#elif _4
        -: 3711:                            4
        -: 3712:#else
        -: 3713:                            3
        -: 3714:#endif
        -: 3715:                        );
        1: 3716:    nallocations = addAllocation(1*sizeof(struct pointerStruct),MEM1SIZE,0,allocations);
        1: 3717:    nallocations = addAllocation(2*sizeof(struct pointerStruct),MEM2SIZE,nallocations,allocations);
        1: 3718:    nallocations = addAllocation(3*sizeof(struct pointerStruct),MEM3SIZE,nallocations,allocations);
        -: 3719:#if _4
        1: 3720:    nallocations = addAllocation(4*sizeof(struct pointerStruct),MEM4SIZE,nallocations,allocations);
        -: 3721:#endif
        -: 3722:#if _5_6
        1: 3723:    nallocations = addAllocation(5*sizeof(struct pointerStruct),MEM5SIZE,nallocations,allocations);
        1: 3724:    nallocations = addAllocation(6*sizeof(struct pointerStruct),MEM6SIZE,nallocations,allocations);
        -: 3725:#endif
        1: 3726:    NumberOfMemBlocks = nallocations;
        1: 3727:    pMemBlocks = (struct memblock **)malloc(NumberOfMemBlocks*sizeof(struct memblock *));
        -: 3728:
        7: 3729:    for(i = 0;i < NumberOfMemBlocks;++i)
        -: 3730:        {
        6: 3731:        pMemBlocks[i] = allocations[i].memoryBlock = initializeMemBlock(allocations[i].elementSize, allocations[i].numberOfElements);
        -: 3732:        }
        1: 3733:    qsort(pMemBlocks,NumberOfMemBlocks,sizeof(struct memblock *),memblocksort);
        -: 3734:    /*
        -: 3735:    for(i = 0;i < NumberOfMemBlocks;++i)
        -: 3736:        {
        -: 3737:        printf  ("%p %d %p %p %p %p %lu\n"
        -: 3738:                ,pMemBlocks[i]
        -: 3739:                ,i
        -: 3740:                ,pMemBlocks[i]->lowestAddress
        -: 3741:                ,pMemBlocks[i]->firstFreeElementBetweenAddresses
        -: 3742:                ,pMemBlocks[i]->highestAddress
        -: 3743:                ,pMemBlocks[i]->previousOfSameLength
        -: 3744:                ,pMemBlocks[i]->sizeOfElement
        -: 3745:                );
        -: 3746:        }
        -: 3747:    */
        1: 3748:    return 1;
        -: 3749:    }
        -: 3750:
  1585542: 3751:static void pskfree(psk p)
        -: 3752:    {
  1585542: 3753:    bfree(p);
  1585542: 3754:    }
        -: 3755:
        -: 3756:#if !defined NDEBUG
        -: 3757:static void result(psk wortel);
        -: 3758:#endif
        -: 3759:
   639247: 3760:static psk new_operator_like(psk kn)
        -: 3761:    {
   639247: 3762:    if(kop(kn) == WORDT)
        -: 3763:        {
        -: 3764:        DBGSRC(printf("new_operator_like:");result(kn);printf("\n");)
        -: 3765:        assert(!ISBUILTIN((objectknoop*)kn));
        -: 3766:/*        if(ISBUILTIN((objectknoop*)kn))
        -: 3767:            {
        -: 3768:            typedObjectknoop * goal = (typedObjectknoop *)bmalloc(__LINE__,sizeof(typedObjectknoop));
        -: 3769:#ifdef BUILTIN
        -: 3770:            goal->u.Int = BUILTIN;
        -: 3771:#else
        -: 3772:            goal->refcount = 0;
        -: 3773:            UNSETCREATEDWITHNEW(goal);
        -: 3774:            SETBUILTIN(goal);
        -: 3775:#endif
        -: 3776:            goal->vtab = ((typedObjectknoop*)kn)->vtab;
        -: 3777:            goal->voiddata = NULL;
        -: 3778:            return (psk)goal;
        -: 3779:            }
        -: 3780:        else*/
        -: 3781:            {
     8283: 3782:            objectknoop * goal = (objectknoop *)bmalloc(__LINE__,sizeof(objectknoop));
        -: 3783:#ifdef BUILTIN
     8283: 3784:            goal->u.Int = 0;
        -: 3785:#else
        -: 3786:            goal->refcount = 0;
        -: 3787:            UNSETCREATEDWITHNEW(goal);
        -: 3788:            UNSETBUILTIN(goal);
        -: 3789:#endif
     8283: 3790:            return (psk)goal;
        -: 3791:            }
        -: 3792:        }
        -: 3793:    else
   630964: 3794:        return (psk)bmalloc(__LINE__,sizeof(kknoop));
        -: 3795:    }
        -: 3796:
     1581: 3797:static unsigned char *shift_nw(void)
        -: 3798:/* Used from startboom_w and opb */
        -: 3799:    {
     1581: 3800:    if(startPos)
        -: 3801:        {
     1382: 3802:        startPos = va_arg(ap,unsigned char *);
     1382: 3803:        if(startPos)
       11: 3804:                start = startPos;
        -: 3805:        }
     1581: 3806:    return start;
        -: 3807:    }
        -: 3808:
        1: 3809:static void combineInputBuffers(void)
        -: 3810:/*
        -: 3811:Only to be called if the current input buffer is too small to contain
        -: 3812:a complete string (atom) and the content continues in one or more of
        -: 3813:the next buffers. These buffers are combined into one big buffer.
        -: 3814:*/
        -: 3815:    {
        1: 3816:    inputBuffer * nextInputElement = InputElement + 1;
        -: 3817:    inputBuffer * next2;
        -: 3818:    unsigned char * bigBuffer;
        -: 3819:    size_t len;
       15: 3820:    while(nextInputElement->cutoff)
       13: 3821:        ++nextInputElement;
        -: 3822:
        1: 3823:    len = (nextInputElement - InputElement) * (DEFAULT_INPUT_BUFFER_SIZE - 1) + 1;
        -: 3824:
        1: 3825:    if(nextInputElement->buffer)
        -: 3826:        {
        1: 3827:        len += strlen((const char *)nextInputElement->buffer);
        -: 3828:        }
        -: 3829:
        1: 3830:    bigBuffer = (unsigned char *)bmalloc(__LINE__,len);
        -: 3831:
        1: 3832:    nextInputElement = InputElement;
        -: 3833:
       16: 3834:    while(nextInputElement->cutoff)
        -: 3835:        {
       14: 3836:        strncpy((char *)bigBuffer + (nextInputElement - InputElement)*(DEFAULT_INPUT_BUFFER_SIZE - 1),(char *)nextInputElement->buffer,DEFAULT_INPUT_BUFFER_SIZE - 1);
       14: 3837:        bfree(nextInputElement->buffer);
       14: 3838:        ++nextInputElement;
        -: 3839:        }
        -: 3840:
        1: 3841:    if(nextInputElement->buffer)
        -: 3842:        {
        1: 3843:        strcpy((char *)bigBuffer + (nextInputElement - InputElement)*(DEFAULT_INPUT_BUFFER_SIZE - 1),(char *)nextInputElement->buffer);
        1: 3844:        if(nextInputElement->mallocallocated)
        -: 3845:            {
    #####: 3846:            bfree(nextInputElement->buffer);
        -: 3847:            }
        1: 3848:        ++nextInputElement;
        -: 3849:        }
        -: 3850:    else
    #####: 3851:        bigBuffer[(nextInputElement - InputElement)*(DEFAULT_INPUT_BUFFER_SIZE - 1)] = '\0';
        -: 3852:
        1: 3853:    InputElement->buffer = bigBuffer;
        1: 3854:    InputElement->cutoff = FALSE;
        1: 3855:    InputElement->mallocallocated = TRUE;
        -: 3856:
        1: 3857:    for(next2 = InputElement + 1;nextInputElement->buffer;++next2,++nextInputElement)
        -: 3858:        {
    #####: 3859:        next2->buffer = nextInputElement->buffer;
    #####: 3860:        next2->cutoff = nextInputElement->cutoff;
    #####: 3861:        next2->mallocallocated = nextInputElement->mallocallocated;
        -: 3862:        }
        -: 3863:
        1: 3864:    next2->buffer = NULL;
        1: 3865:    next2->cutoff = FALSE;
        1: 3866:    next2->mallocallocated = FALSE;
        1: 3867:    }
        -: 3868:
       38: 3869:static unsigned char * vshift_w(void)
        -: 3870:/* used from bouwboom_w, which receives a list of bmalloc-allocated string
        -: 3871:   pointers. The last string pointer must not be deallocated here */
        -: 3872:    {
       38: 3873:    if(InputElement->buffer && (++InputElement)->buffer)
        -: 3874:        {
        2: 3875:        if(InputElement->cutoff)
        -: 3876:            {
    #####: 3877:            combineInputBuffers();
        -: 3878:            }
        -: 3879:	assert(InputElement[-1].mallocallocated);
        2: 3880:        bfree(InputElement[-1].buffer);
        2: 3881:        InputElement[-1].mallocallocated = FALSE;
        2: 3882:        start = InputElement->buffer;
        -: 3883:        }
       38: 3884:    return start;
        -: 3885:    }
        -: 3886:
   186776: 3887:static unsigned char *vshift_nw(void)
        -: 3888:/* Used from vopb */
        -: 3889:    {
   186776: 3890:    if(*pstart && *++pstart)
     2039: 3891:        start = *pstart;
   186776: 3892:    return start;
        -: 3893:    }
        -: 3894:
        -: 3895:static unsigned char *(*shift)(void) = shift_nw;
        -: 3896:
      138: 3897:static void tel(int c)
        -: 3898:    {
        -: 3899:    UNREFERENCED_PARAMETER(c);
      138: 3900:    telling++;
      138: 3901:    }
        -: 3902:
   611241: 3903:static void tstr(int c)
        -: 3904:    {
        -: 3905:    static int esc = FALSE,str = FALSE;
   611241: 3906:    if(esc)
        -: 3907:        {
       22: 3908:        esc = FALSE;
       22: 3909:        telling++;
        -: 3910:        }
   611219: 3911:    else if(c == '\\')
       22: 3912:        esc = TRUE;
   611197: 3913:    else if(str)
        -: 3914:        {
     2214: 3915:        if(c == '"')
      356: 3916:            str = FALSE;
        -: 3917:        else
     1858: 3918:            telling++;
        -: 3919:        }
   608983: 3920:    else if(c == '"')
      356: 3921:        str = TRUE;
   608627: 3922:    else if(c != ' ')
   503883: 3923:        telling++;
   611241: 3924:    }
        -: 3925:
   611241: 3926:static void pstr(int c)
        -: 3927:    {
        -: 3928:    static int esc = FALSE,str = FALSE;
   611241: 3929:    if(esc)
        -: 3930:        {
       22: 3931:        esc = FALSE;
       22: 3932:        switch(c)
        -: 3933:            {
        -: 3934:            case 'n' :
        6: 3935:                c = '\n';
        6: 3936:                break;
        -: 3937:            case 'f' :
        1: 3938:                c = '\f';
        1: 3939:                break;
        -: 3940:            case 'r' :
        7: 3941:                c = '\r';
        7: 3942:                break;
        -: 3943:            case 'b' :
        1: 3944:                c = '\b';
        1: 3945:                break;
        -: 3946:            case 'a' :
        1: 3947:                c = ALERT;
        1: 3948:                break;
        -: 3949:            case 'v' :
        1: 3950:                c = '\v';
        1: 3951:                break;
        -: 3952:            case 't' :
        3: 3953:                c = '\t';
        3: 3954:                break;
        -: 3955:            case 'L' :
        1: 3956:                c = 016;
        1: 3957:                break;
        -: 3958:            case 'D' :
        1: 3959:                c = 017;
        1: 3960:                break;
        -: 3961:            }
       22: 3962:        *bron++ = (char)c;
        -: 3963:        }
   611219: 3964:    else if(c == '\\')
       22: 3965:        esc = TRUE;
   611197: 3966:    else if(str)
        -: 3967:        {
     2214: 3968:        if(c == '"')
      356: 3969:            str = FALSE;
        -: 3970:        else
     1858: 3971:            *bron++ = (char)c;
        -: 3972:        }
   608983: 3973:    else if(c == '"')
      356: 3974:        str = TRUE;
   608627: 3975:    else if(c != ' ')
   503883: 3976:        *bron++ = (char)c;
   611241: 3977:    }
        -: 3978:
      138: 3979:static void plak(int c)
        -: 3980:    {
      138: 3981:    *bron++ = (char)c;
      138: 3982:    }
        -: 3983:
        -: 3984:#define COMPLEX_MAX 80
        -: 3985:#define LINELENGTH 80
        -: 3986:
    91770: 3987:static /*int 20031126*/size_t complexiteit(psk wortel,/*int 20031126*/size_t max)
        -: 3988:    {
        -: 3989:    /*int left,right;*/
        -: 3990:    static int ouder,kind;
   253074: 3991:    while(is_op(wortel))
        -: 3992:        {
    76427: 3993:        switch(kop(wortel))
        -: 3994:            {
        -: 3995:            case OF :
        -: 3996:            case EN :
     9420: 3997:                max += COMPLEX_MAX/5;
     9420: 3998:                break;
        -: 3999:            case WORDT :
        -: 4000:            case MATCH :
    12892: 4001:                max += COMPLEX_MAX/10;
    12892: 4002:                break;
        -: 4003:            case DOT :
        -: 4004:            case KOMMA :
        -: 4005:            case LUCHT :
    22399: 4006:                switch(kop(wortel->LEFT))
        -: 4007:                    {
        -: 4008:                    case DOT:
        -: 4009:                    case KOMMA:
        -: 4010:                    case LUCHT :
      653: 4011:                        max += COMPLEX_MAX/10;
      653: 4012:                        break;
        -: 4013:                    default:
    21746: 4014:                        max += COMPLEX_MAX/LINELENGTH;
        -: 4015:                    }
    22399: 4016:                break;
        -: 4017:                /*
        -: 4018:                case PLUS:
        -: 4019:                max += COMPLEX_MAX/25;
        -: 4020:                break;
        -: 4021:                case MAAL:
        -: 4022:                max += COMPLEX_MAX/40;
        -: 4023:                break;
        -: 4024:                */
        -: 4025:            default:
    31716: 4026:                max += COMPLEX_MAX/LINELENGTH;
        -: 4027:            }
    76427: 4028:        ouder = kop(wortel);
    76427: 4029:        kind = kop(wortel->LEFT);
    76427: 4030:        if(HAS__UNOPS(wortel->LEFT) || ouder >= kind)
    61256: 4031:            max += (2 * COMPLEX_MAX)/LINELENGTH; /* 2 parentheses */
        -: 4032:
    76427: 4033:        kind = kop(wortel->RIGHT);
    76427: 4034:        if(HAS__UNOPS(wortel->RIGHT) || ouder > kind || (ouder == kind && ouder > MAAL))
    43804: 4035:            max += (2 * COMPLEX_MAX)/LINELENGTH; /* 2 parentheses */
        -: 4036:
    76427: 4037:        if(max > COMPLEX_MAX)
     6893: 4038:            return max;
        -: 4039:            /*
        -: 4040:            left = complexiteit(wortel->LEFT,max);
        -: 4041:            right = complexiteit(wortel->RIGHT,max);
        -: 4042:
        -: 4043:             if(left > right)
        -: 4044:             max = left;
        -: 4045:             else
        -: 4046:             max = right;
        -: 4047:        */
    69534: 4048:        max = complexiteit(wortel->LEFT,max);
    69534: 4049:        wortel = wortel->RIGHT;
        -: 4050:        }
    84877: 4051:    if(!is_op(wortel))
    84877: 4052:        max += (COMPLEX_MAX*strlen((char *)POBJ(wortel))) / LINELENGTH;
    84877: 4053:    return max;
        -: 4054:    }
        -: 4055:
        -: 4056:static int indtel = 0,extraspatie = 0,number_of_flags_on_node=0;
        -: 4057:
   453173: 4058:static int indent(psk wortel,int nivo,int ind)
        -: 4059:    {
   453173: 4060:    if(hum)
        -: 4061:        {
    29801: 4062:        if(ind > 0 || (ind == 0 && complexiteit(wortel,2*nivo) > COMPLEX_MAX))
     4590: 4063:            {  /*    blanks that start a line    */
        -: 4064:            int p;
     4590: 4065:            (*verwerk)('\n');
    62739: 4066:            for(p = 2*nivo+number_of_flags_on_node;p;p--)
    58149: 4067:                (*verwerk)(' ');
     4590: 4068:            ind = TRUE;
        -: 4069:            }
        -: 4070:        else
        -: 4071:            {  /* blanks after an operator or parenthesis */
    31355: 4072:            for(indtel = extraspatie + 2*indtel;indtel;indtel--)
     6144: 4073:                (*verwerk)(' ');
    25211: 4074:            ind = FALSE;
        -: 4075:            }
    29801: 4076:        extraspatie = 0;
        -: 4077:        }
   453173: 4078:    return ind;
        -: 4079:    }
        -: 4080:
   221337: 4081:static int moetIndent(psk wortel,int ind,int nivo)
        -: 4082:    {
   221337: 4083:    return hum && !ind && complexiteit(wortel,2*nivo) > COMPLEX_MAX;
        -: 4084:    }
        -: 4085:
   712105: 4086:static void bewerk(int c)
        -: 4087:    {
   712105: 4088:    if(c == 016 || c == 017)
        -: 4089:        {
       68: 4090:        (*verwerk)('\\');
       68: 4091:        (*verwerk)(c == 016 ? 'L' : 'D');
        -: 4092:        }
        -: 4093:    else
   712037: 4094:        (*verwerk)(c);
   712105: 4095:    }
        -: 4096:
      113: 4097:static int lineToLong(unsigned char *string)
        -: 4098:    {
      113: 4099:    if(  hum
       71: 4100:      && strlen((const char *)string) > 10 /*LINELENGTH*/
        -: 4101:      /* very short strings are allowed to keep \n and \t */
        -: 4102:      )
       22: 4103:        return TRUE;
       91: 4104:    return FALSE;
        -: 4105:    }
        -: 4106:
   225703: 4107:static int haalaan(unsigned char *string)
        -: 4108:    {
        -: 4109:    unsigned char *pstring;
   225703: 4110:    if(quote[*string] & 1)
      871: 4111:        return TRUE;
  1257417: 4112:    for(pstring = string;*pstring;pstring++)
  1032892: 4113:        if(quote[*pstring] & 2)
      302: 4114:            return TRUE;
  1032590: 4115:        else if(  quote[*pstring] & 4
       45: 4116:            && lineToLong(string)
        -: 4117:            )
        5: 4118:            return TRUE;
   224525: 4119:    return FALSE;
        -: 4120:    }
        -: 4121:
   228952: 4122:static int printflags(psk wortel)
        -: 4123:    {
   228952: 4124:    int count = 0;
   228952: 4125:    int Flgs = wortel->v.fl;
   228952: 4126:    if(Flgs & POSITION)
        -: 4127:        {
       82: 4128:        (*verwerk)('[');
       82: 4129:        ++count;
        -: 4130:        }
   228952: 4131:    if(Flgs & NOT)
        -: 4132:        {
      162: 4133:        (*verwerk)('~');
      162: 4134:        ++count;
        -: 4135:        }
   228952: 4136:    if(Flgs & BREUK)
        -: 4137:        {
       32: 4138:        (*verwerk)('/');
       32: 4139:        ++count;
        -: 4140:        }
   228952: 4141:    if(Flgs & NUMBER)
        -: 4142:        {
       82: 4143:        (*verwerk)('#');
       82: 4144:        ++count;
        -: 4145:        }
   228952: 4146:    if(Flgs & SMALLER_THAN)
        -: 4147:        {
      107: 4148:        (*verwerk)('<');
      107: 4149:        ++count;
        -: 4150:        }
   228952: 4151:    if(Flgs & GREATER_THAN)
        -: 4152:        {
      112: 4153:        (*verwerk)('>');
      112: 4154:        ++count;
        -: 4155:        }
   228952: 4156:    if(Flgs & NONIDENT)
        -: 4157:        {
      119: 4158:        (*verwerk)('%');
      119: 4159:        ++count;
        -: 4160:        }
   228952: 4161:    if(Flgs & ATOM)
        -: 4162:        {
      329: 4163:        (*verwerk)('@');
      329: 4164:        ++count;
        -: 4165:        }
   228952: 4166:    if(Flgs & UNIFY)
        -: 4167:        {
     1249: 4168:        (*verwerk)('?');
     1249: 4169:        ++count;
        -: 4170:        }
   228952: 4171:    if(Flgs & FENCE)
        -: 4172:        {
        -: 4173:        /* 20111216
        -: 4174:        if(!(Flgs & POSITION))
        -: 4175:            {*/
       45: 4176:            (*verwerk)('`'); /*20111221 this was also commented out*/
       45: 4177:            ++count;
        -: 4178:            /*}
        -: 4179:        */
        -: 4180:        }
   228952: 4181:    if(Flgs & INDIRECT)
        -: 4182:        {
     1195: 4183:        (*verwerk)('!');
     1195: 4184:        ++count;
        -: 4185:        }
   228952: 4186:    if(Flgs & DOUBLY_INDIRECT)
        -: 4187:        {
       10: 4188:        (*verwerk)('!');
       10: 4189:        ++count;
        -: 4190:        }
   228952: 4191:    return count;
        -: 4192:    }
        -: 4193:
        -: 4194:#define LHS 1
        -: 4195:#define RHS 2
        -: 4196:
   226112: 4197:static void eindknoop(psk wortel,int space)
        -: 4198:    {
        -: 4199:    unsigned char *pstring;
        -: 4200:    int q,ikar;
        -: 4201:#if CHECKALLOCBOUNDS
        -: 4202:    if(POINT)
        -: 4203:        printf("\n[%p %d]",wortel,(wortel->ops & ALL_REFCOUNT_BITS_SET)/ ONE);
        -: 4204:#endif
   226112: 4205:    if(!wortel->u.obj
     1261: 4206:        && !HAS_UNOPS(wortel)
      896: 4207:        && space)
        -: 4208:        {
       22: 4209:        (*verwerk)('(');
       22: 4210:        (*verwerk)(')');
   226134: 4211:        return;
        -: 4212:        }
   226090: 4213:    printflags(wortel);
   226090: 4214:    if(wortel->ops & MINUS)
      297: 4215:        (*verwerk)('-');
   226090: 4216:    if(mooi)
        -: 4217:        {
   491173: 4218:        for(pstring = POBJ(wortel);*pstring;pstring++)
   490768: 4219:            bewerk(*pstring);
        -: 4220:        }
        -: 4221:    else
        -: 4222:        {
   225685: 4223:        Boolean longline = FALSE;
   225685: 4224:        if((q = haalaan(POBJ(wortel))) == TRUE)
     1178: 4225:            (*verwerk)('"');
        -: 4226:            /*
        -: 4227:            if(hum) / * 20001129 * /
        -: 4228:            for(pstring = POBJ(wortel);*pstring;pstring++)
        -: 4229:            bewerk(*pstring);
        -: 4230:            else
        -: 4231:            20010103 File saved this way can not be re-read if string contains doublequote \"
        -: 4232:        */
  1274056: 4233:        for(pstring = POBJ(wortel);(ikar = *pstring) != 0;pstring++)
        -: 4234:            {
  1048371: 4235:            switch(ikar)
        -: 4236:                {
        -: 4237:                case '\n' :
       85: 4238:                    if(longline || lineToLong(POBJ(wortel)))
        -: 4239:                    /* We need to call this, even though haalaan returned TRUE,
        -: 4240:                    because haalaan may have returned before reaching this character.
        -: 4241:                    */
        -: 4242:                        {
       53: 4243:                        longline = TRUE;
       53: 4244:                        (*verwerk)('\n');
       53: 4245:                        continue;
        -: 4246:                        }
       32: 4247:                    ikar = 'n';
       32: 4248:                    break;
        -: 4249:                case '\f' :
        4: 4250:                    ikar = 'f';
        4: 4251:                    break;
        -: 4252:                case '\r' :
      131: 4253:                    ikar = 'r';
      131: 4254:                    break;
        -: 4255:                case '\b' :
        4: 4256:                    ikar = 'b';
        4: 4257:                    break;
        -: 4258:                case ALERT :
        4: 4259:                    ikar = 'a';
        4: 4260:                    break;
        -: 4261:                case '\v' :
        4: 4262:                    ikar = 'v';
        4: 4263:                    break;
        -: 4264:                case '\t' :
       69: 4265:                    if(longline || lineToLong(POBJ(wortel)))
        -: 4266:                    /* We need to call this, even though haalaan returned TRUE,
        -: 4267:                    because haalaan may have returned before reaching this character.
        -: 4268:                    */
        -: 4269:                        {
       50: 4270:                        longline = TRUE;
       50: 4271:                        (*verwerk)('\t');
       50: 4272:                        continue;
        -: 4273:                        }
       19: 4274:                    ikar = 't';
       19: 4275:                    break;
        -: 4276:                case '"' :
        -: 4277:                case '\\' :
       39: 4278:                    break;
        -: 4279:                case 016 :
        2: 4280:                    ikar = 'L';
        2: 4281:                    break;
        -: 4282:                case 017 :
        2: 4283:                    ikar = 'D';
        2: 4284:                    break;
        -: 4285:                default :
  1048027: 4286:                    (*verwerk)(ikar);
  1048027: 4287:                    continue;
        -: 4288:                }
      241: 4289:            (*verwerk)('\\');
      241: 4290:            (*verwerk)(ikar);
        -: 4291:            }
   225685: 4292:        if(q)
     1178: 4293:            (*verwerk)('"');
        -: 4294:        }
        -: 4295:    }
        -: 4296:
  4496203: 4297:static psk zelfde_als_w(psk kn)
        -: 4298:    {
  4496203: 4299:    if(shared(kn) != ALL_REFCOUNT_BITS_SET)
        -: 4300:        {
  4493144: 4301:        (kn)->ops += ONE;
  4493144: 4302:        return kn;
        -: 4303:        }
     3059: 4304:    else if(is_object(kn))
        -: 4305:        {
    #####: 4306:        INCREFCOUNT(kn);
    #####: 4307:        return kn;
        -: 4308:        }
        -: 4309:    else
        -: 4310:        {
     3059: 4311:        return subboomcopie(kn);
        -: 4312:        }
        -: 4313:    }
        -: 4314:
   627140: 4315:static psk zelfde_als_w_2(ppsk pkn)
        -: 4316:    {
   627140: 4317:    psk kn = *pkn;
   627140: 4318:    if(shared(kn) != ALL_REFCOUNT_BITS_SET)
        -: 4319:        {
   627139: 4320:        kn->ops += ONE;
   627139: 4321:        return kn;
        -: 4322:        }
        1: 4323:    else if(is_object(kn))
        -: 4324:        {
    #####: 4325:        INCREFCOUNT(kn);
    #####: 4326:        return kn;
        -: 4327:        }
        -: 4328:    else
        -: 4329:        {
        -: 4330:        /* 20100425
        -: 4331:        0:?n&:?L&whl'(!n+1:?n:<10000&out$!n&XXX !L:?L)
        -: 4332:        0:?n&:?L&whl'(!n+1:?n:<10000&out$!n&!L XXX:?L) This is not improved!
        -: 4333:        */
        1: 4334:        *pkn = subboomcopie(kn);
        1: 4335:        return kn;
        -: 4336:        }
        -: 4337:    }
        -: 4338:
        -: 4339:#if ICPY
        -: 4340:static void icpy(LONG *d,LONG *b,int words)
        -: 4341:    {
        -: 4342:    while(words--)
        -: 4343:        *d++ = *b++;
        -: 4344:    }
        -: 4345:#endif
        -: 4346:
   258476: 4347:static psk icopievan(psk kn)
        -: 4348:    {
        -: 4349:    /* EISEN : Na de afsluitende 0 van string moeten eventuele resterende bytes
        -: 4350:    van het betreffende computerwoord ook 0 zijn.
        -: 4351:    Beide argumenten moeten op een woordgrens beginnen. */
        -: 4352:    psk ret;
        -: 4353:    size_t len;
   258476: 4354:    len = sizeof(unsigned LONG)+strlen((char *)POBJ(kn));
   258476: 4355:    ret = (psk)bmalloc(__LINE__,len+1);
        -: 4356:#if ICPY
        -: 4357:    MEMCPY(ret,kn,(len >> LOGWORDLENGTH) + 1);
        -: 4358:#else
   258476: 4359:    MEMCPY(ret,kn,((len / sizeof(LONG)) + 1) * sizeof(LONG));
        -: 4360:#endif
   258476: 4361:    ret->ops &= ~ALL_REFCOUNT_BITS_SET;
   258476: 4362:    return ret;
        -: 4363:    }
        -: 4364:
        -: 4365:static void wis(psk top);
        -: 4366:
     4186: 4367:static void copyToSnijaf(psk * ppknoop,psk pknoop,psk snijaf)
        -: 4368:    {
        -: 4369:    for(;;)
        -: 4370:        {
     4186: 4371:        if(is_op(pknoop))
        -: 4372:            {
     4186: 4373:            if(pknoop->RIGHT == snijaf)
        -: 4374:                {
     1691: 4375:                *ppknoop = zelfde_als_w(pknoop->LEFT);
     1691: 4376:                break;
        -: 4377:                }
        -: 4378:            else
        -: 4379:                {
     2495: 4380:                psk p = new_operator_like(pknoop);
     2495: 4381:                p->ops = pknoop->ops & ~ALL_REFCOUNT_BITS_SET;
     2495: 4382:                p->LEFT = zelfde_als_w(pknoop->LEFT);
     2495: 4383:                *ppknoop = p;
     2495: 4384:                ppknoop = &(p->RIGHT);
     2495: 4385:                pknoop = pknoop->RIGHT;
        -: 4386:                }
        -: 4387:            }
        -: 4388:        else
        -: 4389:            {
    #####: 4390:            *ppknoop = icopievan(pknoop);
    #####: 4391:            break;
        -: 4392:            }
     2495: 4393:        }
     1691: 4394:    }
        -: 4395:
   951049: 4396:static psk Head(psk pknoop)
        -: 4397:{
   951049: 4398:if(pknoop->ops & LATEBIND)
        -: 4399:    {
        -: 4400:    assert(!shared(pknoop));
     1350: 4401:    if(is_op(pknoop))
        -: 4402:        {
      557: 4403:        psk root = pknoop;
      557: 4404:        copyToSnijaf(&pknoop,root->LEFT,root->RIGHT);
      557: 4405:        wis(root);
        -: 4406:        }
        -: 4407:    else
        -: 4408:        {
      793: 4409:        stringrefknoop * ps = (stringrefknoop *)pknoop;
      793: 4410:        pknoop = (psk)bmalloc(__LINE__,sizeof(unsigned LONG) + 1 + ps->length);
      793: 4411:        pknoop->ops = (ps->ops & ~ALL_REFCOUNT_BITS_SET & ~LATEBIND);
      793: 4412:        strncpy((char *)(pknoop)+sizeof(unsigned LONG),(char *)ps->str,ps->length); /* Bart 20040827 strcpy -> strncpy */
      793: 4413:        wis(ps->kn);
      793: 4414:        bfree(ps);
        -: 4415:        }
        -: 4416:    }
   951049: 4417:return pknoop;
        -: 4418:}
        -: 4419:
        -: 4420:#define RSP (ouder == LUCHT ? RHS : 0)
        -: 4421:#define LSP (ouder == LUCHT ? LHS : 0)
        -: 4422:
        -: 4423:#ifndef reslt
    11675: 4424:static void reslt(psk wortel,int nivo,int ind,int space)
        -: 4425:{
        -: 4426:static int ouder,kind,/* 18 Maart 1997:*/newind;
   230844: 4427:while(is_op(wortel))/* 18 Maart 1997: */
        -: 4428:    {
   218475: 4429:    if(kop(wortel) == WORDT)
       15: 4430:        wortel->RIGHT = Head(wortel->RIGHT);
   218475: 4431:    ouder = kop(wortel);
   218475: 4432:    kind = kop(wortel->LEFT);
   218475: 4433:    if(moetIndent(wortel,ind,nivo))
      777: 4434:        indtel++;
   218475: 4435:    if(HAS__UNOPS(wortel->LEFT) || ouder >= kind)
   216326: 4436:        hreslt(wortel->LEFT,nivo+1,FALSE,(space & LHS) | RSP);
        -: 4437:    else
     2149: 4438:        reslt(wortel->LEFT,nivo+1,FALSE,(space & LHS) | RSP);
   218475: 4439:    newind = indent(wortel,nivo,ind);
   218475: 4440:    if(newind)
     2932: 4441:        extraspatie = 1;
        -: 4442:#if CHECKALLOCBOUNDS
        -: 4443:    if(POINT)
        -: 4444:        printf("\n[%p %d]",wortel,(wortel->ops & ALL_REFCOUNT_BITS_SET)/ ONE);
        -: 4445:#endif
   218475: 4446:    bewerk(opchar[klopcode(wortel)]);
   218475: 4447:    ouder = kop(wortel);
   218475: 4448:    kind = kop(wortel->RIGHT);
   218475: 4449:    if(HAS__UNOPS(wortel->RIGHT) || ouder > kind || (ouder == kind && ouder > MAAL))
        -: 4450:        {
     9014: 4451:        hreslt(wortel->RIGHT,nivo+1,FALSE,LSP | (space & RHS));
     9014: 4452:        return;
        -: 4453:        }
   209461: 4454:    else if(ouder < kind)
        -: 4455:        {
     1120: 4456:        reslt(wortel->RIGHT,nivo+1,FALSE,LSP | (space & RHS));
     1120: 4457:        return;
        -: 4458:        }
   208341: 4459:    else if(newind != ind || ((LSP | (space & RHS)) != space))
        -: 4460:        {
      847: 4461:        reslt(wortel->RIGHT,nivo,newind,LSP | (space & RHS));
      847: 4462:        return;
        -: 4463:        }
   207494: 4464:    wortel = wortel->RIGHT;
        -: 4465:    }
      694: 4466:indent(wortel,nivo,-1);
      694: 4467:eindknoop(wortel,space);
        -: 4468:}
        -: 4469:
        -: 4470:#if DEBUGBRACMAT
        -: 4471:
        -: 4472:static void reslts(psk wortel,int nivo,int ind,int space,psk snijaf)
        -: 4473:    {
        -: 4474:    static int ouder,kind,/* 18 Maart 1997:*/newind;
        -: 4475:    if(is_op(wortel))/* 11 May 2004: */
        -: 4476:        {
        -: 4477:        if(kop(wortel) == WORDT)
        -: 4478:            wortel->RIGHT = Head(wortel->RIGHT);
        -: 4479:
        -: 4480:        do
        -: 4481:            {
        -: 4482:            if(snijaf && wortel->RIGHT == snijaf)
        -: 4483:                {
        -: 4484:                reslt(wortel->LEFT,nivo,ind,space);
        -: 4485:                return;
        -: 4486:                }
        -: 4487:            ouder = kop(wortel);
        -: 4488:             kind = kop(wortel->LEFT);
        -: 4489:            if(moetIndent(wortel,ind,nivo))
        -: 4490:                indtel++;
        -: 4491:            if(HAS__UNOPS(wortel->LEFT) || ouder >= kind)
        -: 4492:                hreslt(wortel->LEFT,nivo+1,FALSE,(space & LHS) | RSP);
        -: 4493:            else
        -: 4494:                reslt(wortel->LEFT,nivo+1,FALSE,(space & LHS) | RSP);
        -: 4495:            newind = indent(wortel,nivo,ind);
        -: 4496:            if(newind)
        -: 4497:                extraspatie = 1;
        -: 4498:            bewerk(opchar[klopcode(wortel)]);
        -: 4499:            ouder = kop(wortel);
        -: 4500:            kind = kop(wortel->RIGHT);
        -: 4501:            if(HAS__UNOPS(wortel->RIGHT) || ouder > kind || (ouder == kind && ouder > MAAL))
        -: 4502:                hreslts(wortel->RIGHT,nivo+1,FALSE,LSP | (space & RHS),snijaf);
        -: 4503:            else if(ouder < kind)
        -: 4504:                {
        -: 4505:                reslts(wortel->RIGHT,nivo+1,FALSE,LSP | (space & RHS),snijaf);
        -: 4506:                return;
        -: 4507:                }
        -: 4508:            else if(newind != ind || ((LSP | (space & RHS)) != space))
        -: 4509:                {
        -: 4510:                reslts(wortel->RIGHT,nivo,newind,LSP | (space & RHS),snijaf);
        -: 4511:                return;
        -: 4512:                }
        -: 4513:            wortel = wortel->RIGHT;
        -: 4514:            }
        -: 4515:        while(is_op(wortel));/* 18 Maart 1997: */
        -: 4516:        }
        -: 4517:    else
        -: 4518:        {
        -: 4519:        indent(wortel,nivo,-1);
        -: 4520:        eindknoop(wortel,space);
        -: 4521:        }
        -: 4522:    }
        -: 4523:#endif /* DEBUGBRACMAT */
        -: 4524:#endif
        -: 4525:
   228280: 4526:static void hreslt(psk wortel,int nivo,int ind,int space)
        -: 4527:{
        -: 4528:static int ouder,kind;
   228280: 4529:if(is_op(wortel))
        -: 4530:    {
        -: 4531:    int number_of_flags;
     2862: 4532:    if(kop(wortel) == WORDT)
      329: 4533:        wortel->RIGHT = Head(wortel->RIGHT);
     2862: 4534:    indent(wortel,nivo,-1);
     2862: 4535:    number_of_flags = printflags(wortel);
     2862: 4536:    number_of_flags_on_node += number_of_flags;
     2862: 4537:    (*verwerk)('(');
     2862: 4538:    indtel = 0;
     2862: 4539:    if(moetIndent(wortel,ind,nivo))
      829: 4540:        extraspatie = 1;
     2862: 4541:    ouder = kop(wortel);
     2862: 4542:    kind = kop(wortel->LEFT);
     2862: 4543:    if(HAS__UNOPS(wortel->LEFT) || ouder >= kind)
     1924: 4544:        hreslt(wortel->LEFT,nivo+1,FALSE,RSP);
        -: 4545:    else
      938: 4546:        reslt(wortel->LEFT,nivo+1,FALSE,RSP);
     2862: 4547:    ind = indent(wortel,nivo,ind);
     2862: 4548:    if(ind)
      829: 4549:        extraspatie = 1;
        -: 4550:#if CHECKALLOCBOUNDS
        -: 4551:    if(POINT)
        -: 4552:        printf("\n[%p %d]",wortel,(wortel->ops & ALL_REFCOUNT_BITS_SET)/ ONE);
        -: 4553:#endif
     2862: 4554:    bewerk(opchar[klopcode(wortel)]);
     2862: 4555:    ouder = kop(wortel);
        -: 4556:
     2862: 4557:    kind = kop(wortel->RIGHT);
     2862: 4558:    if(HAS__UNOPS(wortel->RIGHT) || ouder > kind || (ouder == kind && ouder > MAAL))
     1016: 4559:        hreslt(wortel->RIGHT,nivo+1,FALSE,LSP);
     1846: 4560:    else if(ouder < kind)
     1355: 4561:        reslt(wortel->RIGHT,nivo+1,FALSE,LSP);
        -: 4562:    else
      491: 4563:        reslt(wortel->RIGHT,nivo,ind,LSP);
     2862: 4564:    indent(wortel,nivo,FALSE);
     2862: 4565:    (*verwerk)(')');
     2862: 4566:    number_of_flags_on_node -= number_of_flags;
        -: 4567:    }
        -: 4568:else
        -: 4569:    {
   225418: 4570:    indent(wortel,nivo,-1);
   225418: 4571:    eindknoop(wortel,space);
        -: 4572:    }
   228280: 4573:}
        -: 4574:
     4775: 4575:static void result(psk wortel)
        -: 4576:{
     4775: 4577:if(HAS__UNOPS(wortel))
        -: 4578:    {
    #####: 4579:    hreslt(wortel,0,FALSE,0);
        -: 4580:    }
        -: 4581:else
     4775: 4582:    reslt(wortel,0,FALSE,0);
     4775: 4583:}
        -: 4584:
        -: 4585:#if 1
        -: 4586:#define testMul(a,b,c,d) 
        -: 4587:#else
        -: 4588:#if CHECKALLOCBOUNDS
        -: 4589:static int testMul(char * txt,psk variabele,psk pbinding,int doit)
        -: 4590:    {
        -: 4591:    if(  doit 
        -: 4592:      || is_op(pbinding) && kop(pbinding) == MAAL && pbinding->LEFT->u.obj == 'a'
        -: 4593:      )
        -: 4594:        {
        -: 4595:        POINT = 1;
        -: 4596:        printf("%s ",txt);
        -: 4597:        if(variabele)
        -: 4598:            {
        -: 4599:            result(variabele);
        -: 4600:            }
        -: 4601:        printf(":");
        -: 4602:        result(pbinding);
        -: 4603:        printf("\n");
        -: 4604:        POINT = 0;
        -: 4605:        return 1;
        -: 4606:        }
        -: 4607:    return 0;
        -: 4608:    }
        -: 4609:#else
        -: 4610:#define testMul(a,b,c,d) 
        -: 4611:#endif
        -: 4612:#endif
        -: 4613:
        -: 4614:#if DEBUGBRACMAT
        -: 4615:static void hreslts(psk wortel,int nivo,int ind,int space,psk snijaf)
        -: 4616:{
        -: 4617:static int ouder,kind;
        -: 4618:if(is_op(wortel))
        -: 4619:    {
        -: 4620:    int number_of_flags;
        -: 4621:    if(kop(wortel) == WORDT)
        -: 4622:        wortel->RIGHT = Head(wortel->RIGHT);
        -: 4623:    if(snijaf && wortel->RIGHT == snijaf)
        -: 4624:        {
        -: 4625:        hreslt(wortel->LEFT,nivo,ind,space);
        -: 4626:        return;
        -: 4627:        }
        -: 4628:    indent(wortel,nivo,-1);
        -: 4629:    number_of_flags = printflags(wortel);
        -: 4630:    number_of_flags_on_node += number_of_flags;
        -: 4631:    (*verwerk)('(');
        -: 4632:    indtel = 0;
        -: 4633:    if(moetIndent(wortel,ind,nivo))
        -: 4634:        extraspatie = 1;
        -: 4635:    ouder = kop(wortel);
        -: 4636:    kind = kop(wortel->LEFT);
        -: 4637:    if(HAS__UNOPS(wortel->LEFT) || ouder >= kind)
        -: 4638:        hreslt(wortel->LEFT,nivo+1,FALSE,RSP);
        -: 4639:    else
        -: 4640:        reslt(wortel->LEFT,nivo+1,FALSE,RSP);
        -: 4641:    ind = indent(wortel,nivo,ind);
        -: 4642:    if(ind)
        -: 4643:        extraspatie = 1;
        -: 4644:    bewerk(opchar[klopcode(wortel)]);
        -: 4645:    ouder = kop(wortel);
        -: 4646:    kind = kop(wortel->RIGHT);
        -: 4647:    if(HAS__UNOPS(wortel->RIGHT) || ouder > kind || (ouder == kind && ouder > MAAL))
        -: 4648:        hreslts(wortel->RIGHT,nivo+1,FALSE,LSP,snijaf);
        -: 4649:    else if(ouder < kind)
        -: 4650:        reslts(wortel->RIGHT,nivo+1,FALSE,LSP,snijaf);
        -: 4651:    else
        -: 4652:        reslts(wortel->RIGHT,nivo,ind,LSP,snijaf);
        -: 4653:    indent(wortel,nivo,FALSE);
        -: 4654:    (*verwerk)(')');
        -: 4655:    number_of_flags_on_node -= number_of_flags;
        -: 4656:    }
        -: 4657:else
        -: 4658:    {
        -: 4659:    indent(wortel,nivo,-1);
        -: 4660:    eindknoop(wortel,space);
        -: 4661:    }
        -: 4662:}
        -: 4663:
        -: 4664:static void results(psk wortel,psk snijaf)
        -: 4665:{
        -: 4666:if(HAS__UNOPS(wortel))
        -: 4667:    {
        -: 4668:    hreslts(wortel,0,FALSE,0,snijaf);
        -: 4669:    }
        -: 4670:else
        -: 4671:    reslts(wortel,0,FALSE,0,snijaf);
        -: 4672:}
        -: 4673:#endif
        -: 4674:
     2884: 4675:static LONG toLong(psk kn)
        -: 4676:    {
        -: 4677:    LONG res;
     2884: 4678:    res = (LONG)STRTOUL((char *)POBJ(kn),(char **)NULL,10);
     2884: 4679:    if(kn->ops & MINUS)
       93: 4680:        res = -res;
     2884: 4681:    return res;
        -: 4682:    }
        -: 4683:
        -: 4684:#if DEBUGBRACMAT
        -: 4685:static void setend(char ** punmatched,char * p,const char * wh)
        -: 4686:    {
        -: 4687:    if(punmatched)
        -: 4688:        {
        -: 4689:        *punmatched = p;
        -: 4690:        if(debug)
        -: 4691:            {
        -: 4692:            Printf("                   *punmatched=\"%s\" ;; %s\n",p,wh);
        -: 4693:            }
        -: 4694:        }
        -: 4695:    }
        -: 4696:#else
        -: 4697:#define setend(punmatched,p,wh) {if(punmatched)*punmatched=p;}
        -: 4698:#endif
        -: 4699:
   291501: 4700:static int numbercheck(char *begin,char ** punmatched)
        -: 4701:/* If 'punmatched' != NULL and if numbercheck fails, then '*punmatched' points at the
        -: 4702:first character that cannot be accepted. '*punmatched' must be set to NULL
        -: 4703:if the string 'begin' seems to be too short.
        -: 4704:*/
        -: 4705:    {
        -: 4706:    int op_of_0,check;
   291501: 4707:    int needNonZeroDigit = FALSE; /* 20040308 */
   291501: 4708:    if(!*begin)
     3241: 4709:        return 0;
   288260: 4710:    check = QGETAL;
   288260: 4711:    op_of_0 = *begin;
        -: 4712:
   288260: 4713:    if(op_of_0 >= '0' && op_of_0 <= '9')
        -: 4714:        {
     7385: 4715:        if(op_of_0 == '0')
      791: 4716:            check |= QNUL;
    25100: 4717:        while(optab[op_of_0 = *++begin] != -1)/*20010126*/
        -: 4718:            {
    11083: 4719:            if(op_of_0 == '/')
        -: 4720:                {
        -: 4721:                /*20080911 check &= ~QNUL;*/
      997: 4722:                if(check & QBREUK)
        -: 4723:                    {
    #####: 4724:                    if(punmatched)
        -: 4725:                        {
    #####: 4726:                        if(needNonZeroDigit)
        -: 4727:                            {
    #####: 4728:                            setend(punmatched,begin - 1,"A The first '/' was not acceptable");
        -: 4729:                            }
        -: 4730:                        else
        -: 4731:                            {
    #####: 4732:                            setend(punmatched,begin,"B The second '/' is not acceptable");
        -: 4733:                            }
        -: 4734:                        }
        -: 4735:                    /*check = 0;*/
    #####: 4736:                    check = DEFINITELYNONUMBER;
    #####: 4737:                    break;
        -: 4738:                    }
        -: 4739:                else
        -: 4740:                    {
      997: 4741:                    needNonZeroDigit = TRUE;
      997: 4742:                    check |= QBREUK;
        -: 4743:                    }
        -: 4744:                }
    10086: 4745:            else if(op_of_0 < '0' || op_of_0 > '9')
        -: 4746:                {
      573: 4747:                if(punmatched)
        -: 4748:                    {
    #####: 4749:                    if(needNonZeroDigit)
        -: 4750:                        {
    #####: 4751:                        setend(punmatched,begin - 1,"C The '/' was not acceptable");
        -: 4752:                        }
        -: 4753:                    else
        -: 4754:                        {
    #####: 4755:                        setend(punmatched,begin,"D This character is not acceptable");
        -: 4756:                        }
        -: 4757:                    }
      573: 4758:                check = DEFINITELYNONUMBER;
      573: 4759:                break;
        -: 4760:                }
        -: 4761:            else
        -: 4762:                {
        -: 4763:                /*20080910 initial zero followed by
        -: 4764:                                 0 <= k <= 9 makes no number */
     9513: 4765:                if((check & (QNUL|QBREUK)) == QNUL)
        -: 4766:                    {
      121: 4767:                    setend(punmatched,begin,"H The second figure is not acceptable");
      121: 4768:                    check = DEFINITELYNONUMBER;
      121: 4769:                    break;
        -: 4770:                    }
     9392: 4771:                else if(op_of_0 != '0')
        -: 4772:                    {
     7968: 4773:                    needNonZeroDigit = FALSE;
        -: 4774:                    /*check &= ~QNUL;*/ /*Bart 20080908*/
        -: 4775:                    }
     1424: 4776:                else if(needNonZeroDigit) /* '/' followed by '0' */
        -: 4777:                    {
       59: 4778:                    if(punmatched)
        -: 4779:                        {
    #####: 4780:                        setend(punmatched,begin - 1,"E The '/' was not acceptable");
        -: 4781:                        }
       59: 4782:                    check = DEFINITELYNONUMBER;
       59: 4783:                    break;
        -: 4784:                    }
        -: 4785:                }
        -: 4786:            }
        -: 4787:        /* 20101022 Trailing closing parentheses were accepted on equal footing with '\0' bytes. */
    14770: 4788:        if(op_of_0 == ')') /* "2)"+3       @("-23/4)))))":-23/4)  */
        -: 4789:            {
        5: 4790:            if(punmatched)
        -: 4791:                {
    #####: 4792:                setend(punmatched,begin - 1,"F The ')' was not acceptable");
        -: 4793:                }
        5: 4794:            check = DEFINITELYNONUMBER;
        -: 4795:            }
        -: 4796:        }
        -: 4797:    else
        -: 4798:        {
   280875: 4799:        if(punmatched)
        -: 4800:            {
    #####: 4801:            if(*begin)
        -: 4802:                {
    #####: 4803:                setend(punmatched,begin,"G NAN");
        -: 4804:                }
        -: 4805:            else
    #####: 4806:                *punmatched = NULL;
        -: 4807:            }
   280875: 4808:        check = DEFINITELYNONUMBER;
        -: 4809:        }
   288260: 4810:    if(check && needNonZeroDigit)
        -: 4811:        {
       67: 4812:        if(punmatched)
        -: 4813:            {
    #####: 4814:            if(*begin)
        -: 4815:                {
    #####: 4816:                setend(punmatched,begin,"H needNonZeroDigit");
        -: 4817:                }
        -: 4818:            else
    #####: 4819:                *punmatched = NULL;
        -: 4820:            }
       67: 4821:        check = 0;
        -: 4822:        }
   288260: 4823:    return check;
        -: 4824:    }
        -: 4825:
   265742: 4826:static int fullnumbercheck(char *begin,char ** punmatched)
        -: 4827:/* sets *punmatched to NULL if there are no digits or if there is a digit after a division slash, */
        -: 4828:    {
   265742: 4829:    if(*begin == '-')
        -: 4830:        {
       73: 4831:        int ret = numbercheck(begin+1,punmatched);
       73: 4832:        if(ret & ~DEFINITELYNONUMBER)
       41: 4833:            return ret | MINUS;
        -: 4834:        else
       32: 4835:            return ret;
        -: 4836:        }
        -: 4837:    else
   265669: 4838:        return numbercheck(begin,punmatched);
        -: 4839:    }
        -: 4840:
      375: 4841:static int sfullnumbercheck(char *begin,char * snijaf,char ** punmatched)
        -: 4842:    {
      375: 4843:    unsigned char sav = *snijaf;
        -: 4844:    int ret;
      375: 4845:    *snijaf = '\0';
      375: 4846:    ret = fullnumbercheck(begin,punmatched);
      375: 4847:    *snijaf = sav;
      375: 4848:    return ret;
        -: 4849:    }
        -: 4850:
    33536: 4851:static int flags(
        -: 4852:                void /* 20 Dec 1995 */
        -: 4853:                )
        -: 4854:{
    33536: 4855:int Flgs = 0;
        -: 4856:
     8431: 4857:for(;;start++)
        -: 4858:    {
    41967: 4859:    switch(*start)
        -: 4860:        {
        -: 4861:        case '!' :
     2734: 4862:            if(Flgs & INDIRECT)
       20: 4863:                Flgs |= DOUBLY_INDIRECT;
        -: 4864:            else
     2714: 4865:                Flgs |= INDIRECT;
     2734: 4866:            continue;
        -: 4867:        case '[' :
      164: 4868:            Flgs |= POSITION;
      164: 4869:            continue;
        -: 4870:        case '?' :
     2837: 4871:            Flgs |= UNIFY;
     2837: 4872:            continue;
        -: 4873:        case '#' :
      161: 4874:            Flgs |= NUMBER;
      161: 4875:            continue;
        -: 4876:        case '/' :
       47: 4877:            Flgs |= BREUK;
       47: 4878:            continue;
        -: 4879:        case '@' :
      637: 4880:            Flgs |= ATOM;
      637: 4881:            continue;
        -: 4882:        case '`' :
       75: 4883:            Flgs |= FENCE;
       75: 4884:            continue;
        -: 4885:        case '%' :
      268: 4886:            Flgs |= NONIDENT;
      268: 4887:            continue;
        -: 4888:        case '~' :
      332: 4889:            Flgs ^= NOT;
      332: 4890:            continue;
        -: 4891:        case '<' :
      198: 4892:            Flgs |= SMALLER_THAN;
      198: 4893:            continue;
        -: 4894:        case '>' :
      205: 4895:            Flgs |= GREATER_THAN;
      205: 4896:            continue;
        -: 4897:        case '-' :
      773: 4898:            Flgs ^= MINUS;
      773: 4899:            continue;
        -: 4900:        }
        -: 4901:/*    if((Flgs & (POSITION|NONIDENT)) == POSITION)
        -: 4902:        Flgs |= FENCE; 20111216 */
    33536: 4903:    break;
     8431: 4904:    }
        -: 4905:
    33536: 4906:if((Flgs & NOT) && (Flgs < ATOM))
      124: 4907:    Flgs ^= SUCCESS;
    33536: 4908:return Flgs;
        -: 4909:}
        -: 4910:
        -: 4911:#define flags(OPSFLGS) flags()
        -: 4912:
        -: 4913:
        -: 4914:#define atoom(FLGS,OPSFLGS) atoom(FLGS)
        -: 4915:
    26258: 4916:static psk atoom(int Flgs,int opsflgs)
        -: 4917:    {
        -: 4918:    unsigned char *begin,*eind;
    26258: 4919:    size_t af = 0;
        -: 4920:    psk pkn;
    26258: 4921:    begin = start;
        -: 4922:
   619230: 4923:    while(optab[*start] == NOOP)
   566714: 4924:        if(*start++ == 0x7F)
     1263: 4925:            af++;
        -: 4926:
    26258: 4927:    eind = start;
    26258: 4928:    pkn = (psk)bmalloc(__LINE__,sizeof(unsigned LONG) + 1 + (size_t)(eind - begin) - af);
    26258: 4929:    start = begin;
    26258: 4930:    begin = POBJ(pkn);
   617967: 4931:    while(start < eind)
        -: 4932:        {
   565451: 4933:        if(*start == 0x7F)
        -: 4934:            {
     1263: 4935:            ++start;
     1263: 4936:            *begin++ = (unsigned char)(*start++ | 0x80);
        -: 4937:            }
        -: 4938:        else
        -: 4939:            {
   564188: 4940:            *begin++ = (unsigned char)(*start++ & 0x7F);
        -: 4941:            }
        -: 4942:        }
    26258: 4943:    if(Flgs & INDIRECT)
        -: 4944:        {
     2643: 4945:        (pkn)->v.fl = Flgs ^ SUCCESS;
        -: 4946:        }
        -: 4947:    else
        -: 4948:        {
    23615: 4949:        if(ONTKENNING(Flgs,NUMBER))
       41: 4950:            (pkn)->v.fl = (Flgs ^ (READY|SUCCESS));
        -: 4951:        else
    23574: 4952:            (pkn)->v.fl = (Flgs ^ (READY|SUCCESS)) | (numbercheck(SPOBJ(pkn),NULL) & ~DEFINITELYNONUMBER);
        -: 4953:        /* Bart 20010322 : */
        -: 4954:#if 0 /* 20101122 */
        -: 4955:        if(  !(Flgs & (UNIFY|SMALLER_THAN|GREATER_THAN)) /* 20100126 */
        -: 4956:            && (Flgs & (ATOM|NONIDENT))
        -: 4957:            && (pkn)->u.obj
        -: 4958:            )
        -: 4959:            (pkn)->v.fl &= ~(ATOM|NONIDENT); /* Remove superfluous flags @ and % from non-empty atom*/
        -: 4960:#else
        -: 4961:        /* 20110111 */
    23615: 4962:        if(  !(Flgs & (UNIFY|SMALLER_THAN|GREATER_THAN)) /* 20100126 */
    20598: 4963:            && (Flgs & ATOM)
       28: 4964:            && (pkn)->u.obj
        -: 4965:            )
        1: 4966:            (pkn)->v.fl &= ~ATOM; /* Remove superfluous flag @ from non-empty atom*/
        -: 4967:#endif
        -: 4968:        }
        -: 4969:#undef opsflgs
    26258: 4970:    return pkn;
        -: 4971:    }
        -: 4972:
        -: 4973:#define lex(NXT,GRENS,FLGS,OPSFLGS) lex(NXT,GRENS,FLGS)
        -: 4974:
   224905: 4975:static psk lex(int * nxt,int priority,int Flgs,int opsflgs)
        -: 4976:/* tbw zoekt een expressie of subexpressie */
        -: 4977:/* *nxt (if nxt != 0) is set to the character following the expression. */
        -: 4978:    {
        -: 4979:    int op_of_0;
        -: 4980:    psk pkn;
   224905: 4981:    if(*start > 0 && *start <= '\6')
   191369: 4982:        pkn = zelfde_als_w(adr[*start++]);
        -: 4983:    else
        -: 4984:        {
        -: 4985:        int Flgs;
    33536: 4986:        Flgs = flags(&locopsflgs);
    33536: 4987:        if(*start == '(')
        -: 4988:            {
     7278: 4989:            if(*++start == 0)
        5: 4990:                (*shift)();
     7278: 4991:            pkn = lex(NULL,0,Flgs,locopsflgs);
        -: 4992:            }
        -: 4993:        else
    26258: 4994:            pkn = atoom(Flgs,locopsflgs);
        -: 4995:        }
        -: 4996:
   224905: 4997:    if(*start == 0)
        -: 4998:        {
   187465: 4999:        if(!*(*shift)())
   185840: 5000:            return /*0*/pkn;
        -: 5001:        }
        -: 5002:
    39065: 5003:    op_of_0 = *start;
        -: 5004:
    39065: 5005:    if(*++start == 0)
      925: 5006:        (*shift)();
        -: 5007:
    39065: 5008:    if(optab[op_of_0] == NOOP) /* 20080910 Otherwise problem with the k in ()k */
    #####: 5009:        errorprintf("malformed input\n");
        -: 5010:    else
        -: 5011:        {
    39065: 5012:        Flgs &= ~MINUS;/* 20110831 Bitwise, operators cannot have the - flag. */
        -: 5013:        do
        -: 5014:            {
        -: 5015:            /* op_of_0 == een operator */
        -: 5016:            psk operatorNode;
        -: 5017:            int child_op_of_0;
    58301: 5018:            if(optab[op_of_0] < priority) /* 'op_of_0' heeft te lage prioriteit */
        -: 5019:                {
        -: 5020:#if STRINGMATCH_CAN_BE_NEGATED
        -: 5021:                if(  (Flgs & (NOT|FILTERS)) == (NOT|ATOM)
        -: 5022:                  && kop(*pkn) == MATCH
        -: 5023:                  ) /* 20071229 Undo setting of
        -: 5024:                        success == FALSE
        -: 5025:                       if ~@ flags are attached to : operator
        -: 5026:                       Notice that op_of_0 is ')'
        -: 5027:                       This is a special case. In ~@(a:b) the ~ operator must
        -: 5028:                       not negate the @ but the result of the string match.
        -: 5029:                    */
        -: 5030:                    {
        -: 5031:                    Flgs ^= SUCCESS;
        -: 5032:                    }
        -: 5033:#endif
    26549: 5034:                (pkn)->v.fl ^= Flgs; /*19970821*/
    26549: 5035:                if(nxt)
    19236: 5036:                    *nxt = op_of_0;
    26549: 5037:                return pkn;
        -: 5038:                }
    31752: 5039:            if(optab[op_of_0] == WORDT)
        -: 5040:                {
      754: 5041:                operatorNode = (psk)bmalloc(__LINE__,sizeof(objectknoop));
        -: 5042:        /*        ((objectknoop*)psk)->refcount = 0; done by bmalloc */
        -: 5043:                }
        -: 5044:            else
    30998: 5045:                operatorNode = (psk)bmalloc(__LINE__,sizeof(kknoop));
        -: 5046:            assert(optab[op_of_0] != NOOP);
        -: 5047:            assert(optab[op_of_0] >= 0);
    31752: 5048:            operatorNode->v.fl = optab[op_of_0] | SUCCESS;
        -: 5049:            /*operatorNode->v.fl ^= Flgs;*/
    31752: 5050:            operatorNode->LEFT = pkn;
    31752: 5051:            pkn = operatorNode;/* 'op_of_0' heeft voldoende prioriteit */
    31752: 5052:            if(optab[op_of_0] == priority) /* 'op_of_0' heeft zelfde prioriteit */
        -: 5053:                {
     8895: 5054:                (pkn)->v.fl ^= Flgs; /*19970821*/
     8895: 5055:                operatorNode->RIGHT = NULL;
     8895: 5056:                if(nxt)
     8895: 5057:                    *nxt = op_of_0;
     8895: 5058:                return pkn;
        -: 5059:                }
        -: 5060:            for(;;)
        -: 5061:                {
    31752: 5062:                child_op_of_0 = 0;
        -: 5063:                assert(optab[op_of_0] >= 0);
    31752: 5064:                operatorNode->RIGHT = lex(&child_op_of_0,optab[op_of_0],0,0);
    31752: 5065:                if(child_op_of_0 != op_of_0)
    22857: 5066:                    break;
     8895: 5067:                operatorNode = operatorNode->RIGHT;
     8895: 5068:                }
    22857: 5069:            op_of_0 = child_op_of_0;
        -: 5070:            }
    22857: 5071:        while(op_of_0 != 0);
        -: 5072:        }
     3621: 5073:    (pkn)->v.fl ^= Flgs; /*19970821*/
     3621: 5074:    return /*0*/pkn;
        -: 5075:    }
        -: 5076:
       26: 5077:static psk bouwboom_w(psk pkn)
        -: 5078:    {
       26: 5079:    if(pkn)
       18: 5080:        wis(pkn);
       26: 5081:    InputElement = InputArray;
       26: 5082:    if(InputElement->cutoff)
        -: 5083:        {
        1: 5084:        combineInputBuffers();
        -: 5085:        }
       26: 5086:    start = InputElement->buffer;
       26: 5087:    shift = vshift_w;
       26: 5088:    pkn = lex(NULL,0,0,0);
       26: 5089:    shift = shift_nw;
       26: 5090:    if((--InputElement)->mallocallocated)
        -: 5091:        {
        1: 5092:        bfree(InputElement->buffer);
        -: 5093:        }
       26: 5094:    bfree(InputArray);
       26: 5095:    return pkn;
        -: 5096:    }
        -: 5097:
   607254: 5098:static void lput(int c)
        -: 5099:    {
   607254: 5100:    if(wijzer >= maxwijzer)
        -: 5101:        {
        -: 5102:        inputBuffer * newInputArray;
        -: 5103:        unsigned char * lijst;
        -: 5104:        unsigned char * dest;
        -: 5105:        int len;
        -: 5106:	size_t L;
        -: 5107:
       16: 5108:        for(len = 0;InputArray[++len].buffer;)
        -: 5109:            ;
        -: 5110:        /* len = index of last element in InputArray array */
        -: 5111:
       16: 5112:        lijst = InputArray[len - 1].buffer;
        -: 5113:        /* The last string (probably on the stack, not on the heap) */
        -: 5114:
       16: 5115:        while(wijzer > lijst && optab[*--wijzer] == NOOP)
        -: 5116:            ;
        -: 5117:        /* wijzer points at last operator (where string can be split) or at
        -: 5118:           the start of the string. */
        -: 5119:
       16: 5120:        newInputArray = (inputBuffer *)bmalloc(__LINE__,(2 + len) * sizeof(inputBuffer));
        -: 5121:        /* allocate new array one element bigger than the previous. */
        -: 5122:
       16: 5123:        newInputArray[len + 1].buffer = NULL;
       16: 5124:        newInputArray[len + 1].cutoff = FALSE;
       16: 5125:        newInputArray[len + 1].mallocallocated = FALSE;
       16: 5126:        newInputArray[len].buffer = lijst;
        -: 5127:	/*The buffer pointers with lower index are copied further down.*/
        -: 5128:
        -: 5129:        /*Printf("lijst %p\n",lijst);*/
        -: 5130:
       16: 5131:        newInputArray[len].cutoff = FALSE;
       16: 5132:        newInputArray[len].mallocallocated = FALSE;
        -: 5133:        /*The active buffer is still the one declared in input(),
        -: 5134:	  so on the stack (except under EPOC).*/
       16: 5135:        --len; /* point at the second last element, the one that got filled up. */
       16: 5136:        if(wijzer == lijst)
        -: 5137:            {
        -: 5138:            /* copy the full content of lijst to the second last element */
       14: 5139:            dest = newInputArray[len].buffer = (unsigned char *)bmalloc(__LINE__,DEFAULT_INPUT_BUFFER_SIZE);
       14: 5140:            strncpy((char *)dest,(char *)lijst,DEFAULT_INPUT_BUFFER_SIZE - 1);
       14: 5141:	    dest[DEFAULT_INPUT_BUFFER_SIZE - 1] = '\0';
        -: 5142:            /* Make a notice that the element's string is cut-off */
       14: 5143:            newInputArray[len].cutoff = TRUE;
       14: 5144:            newInputArray[len].mallocallocated = TRUE;
        -: 5145:            }
        -: 5146:        else
        -: 5147:            {
        2: 5148:            ++wijzer; /* wijzer points at first character after the operator */
        -: 5149:            /* maxwijzer - wijzer >= 0 */
        2: 5150:	    L = (size_t)(wijzer - lijst);
        2: 5151:            dest = newInputArray[len].buffer = (unsigned char *)bmalloc(__LINE__,L + 1);
        2: 5152:            strncpy((char *)dest,(char *)lijst,L);
        2: 5153:            dest[L] = '\0';
        2: 5154:            newInputArray[len].cutoff = FALSE;
        2: 5155:            newInputArray[len].mallocallocated = TRUE;
        -: 5156:
        -: 5157:            /* Now remove the substring up to wijzer from lijst */
        2: 5158:	    L = (size_t)(maxwijzer - wijzer);
        2: 5159:            strncpy((char *)lijst,(char *)wijzer,L);
        2: 5160:	    lijst[L] = '\0';
        2: 5161:            wijzer = lijst + L;
        -: 5162:            }
        -: 5163:
        -: 5164:        /* Copy previous element's fields */
      123: 5165:        while(len)
        -: 5166:            {
       91: 5167:            --len;
       91: 5168:            newInputArray[len].buffer = InputArray[len].buffer;
       91: 5169:            newInputArray[len].cutoff = InputArray[len].cutoff;
       91: 5170:            newInputArray[len].mallocallocated = InputArray[len].mallocallocated;
        -: 5171:            }
       16: 5172:        bfree(InputArray);
       16: 5173:        InputArray = newInputArray;
        -: 5174:        }
        -: 5175:    assert(wijzer <= maxwijzer);
   607254: 5176:    *wijzer++ = (unsigned char)c;
   607254: 5177:    }
        -: 5178:
        -: 5179:/* referenced from xml.c */
    #####: 5180:void putOperatorChar(int c)
        -: 5181:/* c == parenthesis, operator of flag */ 
        -: 5182:    {
    #####: 5183:    lput(c);
    #####: 5184:    }
        -: 5185:
        -: 5186:/* referenced from xml.c */
    #####: 5187:void putLeaveChar(int c)
        -: 5188:/* c == any character that should end as part of an atom (string) */ 
        -: 5189:    {
    #####: 5190:    if(c & 0x80)
    #####: 5191:        lput(0x7F);
    #####: 5192:    lput(c | 0x80);
    #####: 5193:    }
        -: 5194:
    #####: 5195:void writeError(psk pkn)
        -: 5196:    {
        -: 5197:    FILE *redfpo;
        -: 5198:    int redMooi;
    #####: 5199:    redMooi = mooi;
    #####: 5200:    mooi = FALSE;
    #####: 5201:    redfpo = fpo;
    #####: 5202:    fpo = errorStream;
        -: 5203:#if !defined NO_FOPEN
    #####: 5204:    if(fpo == NULL && errorFileName != NULL)
    #####: 5205:        fpo = fopen(errorFileName,"a");
        -: 5206:#endif
    #####: 5207:    if(fpo)
        -: 5208:        {
    #####: 5209:        result(pkn);
    #####: 5210:        myputc('\n');
        -: 5211:/*#if !_BRACMATEMBEDDED*/
        -: 5212:#if !defined NO_FOPEN
    #####: 5213:        if(errorStream == NULL && fpo != stderr && fpo != stdout)
        -: 5214:            {
    #####: 5215:            fclose(fpo);/* 20100312 */
        -: 5216:            }
        -: 5217:        }
        -: 5218:#endif
        -: 5219:/*#endif*/
    #####: 5220:    fpo = redfpo;
    #####: 5221:    mooi = redMooi;
    #####: 5222:    }
        -: 5223:
        -: 5224:/*#if !_BRACMATEMBEDDED*/
    #####: 5225:static int redirectError(char * name)
        -: 5226:    {
        -: 5227:#if !defined NO_FOPEN
    #####: 5228:    if(errorFileName)
        -: 5229:        {
    #####: 5230:        free(errorFileName);
    #####: 5231:        errorFileName = NULL;
        -: 5232:        }
        -: 5233:#endif
        -: 5234:/* 20100312
        -: 5235:    if(errorStream && errorStream != stdout && errorStream != stderr)
        -: 5236:        fclose(errorStream);
        -: 5237:*/
    #####: 5238:    if(!strcmp(name,"stdout"))
        -: 5239:        {
    #####: 5240:        errorStream = stdout;
    #####: 5241:        return TRUE;
        -: 5242:        }
    #####: 5243:    else if(!strcmp(name,"stderr"))
        -: 5244:        {
    #####: 5245:        errorStream = stderr;
    #####: 5246:        return TRUE;
        -: 5247:        }
        -: 5248:    else
        -: 5249:        {
        -: 5250:#if !defined NO_FOPEN
    #####: 5251:        errorStream = fopen(name,"a");
    #####: 5252:        if(errorStream)
        -: 5253:            {
        -: 5254:/*            errorFileName = strdup(name);*/
    #####: 5255:            fclose(errorStream);
    #####: 5256:            errorStream = NULL; /* 20100312 */
    #####: 5257:            errorFileName = (char *)malloc(strlen(name)+1);
    #####: 5258:            strcpy(errorFileName,name);
    #####: 5259:            return TRUE;
        -: 5260:            }
        -: 5261:#endif
    #####: 5262:        errorStream = stderr;
        -: 5263:        }
    #####: 5264:    return FALSE;
        -: 5265:    }
        -: 5266:/*#endif*/
        -: 5267:
        -: 5268:
       30: 5269:static psk input(FILE * fpi,psk pkn,int echmemvapstrmltrm,Boolean * err,Boolean * GoOn)
        -: 5270:    {
        -: 5271:    int braces,ikar,hasop,whiteSpaceSeen,escape,backslashesAreEscaped,inString,parentheses,error;
        -: 5272:#ifdef __SYMBIAN32__
        -: 5273:    unsigned char * lijst;
        -: 5274:    lijst = bmalloc(__LINE__,DEFAULT_INPUT_BUFFER_SIZE);
        -: 5275:#else
        -: 5276:    unsigned char lijst[DEFAULT_INPUT_BUFFER_SIZE];
        -: 5277:#endif
       30: 5278:    maxwijzer = lijst + (DEFAULT_INPUT_BUFFER_SIZE - 1);/* er moet ruimte zijn voor afsluitende 0 */
        -: 5279:    /* Array of pointers to inputbuffers. Initially 2 elements,
        -: 5280:       large enough for small inputs (< DEFAULT_INPUT_BUFFER_SIZE)*/
       30: 5281:    InputArray = (inputBuffer *)bmalloc(__LINE__,2*sizeof(inputBuffer));
       30: 5282:    InputArray[0].buffer = lijst;
       30: 5283:    InputArray[0].cutoff = FALSE;
       30: 5284:    InputArray[0].mallocallocated = FALSE;
       30: 5285:    InputArray[1].buffer = NULL;
       30: 5286:    InputArray[1].cutoff = FALSE;
       30: 5287:    InputArray[1].mallocallocated = FALSE;
       30: 5288:    error = FALSE;
       30: 5289:    braces = 0;
       30: 5290:    parentheses = 0;
       30: 5291:    hasop = TRUE;
       30: 5292:    whiteSpaceSeen = FALSE;
       30: 5293:    escape = FALSE;
       30: 5294:    backslashesAreEscaped = TRUE; /* but false in @"C:\dir1\bracmat" */
       30: 5295:    inString = FALSE;
        -: 5296:
        -: 5297:#if READMARKUPFAMILY
       30: 5298:    if(echmemvapstrmltrm & OPT_ML)
        -: 5299:        {
    #####: 5300:        wijzer = lijst;
    #####: 5301:        XMLtext(fpi,(char*)bron,(echmemvapstrmltrm & OPT_TRM),(echmemvapstrmltrm & OPT_HT));
    #####: 5302:        *wijzer = 0;
    #####: 5303:        pkn = bouwboom_w(pkn);
    #####: 5304:        if(err) *err = error;
        -: 5305:#ifdef __SYMBIAN32__
        -: 5306:        bfree(lijst);
        -: 5307:#endif
    #####: 5308:        if(GoOn)
    #####: 5309:            *GoOn = FALSE;
    #####: 5310:        return pkn;
        -: 5311:        }
        -: 5312:    else
        -: 5313:#endif
       30: 5314:        if(echmemvapstrmltrm & (OPT_VAP|OPT_STR))
        -: 5315:        {
       10: 5316:        for(wijzer = lijst;;)
        -: 5317:            {
      459: 5318:            if(fpi)
        -: 5319:                {
    #####: 5320:                ikar = mygetc(fpi);
    #####: 5321:                if(fpi == stdin)
        -: 5322:                   {
    #####: 5323:                   if(ikar == '\n')
    #####: 5324:                       break;
        -: 5325:                   }
    #####: 5326:                else if(ikar == EOF)
    #####: 5327:                   break;
        -: 5328:                }
        -: 5329:            else
      459: 5330:                if((ikar = *bron++) == 0)
       10: 5331:                    break;
      449: 5332:            if(ikar & 0x80)
        2: 5333:                 lput(0x7F);
      449: 5334:            lput(ikar | 0x80);
      449: 5335:            if(echmemvapstrmltrm & OPT_VAP)
        -: 5336:                {
      386: 5337:                if(echmemvapstrmltrm & OPT_STR)
    #####: 5338:                    lput(' ' | 0x80);
        -: 5339:                else
      386: 5340:                    lput(' ');
        -: 5341:                }
      449: 5342:            }
       10: 5343:        *wijzer = 0;
       10: 5344:        pkn = bouwboom_w(pkn);
       10: 5345:        if(err) *err = error;
        -: 5346:#ifdef __SYMBIAN32__
        -: 5347:        bfree(lijst);
        -: 5348:#endif
       10: 5349:        if(GoOn)
        2: 5350:            *GoOn = FALSE;
       10: 5351:        return pkn;
        -: 5352:        }
   754409: 5353:    for( wijzer = lijst
        -: 5354:       ;    
        -: 5355:#if _BRACMATEMBEDDED
        -: 5356:            !error
        -: 5357:         &&
        -: 5358:#endif
   754389: 5359:            (ikar = fpi ? mygetc(fpi) : *bron++) != EOF
   754385: 5360:         && ikar
   754378: 5361:         && parentheses >= 0
        -: 5362:       ;
        -: 5363:       )
        -: 5364:        {
   754378: 5365:        if(echmemvapstrmltrm & OPT_ECH)
        -: 5366:            {
    #####: 5367:            if(fpi != stdin)
    #####: 5368:                Printf("%c",ikar);
    #####: 5369:            if(ikar == '\n')
        -: 5370:                {
    #####: 5371:                if(braces)
    #####: 5372:                    Printf("{com} ");
    #####: 5373:                else if(inString)
    #####: 5374:                    Printf("{str} ");
    #####: 5375:                else if(parentheses > 0 || fpi != stdin)
        -: 5376:                    {
        -: 5377:                    int tel;
    #####: 5378:                    Printf("{%d} ",parentheses);
    #####: 5379:                    if(fpi == stdin)
    #####: 5380:                        for(tel = parentheses;tel;tel--)
    #####: 5381:                                Printf("  ");
        -: 5382:                    }
        -: 5383:                }
        -: 5384:            }
   754378: 5385:        if(braces)
        -: 5386:            {
       20: 5387:            if(ikar == '{')
    #####: 5388:                braces++;
       20: 5389:            else if(ikar == '}')
        2: 5390:                braces--;
        -: 5391:            }
   754358: 5392:        else if(ikar & 0x80)
        -: 5393:            {
     1231: 5394:            if(whiteSpaceSeen && !hasop)
    #####: 5395:                lput(' ');
     1231: 5396:            whiteSpaceSeen = FALSE;
     1231: 5397:            lput(0x7F);
     1231: 5398:            lput(ikar);
     1231: 5399:            escape = FALSE;
        -: 5400:            }
        -: 5401:        else
        -: 5402:            { 
   753127: 5403:            if(escape)
        -: 5404:                {
      391: 5405:                escape = FALSE;
      391: 5406:                if(0 <= ikar && ikar < ' ')
    #####: 5407:                    break;
      391: 5408:                switch(ikar)
        -: 5409:                    {
        -: 5410:                    case 'n' :
       37: 5411:                        ikar = '\n' | 0x80;
       37: 5412:                        break;
        -: 5413:                    case 'f' :
        1: 5414:                        ikar = '\f' | 0x80;
        1: 5415:                        break;
        -: 5416:                    case 'r' :
      127: 5417:                        ikar = '\r' | 0x80;
      127: 5418:                        break;
        -: 5419:                    case 'b' :
        1: 5420:                        ikar = '\b' | 0x80;
        1: 5421:                        break;
        -: 5422:                    case 'a' :
        1: 5423:                        ikar = ALERT | 0x80;
        1: 5424:                        break;
        -: 5425:                    case 'v' :
        1: 5426:                        ikar = '\v' | 0x80;
        1: 5427:                        break;
        -: 5428:                    case 't' :
       19: 5429:                        ikar = '\t' | 0x80;
       19: 5430:                        break;
        -: 5431:                    case '"' :
       28: 5432:                        ikar = '"' | 0x80;
       28: 5433:                        break;
        -: 5434:                    case 'L' :
      111: 5435:                        ikar = 016;
      111: 5436:                        break;
        -: 5437:                    case 'D' :
       19: 5438:                        ikar = 017;
       19: 5439:                        break;
        -: 5440:                    default:
       46: 5441:                        ikar = ikar | 0x80; /* 20070403 */
        -: 5442:                    }
        -: 5443:                }
   752736: 5444:            else if(  ikar == '\\' 
      392: 5445:                   && (  backslashesAreEscaped
        1: 5446:          /*20120413*/|| !inString /* %\L @\L */
        -: 5447:                      )
        -: 5448:                   )
        -: 5449:                {
      391: 5450:                escape = TRUE;
      391: 5451:                continue;
        -: 5452:                }
   752736: 5453:            if(inString)
        -: 5454:                {
    26250: 5455:                if(ikar == '"')
        -: 5456:                    {
      923: 5457:                    inString = FALSE;
      923: 5458:                    backslashesAreEscaped = TRUE;
        -: 5459:                    }
        -: 5460:                else
        -: 5461:                    {
    25327: 5462:                    lput(ikar | 0x80);
        -: 5463:                    }
        -: 5464:                }
        -: 5465:            else
        -: 5466:                {
   726486: 5467:                switch(ikar)
        -: 5468:                    {
        -: 5469:                    case '{' :
        2: 5470:                        braces = 1;
        2: 5471:                        break;
        -: 5472:                    case '}' :
    #####: 5473:                        *wijzer = 0;
    #####: 5474:                        errorprintf(
        -: 5475:                        "\n%s brace }",
        -: 5476:                            unbalanced);
    #####: 5477:                        error = TRUE;
    #####: 5478:                        break;
        -: 5479:                    default :
        -: 5480:                        {
   726484: 5481:                        if(  optab[ikar] == LUCHT
   152676: 5482:                          && (  ikar != '\n' 
     9186: 5483:                             || fpi != stdin
    #####: 5484:                             || parentheses
        -: 5485:                             )
        -: 5486:                          )
        -: 5487:                            {
   152676: 5488:                            whiteSpaceSeen = TRUE;
   152676: 5489:                            backslashesAreEscaped = TRUE; /* Bart 20030331 */
        -: 5490:                            }
        -: 5491:                        else
        -: 5492:                            {
   573808: 5493:                            switch(ikar)
        -: 5494:                                {
        -: 5495:                                case ';' :
        9: 5496:                                    if(parentheses)
        -: 5497:                                        {
    #####: 5498:                                        *wijzer = 0;
    #####: 5499:                                        errorprintf("\n%d %s \"(\"",parentheses,unbalanced);
    #####: 5500:                                        error = TRUE;
        -: 5501:                                        }
        9: 5502:                                    if(echmemvapstrmltrm & OPT_ECH)
    #####: 5503:                                        Printf("\n");
        -: 5504:                                    /* fall through */
        -: 5505:                                case '\n':
        -: 5506:                                    /* You get here only directly if fpi==stdin */
        9: 5507:                                    *wijzer = 0;
        9: 5508:                                    pkn = bouwboom_w(pkn);
        9: 5509:                                    if(error)
    #####: 5510:                                        writeError(pkn);
        9: 5511:                                    if(err) *err = error;
        -: 5512:#ifdef __SYMBIAN32__
        -: 5513:                                    bfree(lijst);
        -: 5514:#endif
        9: 5515:                                    if(GoOn)
        9: 5516:                                        *GoOn = ikar == ';' && !error;
        9: 5517:                                    return pkn;
        -: 5518:                                default:
   573799: 5519:                                    switch(ikar)
        -: 5520:                                        {
        -: 5521:                                        case '"':
      923: 5522:                                            inString = TRUE;
      923: 5523:                                            break;
        -: 5524:                                        case '@':
        -: 5525:                                        case '%': /* These flags are removed if the string
        -: 5526:                                                     is non-empty, so using them to
        -: 5527:                                                     indicate "do not use escape sequences"
        -: 5528:                                                     does no harm.
        -: 5529:                                                     Bart 20010322
        -: 5530:                                                 */
      849: 5531:                                            backslashesAreEscaped = FALSE;
      849: 5532:                                            break;
        -: 5533:                                        case '(':
     5772: 5534:                                            parentheses++;
     5772: 5535:                                            break;
        -: 5536:                                        case ')':
     5772: 5537:                                            backslashesAreEscaped = TRUE;
     5772: 5538:                                            parentheses--;
     5772: 5539:                                            break;
        -: 5540:                                        }
        -: 5541:
   573799: 5542:                                    if(  whiteSpaceSeen
    18736: 5543:                                      && !hasop
    11987: 5544:                                      && optab[ikar] == NOOP
        -: 5545:                                      )
     5752: 5546:                                        lput(' ');
        -: 5547:
   573799: 5548:                                    whiteSpaceSeen = FALSE;
   597512: 5549:                                    hasop =
        -: 5550:                                        (  (ikar == '(')
   568027: 5551:                                        || (  (optab[ikar] < NOOP)
    23713: 5552:                                           && ikar != ')'
        -: 5553:                                           )
        -: 5554:                                        );
        -: 5555:
   573799: 5556:                                    if(!inString)
        -: 5557:                                        {
   572876: 5558:                                        lput(ikar);
   572876: 5559:                                        if(hasop)
    23713: 5560:                                            backslashesAreEscaped = TRUE;
        -: 5561:                                        }
        -: 5562:                                }
        -: 5563:                            }
        -: 5564:                        }
        -: 5565:                    }
        -: 5566:                }
        -: 5567:            }
        -: 5568:        }
       11: 5569:    *wijzer = 0;
        -: 5570:#if _BRACMATEMBEDDED
        -: 5571:    if(!error)
        -: 5572:#endif
        -: 5573:        {
       11: 5574:        if(inString)
        -: 5575:            {
    #####: 5576:            errorprintf("\n%s \"",unbalanced);
    #####: 5577:            error = TRUE;
        -: 5578:            /*exit(1);*/
        -: 5579:            }
       11: 5580:        if(braces)
        -: 5581:            {
    #####: 5582:            errorprintf("\n%d %s \"{\"",braces,unbalanced);
    #####: 5583:            error = TRUE;
        -: 5584:            /*exit(1);*/
        -: 5585:            }
       11: 5586:        if(parentheses > 0)
        -: 5587:            {
    #####: 5588:            errorprintf("\n%d %s \"(\"",parentheses,unbalanced);
    #####: 5589:            error = TRUE;
        -: 5590:            /*exit(1);*/
        -: 5591:            }
       11: 5592:        if(parentheses < 0)
        -: 5593:            {
        -: 5594:#if !defined NO_EXIT_ON_NON_SEVERE_ERRORS
    #####: 5595:            if(ikar == 'j' || ikar == 'J' || ikar == 'y' || ikar == 'Y')
        -: 5596:                {
    #####: 5597:                exit(0);
        -: 5598:                }
    #####: 5599:            else if(!fpi || fpi == stdin)
        -: 5600:                {
    #####: 5601:                Printf(
        -: 5602:                "\nend session? (y/n)"
        -: 5603:                );
    #####: 5604:                while((ikar = mygetc(stdin)) != 'n')
        -: 5605:                    {
    #####: 5606:                    if(ikar == 'j' || ikar == 'J' || ikar == 'y' || ikar == 'Y')
        -: 5607:                        {
    #####: 5608:                        exit(0);
        -: 5609:                        }
        -: 5610:                    }
    #####: 5611:                while(ikar != '\n')
        -: 5612:                    {
    #####: 5613:                    ikar = mygetc(stdin);
        -: 5614:                    }
        -: 5615:                }
        -: 5616:            else
        -: 5617:#endif
        -: 5618:                {
    #####: 5619:                errorprintf("\n%d %s \")\"",-parentheses,unbalanced);
    #####: 5620:                error = TRUE;
        -: 5621:                /*exit(1);*/
        -: 5622:                }
        -: 5623:            }
       11: 5624:        if(echmemvapstrmltrm & OPT_ECH)
    #####: 5625:            Printf("\n");
       11: 5626:        if(*InputArray[0].buffer)
        -: 5627:            {
        7: 5628:            pkn = bouwboom_w(pkn);
        7: 5629:            if(error)
        -: 5630:                {
        -: 5631:#if !_BRACMATEMBEDDED
    #####: 5632:                if(errorFileName)
        -: 5633:                    {
        -: 5634:                    ;
        -: 5635:                    }
        -: 5636:                else
        -: 5637:                    {
    #####: 5638:                    Printf("\nType name of file to write erroneous code to and then press <return>: ");
    #####: 5639:                    wijzer = lijst;
    #####: 5640:                    while((ikar = mygetc(stdin)) != '\n')
        -: 5641:                        {
    #####: 5642:                        *wijzer++ = (unsigned char)ikar;
        -: 5643:                        }
    #####: 5644:                    *wijzer = '\0';
    #####: 5645:                    if(lijst[0])
    #####: 5646:                        redirectError((char *)lijst);
        -: 5647:                    }
        -: 5648:#endif
    #####: 5649:                writeError(pkn);
        -: 5650:                }
        -: 5651:            }
        -: 5652:        else
        -: 5653:            {
        4: 5654:            bfree(InputArray);
        -: 5655:            }
        -: 5656:        }
        -: 5657:#if _BRACMATEMBEDDED
        -: 5658:    else
        -: 5659:        {
        -: 5660:        bfree(InputArray);
        -: 5661:        }
        -: 5662:#endif
       11: 5663:    if(err)
       11: 5664:        *err = error;
        -: 5665:    #ifdef __SYMBIAN32__
        -: 5666:    bfree(lijst);
        -: 5667:    #endif
       11: 5668:    if(GoOn)
        8: 5669:        *GoOn = FALSE;
       11: 5670:    return pkn;
        -: 5671:    }
        -: 5672:
        -: 5673:#if JMP
        -: 5674:#include <setjmp.h>
        -: 5675:static jmp_buf jumper;
        -: 5676:#endif
        -: 5677:
        3: 5678:void /*int*/ stringEval(const char *s,const char ** out,int * err)
        -: 5679:    {
        -: 5680:#if _BRACMATEMBEDDED
        -: 5681:    char * buf = (char *)malloc(strlen(s) + 11);
        -: 5682:    sprintf(buf,"put$(%s,MEM)",s);
        -: 5683:#else
        3: 5684:    char * buf = (char *)malloc(strlen(s) + 7);
        3: 5685:    sprintf(buf,"str$(%s)",s);
        -: 5686:#endif
        3: 5687:    bron = (unsigned char *)buf;
        3: 5688:    anker = input(NULL,anker,4,err,NULL);
        3: 5689:    if(err && *err)
    #####: 5690:        return /*FALSE*/;
        -: 5691:#if JMP
        -: 5692:    if(setjmp(jumper) != 0)
        -: 5693:        {
        -: 5694:        free(buf);
        -: 5695:        return -1;
        -: 5696:        }
        -: 5697:#endif
        3: 5698:    anker = eval(anker);
        3: 5699:    if(out != NULL)
        1: 5700:        *out = is_op(anker) ? "" : (const char *)POBJ(anker);
        3: 5701:    free(buf);
        3: 5702:    return /*1*/;
        -: 5703:    }
        -: 5704:
    42916: 5705:static psk copievan(psk kn)
        -: 5706:    {
        -: 5707:    psk res;
    42916: 5708:    res = icopievan(kn);
    42916: 5709:    res->v.fl &= ~IDENT;
    42916: 5710:    return res;
        -: 5711:    }
        -: 5712:
   627140: 5713:static psk _copyop(psk pkn)
        -: 5714:    {
        -: 5715:    psk hulp;
   627140: 5716:    hulp = new_operator_like(pkn);
   627140: 5717:    hulp->ops = pkn->ops & ~ALL_REFCOUNT_BITS_SET;
   627140: 5718:    hulp->LEFT = zelfde_als_w_2(&pkn->LEFT);
   627140: 5719:    hulp->RIGHT = zelfde_als_w(pkn->RIGHT);
   627140: 5720:    return hulp;
        -: 5721:    }
        -: 5722:
   606526: 5723:static psk copyop(psk pkn)
        -: 5724:    {
   606526: 5725:    dec_refcount(pkn);
   606526: 5726:    return _copyop(pkn);
        -: 5727:    }
        -: 5728:
   236174: 5729:static psk subboomcopie(psk src)
        -: 5730:    {
   236174: 5731:    if(is_op(src))
    20614: 5732:        return _copyop(src);
        -: 5733:    else
   215560: 5734:        return icopievan(src);
        -: 5735:    }
        -: 5736:
    48837: 5737:static int getal_graad(psk kn)
        -: 5738:    {
    48837: 5739:    if(RATIONAAL_COMP(kn))
    20295: 5740:        return 4;
    28542: 5741:    switch(PLOBJ(kn))
        -: 5742:        {
      464: 5743:        case IM: return 3;
       28: 5744:        case PI: return 2;
      906: 5745:        case XX: return 1;
    27144: 5746:        default: return 0;
        -: 5747:        }
        -: 5748:    }
        -: 5749:
      397: 5750:static int is_constant(psk kn)
        -: 5751:    {
      861: 5752:    while(is_op(kn))
        -: 5753:        {
        -: 5754:        /* return is_constant(kn->LEFT) && is_constant(kn->RIGHT);
        -: 5755:        18 Maart 1997 */
      107: 5756:        if(!is_constant(kn->LEFT))
       40: 5757:            return FALSE;
       67: 5758:        kn = kn->RIGHT;
        -: 5759:        }
      357: 5760:    return getal_graad(kn);
        -: 5761:    }
        -: 5762:
        1: 5763:static void init_opcode(void)
        -: 5764:    {
        -: 5765:    int tel;
      257: 5766:    for(tel = 0;tel<256;tel++)
        -: 5767:        {
        -: 5768:#if TELLING
        -: 5769:        cnts[tel] = 0;
        -: 5770:#endif
      256: 5771:        switch (tel)
        -: 5772:            {
        -: 5773:            case 0   :
        2: 5774:            case ')' : optab[tel] = -1   ;break;
        1: 5775:            case '=' : optab[tel] = WORDT;break;
        1: 5776:            case '.' : optab[tel] = DOT  ;break;
        1: 5777:            case ',' : optab[tel] = KOMMA;break;
        1: 5778:            case '|' : optab[tel] = OF   ;break;
        1: 5779:            case '&' : optab[tel] = EN   ;break;
        1: 5780:            case ':' : optab[tel] = MATCH;break;
        1: 5781:            case '+' : optab[tel] = PLUS ;break;
        1: 5782:            case '*' : optab[tel] = MAAL ;break;
        1: 5783:            case '^' : optab[tel] = EXP  ;break;
        1: 5784:            case 016 : optab[tel] = LOG  ;break;
        1: 5785:            case 017 : optab[tel] = DIF  ;break;
        1: 5786:            case '$' : optab[tel] = FUN  ;break;
        1: 5787:            case '\'': optab[tel] = FUU  ;break;
        1: 5788:            case '_' : optab[tel] = STREEP;break;
      240: 5789:            default  : optab[tel] = (tel <= ' ') ? LUCHT : NOOP;
        -: 5790:            }
        -: 5791:        }
        1: 5792:    }
        -: 5793:
   430298: 5794:static psk prive(psk pkn)
        -: 5795:    {
   430298: 5796:    if(shared(pkn))
        -: 5797:        {
   220838: 5798:        dec_refcount(pkn);
   220838: 5799:        return subboomcopie(pkn);
        -: 5800:        }
   209460: 5801:    return pkn;
        -: 5802:    }
        -: 5803:
   197064: 5804:static psk setflgs(psk pokn,int Flgs)
        -: 5805:    {
   197064: 5806:    if((Flgs & ERFENIS) || !(Flgs & SUCCESS))
        -: 5807:        {
      130: 5808:        pokn = prive(pokn);
      130: 5809:        pokn->v.fl ^= ((Flgs & SUCCESS) ^ SUCCESS);
      130: 5810:        pokn->v.fl |= (Flgs & ERFENIS);
      130: 5811:        if(ANYNEGATION(Flgs))
      100: 5812:            pokn->v.fl |= NOT;
        -: 5813:        }
   197064: 5814:    return pokn;
        -: 5815:    }
        -: 5816:
        1: 5817:static psk startboom_w(psk pkn,...)
        -: 5818:    {
        1: 5819:    if(pkn)
    #####: 5820:        wis(pkn);
        1: 5821:    va_start(ap,pkn);
        1: 5822:    start = startPos = va_arg(ap,unsigned char *);
        1: 5823:    pkn = lex(NULL,0,0,0);
        1: 5824:    va_end(ap);
        1: 5825:    return pkn;
        -: 5826:    }
        -: 5827:
   184478: 5828:static psk vopbnowis(psk pkn,const char *conc[])
        -: 5829:    {
        -: 5830:    psk okn;
        -: 5831:    assert(pkn != NULL);
   184478: 5832:    pstart = (unsigned char **)conc;
   184478: 5833:    start = (unsigned char *)conc[0];
   184478: 5834:    shift = vshift_nw;
   184478: 5835:    okn = lex(NULL,0,0,0);
   184478: 5836:    shift = shift_nw;
   184478: 5837:    okn = setflgs(okn,pkn->v.fl);
   184478: 5838:    return okn;
        -: 5839:    }
        -: 5840:
   184478: 5841:static psk vopb(psk pkn,const char *conc[])
        -: 5842:    {
   184478: 5843:    psk okn = vopbnowis(pkn,conc);
   184478: 5844:    wis(pkn);
   184478: 5845:    return okn;
        -: 5846:    }
        -: 5847:
     1370: 5848:static psk opb(psk pkn,...)
        -: 5849:    {
        -: 5850:    psk okn;
     1370: 5851:    va_start(ap,pkn);
     1370: 5852:    start = startPos = va_arg(ap,unsigned char *);
     1370: 5853:    okn = lex(NULL,0,0,0);
     1370: 5854:    va_end(ap);
     1370: 5855:    if(pkn)
        -: 5856:        {
     1208: 5857:        okn = setflgs(okn,pkn->v.fl);
     1208: 5858:        wis(pkn);
        -: 5859:        }
     1370: 5860:    return okn;
        -: 5861:    }
        -: 5862:
    11229: 5863:static psk dopb(psk pkn,psk src)
        -: 5864:    {
        -: 5865:    psk okn;
    11229: 5866:    okn = zelfde_als_w(src);
    11229: 5867:    okn = setflgs(okn,(pkn)->v.fl);
    11229: 5868:    wis(pkn);
    11229: 5869:    return okn;
        -: 5870:    }
        -: 5871:
        7: 5872:static int fireBuiltInFunc(objectknoop * object,char * name)
        -: 5873:    {
        -: 5874:    /*Printf("find member %s\n",name);*/
        7: 5875:    if(ISBUILTIN((objectknoop*)object))
        -: 5876:        {
        7: 5877:        method_pnt theMethod = NULL;
        7: 5878:        method * methods = ((typedObjectknoop*)object)->vtab;
        -: 5879:        /*
        -: 5880:        Printf("object==(");result((psk)object);Printf(")\n");
        -: 5881:        Printf("is <%s> built-in?\n",name);
        -: 5882:        Printf("object %p\n",object);
        -: 5883:        result((psk)object);
        -: 5884:        Printf("methods %p\n",methods);
        -: 5885:        getchar();
        -: 5886:        */
        7: 5887:        if(methods)
        -: 5888:            {
        7: 5889:            for(;methods->name && strcmp(methods->name,name);++methods)
        -: 5890:                ;
        7: 5891:            theMethod = methods->func;
        -: 5892:            }
        7: 5893:        if(theMethod)
        -: 5894:            {
        -: 5895:            /*Printf("theMethod found %p\n",theMethod);*/
        7: 5896:            theMethod((struct typedObjectknoop *)object,NULL);
        7: 5897:            return TRUE;
        -: 5898:            }
        -: 5899:        }
    #####: 5900:    return FALSE;
        -: 5901:    }
        -: 5902:
  4104892: 5903:static void wis(psk top)
        -: 5904:    {
  8853186: 5905:    while(!shared(top)) /* 18 Maart 1997, tail recursion optimisation; delete deep structures*/
        -: 5906:        {
  1368295: 5907:        psk kn = NULL; /* 18 Maart 1997 */
  1368295: 5908:        if(is_object(top) && ISCREATEDWITHNEW((objectknoop*)top))
        -: 5909:            {
        -: 5910:    /*        psk kn = NULL;*/
       14: 5911:            adr[1] = top->RIGHT;
       14: 5912:            kn = opb(kn,"(((=\1).die)')",NULL);
       14: 5913:            kn = eval(kn);
       14: 5914:            wis(kn);
       14: 5915:            if(ISBUILTIN((objectknoop*)top))
        7: 5916:                fireBuiltInFunc((objectknoop*)top,"Die");
        -: 5917:            }
  1368295: 5918:        if(is_op(top))
        -: 5919:            {
   643402: 5920:            wis(top->LEFT);
   643402: 5921:            kn = top; /* 18 Maart 1997 */
   643402: 5922:            top = top->RIGHT; /* 18 Maart 1997 */
   643402: 5923:            pskfree(kn);
        -: 5924:            }
        -: 5925:        else
        -: 5926:            {
   724893: 5927:            if(top->ops & LATEBIND)
        -: 5928:                {
      862: 5929:                wis(((stringrefknoop*)top)->kn);
        -: 5930:                }
   724893: 5931:            pskfree(top);
  4829785: 5932:            return;
        -: 5933:            }
        -: 5934:        }
  3379999: 5935:    dec_refcount(top);
        -: 5936:    }
        -: 5937:
   300792: 5938:static int macht2(int n)
        -: 5939:/* retourneert MSB van n */
        -: 5940:    {
        -: 5941:    int m;
  1324626: 5942:    for( m = 1
        -: 5943:       ; n
   723042: 5944:       ; n >>= 1,m <<= 1
        -: 5945:       )
        -: 5946:       ;
   300792: 5947:    return m >> 1;
        -: 5948:    }
        -: 5949:
  1422699: 5950:static ppsk Entry(int n,int index,varia **pv)
        -: 5951:    {
  1422699: 5952:    if(n == 0)
        -: 5953:        {
  1214846: 5954:        return (ppsk)pv;  /* er zijn geen varia records nodig voor 1 entry */
        -: 5955:        }
        -: 5956:    else
        -: 5957:        {
        -: 5958:        varia *hv;
   207853: 5959:        int MSB = macht2(n);
   423935: 5960:        for( hv = *pv /* begin bij langste varia record */
   184111: 5961:           ; MSB > 1 && index < MSB
     8229: 5962:           ; MSB >>= 1
        -: 5963:           )
     8229: 5964:           hv = hv->prev;
   207853: 5965:        index -= MSB;   /* als index == 0, dan wordt index -1 */
   207853: 5966:        return &hv->verdi[index];  /* verdi[-1] == (psk)*prev */
        -: 5967:        }
        -: 5968:    }
        -: 5969:
    38299: 5970:static psk Entry2(int n,int index,varia * pv)
        -: 5971:    {
    38299: 5972:    if(n == 0)
        -: 5973:        {
     6544: 5974:        return (psk)pv;  /* er zijn geen varia records nodig voor 1 entry */
        -: 5975:        }
        -: 5976:    else
        -: 5977:        {
        -: 5978:        varia *hv;
    31755: 5979:        int MSB = macht2(n);
    67616: 5980:        for( hv = pv /* begin bij langste varia record */
    28889: 5981:           ; MSB > 1 && index < MSB
     4106: 5982:           ; MSB >>= 1
        -: 5983:           )
     4106: 5984:           hv = hv->prev;
    31755: 5985:        index -= MSB;   /* als index == 0, dan wordt index -1 */
    31755: 5986:        return hv->verdi[index];  /* verdi[-1] == (psk)*prev */
        -: 5987:        }
        -: 5988:    }
        -: 5989:
        -: 5990:#if INTSCMP
        -: 5991:static int intscmp(LONG *s1,LONG *s2) /* deze routine geeft verschillende resultaten
        -: 5992:                                  afhankelijk van BIGENDIAN */
        -: 5993:{
        -: 5994:while(*((char *)s1 + 3))
        -: 5995:    {
        -: 5996:    if(*s1 != *s2)
        -: 5997:        {
        -: 5998:        if(*s1 < *s2)
        -: 5999:            return -1;
        -: 6000:        else
        -: 6001:            return 1;
        -: 6002:        }
        -: 6003:    s1++;
        -: 6004:    s2++;
        -: 6005:    }
        -: 6006:if(*s1 != *s2)
        -: 6007:    {
        -: 6008:    if(*s1 < *s2)
        -: 6009:        return -1;
        -: 6010:    else
        -: 6011:        return 1;
        -: 6012:    }
        -: 6013:else
        -: 6014:    return 0;
        -: 6015:}
        -: 6016:#endif
        -: 6017:
        -: 6018:
   532973: 6019:static int zoeknaam(psk name,
        -: 6020:                    vars **pvoorvar,
        -: 6021:                    vars **pnavar)
        -: 6022:    {
        -: 6023:    unsigned char *string;
        -: 6024:    vars *navar,*voorvar;
   532973: 6025:    string = POBJ(name);
  7251511: 6026:    for( voorvar = NULL,navar = variabelen[*string]
  6714296: 6027:       ;  navar && (STRCMP(VARNAME(navar),string) < 0)
  6185565: 6028:       ; voorvar = navar,navar = navar->next
        -: 6029:       )
        -: 6030:       ;
        -: 6031:    /* voorvar < string <= navar */
   532973: 6032:    *pvoorvar = voorvar;
   532973: 6033:    *pnavar = navar;
   532973: 6034:    return navar && !STRCMP(VARNAME(navar),string);
        -: 6035:    }
        -: 6036:
       29: 6037:static Qgetal _qmaalmineen(Qgetal _qx)
        -: 6038:    {
        -: 6039:    Qgetal res;
        -: 6040:    size_t len;
       29: 6041:    len = offsetof(sk,u.obj) + 1 + strlen((char *)POBJ(_qx));
       29: 6042:    res = (Qgetal)bmalloc(__LINE__,len);
       29: 6043:    memcpy(res,_qx,len);
       29: 6044:    res->ops ^= MINUS;
       29: 6045:    res->ops &= ~ALL_REFCOUNT_BITS_SET;
       29: 6046:    return res;
        -: 6047:    }
        -: 6048:
        -: 6049:/* Create a node from a number, allocating memory for the node.
        -: 6050:The numbers' memory isn't deallocated. */
      213: 6051:static psk numberNode(ngetal * g)
        -: 6052:    {
        -: 6053:    psk res;
        -: 6054:    size_t len;
      213: 6055:    len = offsetof(sk,u.obj) + 1 + g->length;
      213: 6056:    res = (psk)bmalloc(__LINE__,len);
      213: 6057:    if(g->sign & QNUL)
    #####: 6058:        res->u.obj = '0';
        -: 6059:    else
        -: 6060:        {
      213: 6061:        memcpy((void*)POBJ(res),g->number,g->length);
        -: 6062:    /*(char *)POBJ(res) + g.length = '\0'; hoeft niet, gebeurt in bmalloc */
        -: 6063:        }
      213: 6064:    res->v.fl = READY | SUCCESS | QGETAL;
      213: 6065:    res->ops |= g->sign;
      213: 6066:    return res;
        -: 6067:    }
        -: 6068:
    17983: 6069:static char * iconvert2decimal(ngetal * res, char * g)
        -: 6070:    {
        -: 6071:    LONG * iwyzer;
    17983: 6072:    g[0] = '0';
    17983: 6073:    g[1] = 0;
    17983: 6074:    for(iwyzer = res->inumber;iwyzer < res->inumber + res->ilength;++iwyzer)
        -: 6075:        {
        -: 6076:        assert(*iwyzer >= 0);
        -: 6077:        assert(*iwyzer < RADIX);
    17983: 6078:        if(*iwyzer)
        -: 6079:            {
    17983: 6080:            g += sprintf(g,"%ld",*iwyzer);
    87038: 6081:            for(;++iwyzer < res->inumber + res->ilength;)
        -: 6082:                {
        -: 6083:                assert(*iwyzer >= 0);
        -: 6084:                assert(*iwyzer < RADIX);
    51072: 6085:                g += sprintf(g,"%0*ld",(int)TEN_LOG_RADIX,*iwyzer);
        -: 6086:                }
    17983: 6087:            break;
        -: 6088:            }
        -: 6089:        }
    17983: 6090:    return g;
        -: 6091:    }
        -: 6092:
    17997: 6093:static ptrdiff_t numlength(ngetal * n)
        -: 6094:    {
        -: 6095:    ptrdiff_t len;
        -: 6096:    LONG H;
        -: 6097:    assert(n->ilength >= 1);
    17997: 6098:    len = TEN_LOG_RADIX*n->ilength;
    17997: 6099:    H = n->inumber[0];
    17997: 6100:    if(H < 10)
    12371: 6101:        len -= TEN_LOG_RADIX - 1;
     5626: 6102:    else if(H < 100)
     3417: 6103:        len -= TEN_LOG_RADIX - 2;
     2209: 6104:    else if(H < 1000)
      139: 6105:        len -= TEN_LOG_RADIX - 3;
        -: 6106:#if !WORD32
        -: 6107:    else if(H < 10000)
        -: 6108:        len -= TEN_LOG_RADIX - 4;
        -: 6109:    else if(H < 100000)
        -: 6110:        len -= TEN_LOG_RADIX - 5;
        -: 6111:    else if(H < 1000000)
        -: 6112:        len -= TEN_LOG_RADIX - 6;
        -: 6113:    else if(H < 10000000)
        -: 6114:        len -= TEN_LOG_RADIX - 7;
        -: 6115:    else if(H < 100000000)
        -: 6116:        len -= TEN_LOG_RADIX - 8;
        -: 6117:#endif
    17997: 6118:    return len;
        -: 6119:    }
        -: 6120:
      937: 6121:static psk inumberNode(ngetal * g)
        -: 6122:    {
        -: 6123:    psk res;
        -: 6124:    size_t len;
      937: 6125:    len = offsetof(sk,u.obj) + numlength(g);
      937: 6126:    res = (psk)bmalloc(__LINE__,len + 1);
      937: 6127:    if(g->sign & QNUL)
       14: 6128:        res->u.obj = '0';
        -: 6129:    else
        -: 6130:        {
      923: 6131:        iconvert2decimal(g,(char *)POBJ(res));
        -: 6132:        }
        -: 6133:
      937: 6134:    res->v.fl = READY | SUCCESS | QGETAL;
      937: 6135:    res->ops |= g->sign;
      937: 6136:    return res;
        -: 6137:    }
        -: 6138:
        -: 6139:/* Create a node from a number, only allocating memory for the node if the
        -: 6140:number hasn't the right size (== too large). If new memory is allocated,
        -: 6141:the number's memory is deallocated. */
   373412: 6142:static psk numberNode2(ngetal * g)
        -: 6143:    {
        -: 6144:    psk res;
        -: 6145:    size_t neededlen;
   373412: 6146:    size_t availablelen = g->allocated;
   373412: 6147:    neededlen = offsetof(sk,u.obj) + 1 + g->length;
   373412: 6148:    if((neededlen - 1)/sizeof(LONG) == (availablelen - 1)/sizeof(LONG))
        -: 6149:        {
   368355: 6150:        res = (psk)g->alloc;
   368355: 6151:        if(g->sign & QNUL)
        -: 6152:            {
     6791: 6153:            res->u.lobj = 0;
     6791: 6154:            res->u.obj = '0';
        -: 6155:            }
        -: 6156:        else
        -: 6157:            {
   361564: 6158:            char * end = (char *)POBJ(res) + g->length;
   361564: 6159:            char * limit = (char *)g->alloc + (1+(availablelen - 1)/sizeof(LONG))*sizeof(LONG);
   361564: 6160:            memmove((void*)POBJ(res),g->number,g->length);
  1826057: 6161:            while(end < limit)
  1102929: 6162:                *end++ = '\0';
        -: 6163:            }
        -: 6164:        }
        -: 6165:    else
        -: 6166:        {
     5057: 6167:        res = (psk)bmalloc(__LINE__,neededlen);
     5057: 6168:        if(g->sign & QNUL)
       48: 6169:            res->u.obj = '0';
        -: 6170:        else
        -: 6171:            {
     5009: 6172:            memcpy((void*)POBJ(res),g->number,g->length);
        -: 6173:            /*(char *)POBJ(res) + g.length = '\0'; hoeft niet, gebeurt in bmalloc */
        -: 6174:            }
     5057: 6175:        bfree(g->alloc);
        -: 6176:        }
   373412: 6177:    res->v.fl = READY | SUCCESS | QGETAL;
   373412: 6178:    res->ops |= g->sign;
   373412: 6179:    return res;
        -: 6180:    }
        -: 6181:
        3: 6182:static Qgetal not_a_number(void)
        -: 6183:    {
        -: 6184:    Qgetal res;
        3: 6185:    res = copievan(&nulk);
        3: 6186:    res->v.fl ^= SUCCESS;
        3: 6187:    return res;
        -: 6188:    }
        -: 6189:
    39980: 6190:static void convert2binary(ngetal * x)
        -: 6191:    {
        -: 6192:    LONG * iwyzer;
        -: 6193:    char * wyzer;
        -: 6194:    ptrdiff_t n;
        -: 6195: 
    39980: 6196:    x->ilength = x->iallocated = ((x->sign & QNUL ? 1 : x->length) + TEN_LOG_RADIX - 1) / TEN_LOG_RADIX;
    39980: 6197:    x->inumber = x->ialloc = (LONG *)bmalloc(__LINE__,sizeof(LONG) * x->iallocated);
        -: 6198: 
   212148: 6199:    for(   iwyzer = x->inumber
    39980: 6200:         , wyzer = x->number
    39980: 6201:         , n = x->length
   132188: 6202:       ; iwyzer < x->inumber + x->ilength
    92208: 6203:       ; ++iwyzer
        -: 6204:       )
        -: 6205:        {
    92208: 6206:        *iwyzer = 0;
        -: 6207:        do
        -: 6208:            {
   260028: 6209:            *iwyzer = 10 * (*iwyzer) + *wyzer++ - '0';
        -: 6210:            }
   260028: 6211:        while(--n % TEN_LOG_RADIX != 0);
        -: 6212:        }
        -: 6213:    assert((LONG)TEN_LOG_RADIX * x->ilength >= wyzer - x->number);
    39980: 6214:    }
        -: 6215:
     5350: 6216:static char * isplits(Qgetal _qget,ngetal * ptel,ngetal * pnoem)
        -: 6217:    {
     5350: 6218:    ptel->sign = _qget->ops & (MINUS|QNUL);
     5350: 6219:    pnoem->sign = 0;
     5350: 6220:    pnoem->alloc = ptel->alloc = NULL;
     5350: 6221:    ptel->number = (char *)POBJ(_qget);
     5350: 6222:    if(_qget->v.fl & QBREUK)
        -: 6223:        {
     3226: 6224:        char * on = strchr(ptel->number,'/');
        -: 6225:        assert(on);
     3226: 6226:        ptel->length = on - ptel->number;
     3226: 6227:        pnoem->number = on + 1;
     3226: 6228:        pnoem->length = strlen(on + 1);
     3226: 6229:        convert2binary(ptel);
     3226: 6230:        convert2binary(pnoem);
     3226: 6231:        return on;
        -: 6232:        }
        -: 6233:    else
        -: 6234:        {
        -: 6235:        assert(!(_qget->v.fl & QBREUK));
     2124: 6236:        ptel->length = strlen(ptel->number);
     2124: 6237:        pnoem->number = "1";
     2124: 6238:        pnoem->length = 1;
     2124: 6239:        convert2binary(ptel);
     2124: 6240:        convert2binary(pnoem);
     2124: 6241:        return NULL;
        -: 6242:        }
        -: 6243:    }
        -: 6244:
   761682: 6245:static char * splits(Qgetal _qget,ngetal * ptel,ngetal * pnoem)
        -: 6246:    {
   761682: 6247:    ptel->sign = _qget->ops & (MINUS|QNUL);
   761682: 6248:    pnoem->sign = 0;
   761682: 6249:    pnoem->alloc = ptel->alloc = NULL;
   761682: 6250:    ptel->number = (char *)POBJ(_qget);
        -: 6251:
   761682: 6252:    if(_qget->v.fl & QBREUK)
        -: 6253:        {
     8291: 6254:        char * on = strchr(ptel->number,'/');
        -: 6255:        assert(on);
     8291: 6256:        ptel->length = on - ptel->number;
     8291: 6257:        pnoem->number = on + 1;
     8291: 6258:        pnoem->length = strlen(on + 1);
     8291: 6259:        return on;
        -: 6260:        }
        -: 6261:    else
        -: 6262:        {
        -: 6263:        assert(!(_qget->v.fl & QBREUK));
   753391: 6264:        ptel->length = strlen(ptel->number);
   753391: 6265:        pnoem->number = "1";
   753391: 6266:        pnoem->length = 1;
   753391: 6267:        return NULL;
        -: 6268:        }
        -: 6269:    }
        -: 6270:
        -: 6271:
   373412: 6272:static int opaffinal(char * i1,char * i2,char tmp,char ** pres,char *bx)
        -: 6273:    {
  2068513: 6274:    for(;i2 >= bx;)
        -: 6275:        {
  1321689: 6276:        tmp += (*i2);
  1321689: 6277:        if(tmp > '9')
        -: 6278:            {
      111: 6279:            *i1-- = tmp - 10;
      111: 6280:            tmp = 1;
        -: 6281:            }
  1321578: 6282:        else if(tmp < '0')
        -: 6283:            {
     2242: 6284:            *i1-- = tmp + 10;
     2242: 6285:            tmp = -1;
        -: 6286:            }
        -: 6287:        else
        -: 6288:            {
  1319336: 6289:            *i1-- = tmp;
  1319336: 6290:            tmp = 0;
        -: 6291:            }
  1321689: 6292:        i2--;
        -: 6293:        }
   373412: 6294:    *pres = i1+1;
   373412: 6295:    return tmp;
        -: 6296:    }
        -: 6297:
        -: 6298:
    11590: 6299:static int op(char **pres,char *bx,char *ex,char *by,char *ey)
        -: 6300:    {
    11590: 6301:    char *i1 = *pres,*i2 = ex,*wyzer = ey;
    11590: 6302:    char tmp = 0;
        -: 6303:    do
        -: 6304:        {
    11610: 6305:        tmp += (*i2 + *wyzer-'0');
    11610: 6306:        if(tmp > '9')
        -: 6307:            {
     1035: 6308:            *i1-- = tmp - 10;
     1035: 6309:            tmp = 1;
        -: 6310:            }
        -: 6311:        else
        -: 6312:            {
    10575: 6313:            *i1-- = tmp;
    10575: 6314:            tmp = 0;
        -: 6315:            }
    11610: 6316:        --i2;
    11610: 6317:        --wyzer;
        -: 6318:        }
    11610: 6319:    while(wyzer >= by);
    11590: 6320:    return opaffinal(i1,i2,tmp,pres,bx);
        -: 6321:    }
        -: 6322:
   361822: 6323:static int af(char **pres,char *bx,char *ex,char *by,char *ey)
        -: 6324:    {
   361822: 6325:    char *i1 = *pres,*i2 = ex,*wyzer = ey;
   361822: 6326:    char tmp = 0;
        -: 6327:    do
        -: 6328:        {
   386214: 6329:        tmp += (*i2 - *wyzer + '0');
   386214: 6330:        if(tmp < '0')
        -: 6331:            {
    40784: 6332:            *i1-- = tmp + 10;
    40784: 6333:            tmp = -1;
        -: 6334:            }
        -: 6335:        else
        -: 6336:            {
   345430: 6337:            *i1-- = tmp;
   345430: 6338:            tmp = 0;
        -: 6339:            }
   386214: 6340:        --i2;
   386214: 6341:        --wyzer;
        -: 6342:        }
   386214: 6343:    while(wyzer >= by);
   361822: 6344:    return opaffinal(i1,i2,tmp,pres,bx);
        -: 6345:    }
        -: 6346:
        -: 6347:
        -: 6348:
   373412: 6349:static void skipnullen(ngetal * nget,int teken)
        -: 6350:    {
  1133943: 6351:    for(
  1514223: 6352:       ; nget->length > 0 && *(nget->number) == '0'
   387119: 6353:       ; nget->number++,nget->length--
        -: 6354:       )
        -: 6355:       ;
   373412: 6356:    nget->sign = nget->length ? (teken & MINUS) : QNUL;
   373412: 6357:    }
        -: 6358:/*
        -: 6359:multiply number with 204586 digits with itself
        -: 6360:New algorithm:   17,13 s
        -: 6361:Old algorithm: 1520,32 s
        -: 6362:
        -: 6363:{?} get$longint&!x*!x:?y&lst$(y,verylongint,NEW)&ok
        -: 6364:
        -: 6365:*/
        -: 6366:#ifndef NDEBUG
        -: 6367:static void pbint(LONG * high,LONG * low)
        -: 6368:    {
        -: 6369:    for(;high <= low;++high)
        -: 6370:        {
        -: 6371:        if(*high)
        -: 6372:            {
        -: 6373:            printf("%ld ",*high);
        -: 6374:            break;
        -: 6375:            }
        -: 6376:        else
        -: 6377:            printf("NUL ");
        -: 6378:        }
        -: 6379:    for(;++high <= low;)
        -: 6380:        {
        -: 6381:        printf("%0*ld ",(int)TEN_LOG_RADIX,*high);
        -: 6382:        }
        -: 6383:    }
        -: 6384:
        -: 6385:static void pbin(ngetal * res)
        -: 6386:    {
        -: 6387:    pbint(res->inumber,res->inumber + res->ilength - 1);
        -: 6388:    }
        -: 6389:
        -: 6390:static void fpbint(FILE * fp,LONG * high,LONG * low)
        -: 6391:    {
        -: 6392:    for(;high <= low;++high)
        -: 6393:        {
        -: 6394:        if(*high)
        -: 6395:            {
        -: 6396:            fprintf(fp,"%ld ",*high);
        -: 6397:            break;
        -: 6398:            }
        -: 6399:        else
        -: 6400:            fprintf(fp,"NUL ");
        -: 6401:        }
        -: 6402:    for(;++high <= low;)
        -: 6403:        {
        -: 6404:        fprintf(fp,"%0*ld ",(int)TEN_LOG_RADIX,*high);
        -: 6405:        }
        -: 6406:    }
        -: 6407:
        -: 6408:static void fpbin(FILE * fp,ngetal * res)
        -: 6409:    {
        -: 6410:    fpbint(fp,res->inumber,res->inumber + res->ilength - 1);
        -: 6411:    }
        -: 6412:
        -: 6413:static void validt(LONG * high,LONG * low)
        -: 6414:    {
        -: 6415:    for(;high <= low;++high)
        -: 6416:        {
        -: 6417:        assert(0 <= *high);
        -: 6418:        assert(*high < RADIX);
        -: 6419:        }
        -: 6420:    }
        -: 6421:
        -: 6422:static void valid(ngetal * res)
        -: 6423:    {
        -: 6424:    validt(res->inumber,res->inumber + res->ilength - 1);
        -: 6425:    }
        -: 6426:#endif
        -: 6427:
    26685: 6428:static void nmaal(ngetal * x,ngetal * y,ngetal * product)
        -: 6429:    {
        -: 6430:    LONG *I1,*I2;
        -: 6431:    LONG *iwyzer,*itussen;
        -: 6432:
        -: 6433:    assert(product->length == 0);
        -: 6434:    assert(product->ilength == 0);
        -: 6435:    assert(product->alloc == 0);
        -: 6436:    assert(product->ialloc == 0);
    26685: 6437:    product->ilength = product->iallocated = x->ilength + y->ilength;
        -: 6438:    assert(product->iallocated > 0);
    26685: 6439:    product->inumber = product->ialloc = (LONG *)bmalloc(__LINE__,sizeof(LONG) * product->iallocated);
        -: 6440:
    26685: 6441:    for(iwyzer = product->inumber;iwyzer < product->inumber + product->ilength;*iwyzer++ = 0)
        -: 6442:        ;
        -: 6443:
    93270: 6444:    for(I1 = x->inumber + x->ilength - 1;I1 >= x->inumber;I1--)
        -: 6445:        {
    66585: 6446:        itussen = --iwyzer; /* pointer to result, starting from LSW. */
        -: 6447:        assert(itussen >= product->inumber);
   243538: 6448:        for(I2 = y->inumber + y->ilength - 1;I2 >= y->inumber;I2--)
        -: 6449:            {
        -: 6450:            LONG prod;
        -: 6451:            LONG *itussen2;
   176953: 6452:            prod = (*I1)*(*I2);
   176953: 6453:            *itussen += prod;
   176953: 6454:            itussen2 = itussen--;
   353906: 6455:            while(*itussen2 >= HEADROOM * RADIX2)
        -: 6456:                {
        -: 6457:                LONG karry;
    #####: 6458:                karry = *itussen2/RADIX;
    #####: 6459:                *itussen2 %= RADIX;
    #####: 6460:                --itussen2;
        -: 6461:                assert(itussen2 >= product->inumber);
    #####: 6462:                *itussen2 += karry;
        -: 6463:                }
        -: 6464:            assert(itussen2 >= product->inumber);
        -: 6465:            }
    66585: 6466:        if(*iwyzer >= RADIX)
        -: 6467:            {
    16353: 6468:            LONG karry = *iwyzer/RADIX;
    16353: 6469:            *iwyzer %= RADIX;
    16353: 6470:            itussen = iwyzer - 1;
        -: 6471:            assert(itussen >= product->inumber);
    16353: 6472:            *itussen += karry;
    32706: 6473:            while(*itussen >= 2000000000)
        -: 6474:                {
    #####: 6475:                karry = *itussen/RADIX;
    #####: 6476:                *itussen %= RADIX;
    #####: 6477:                --itussen;
        -: 6478:                assert(itussen >= product->inumber);
    #####: 6479:                *itussen += karry;
        -: 6480:                }
        -: 6481:            assert(itussen >= product->inumber);
        -: 6482:            }
        -: 6483:        }
   131477: 6484:    while(iwyzer >= product->inumber)
        -: 6485:        {
    78107: 6486:        if(*iwyzer >= RADIX)
        -: 6487:            {
    11257: 6488:            LONG karry = *iwyzer/RADIX;
    11257: 6489:            *iwyzer %= RADIX;
    11257: 6490:            --iwyzer;
        -: 6491:            assert(iwyzer >= product->inumber);
    11257: 6492:            *iwyzer += karry;
        -: 6493:            }
        -: 6494:        else
    66850: 6495:            --iwyzer;
        -: 6496:        }
        -: 6497:
    52398: 6498:    for(iwyzer = product->inumber;product->ilength > 1 && *iwyzer == 0;++iwyzer)
        -: 6499:        {
    25713: 6500:        --(product->ilength);
    25713: 6501:        ++(product->inumber);
        -: 6502:        }
        -: 6503:
        -: 6504:    assert(product->ilength >= 1);
        -: 6505:    assert(product->inumber >= (LONG*)product->ialloc);
        -: 6506:    assert(product->inumber < (LONG*)product->ialloc + product->iallocated);
        -: 6507:    assert(product->inumber + product->ilength <= (LONG*)product->ialloc + product->iallocated);
        -: 6508:
    26685: 6509:    product->sign = product->inumber[0] ? ((x->sign ^ y->sign) & MINUS) : QNUL;
    26685: 6510:    }
        -: 6511:
     7320: 6512:static LONG iopaffinal(LONG *highRemainder,LONG * lowRemainder,LONG carry)
        -: 6513:    {
    23120: 6514:    while(highRemainder <= lowRemainder)
        -: 6515:        {
     8480: 6516:        carry += *lowRemainder;
     8480: 6517:        if(carry >= RADIX)
        -: 6518:            {
        -: 6519:/*
        -: 6520:{?} (10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000/1000000000000000000000000000000000000001
        -: 6521:  + 1/10000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)
        -: 6522:{!} 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001000000000000000000000000000000000000001/10000000000000000000000000000000000000010000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000
        -: 6523:{?} 100000000000000000000000000000000000000000000000/10000000000000000000000001+ 1
        -: 6524:{!} 100000000000000000000010000000000000000000000001/10000000000000000000000001
        -: 6525:*/
    #####: 6526:            *lowRemainder = carry - RADIX;
        -: 6527:            assert(*lowRemainder >= 0);
        -: 6528:            assert(*lowRemainder < RADIX);
    #####: 6529:            carry = 1;
        -: 6530:            }
     8480: 6531:        else if(carry < 0)
        -: 6532:            {
        1: 6533:            *lowRemainder = carry + RADIX;
        -: 6534:            assert(*lowRemainder >= 0);
        -: 6535:            assert(*lowRemainder < RADIX);
        1: 6536:            carry = -1;
        -: 6537:            }
        -: 6538:        else
        -: 6539:            {
     8479: 6540:            *lowRemainder = carry;
        -: 6541:            assert(*lowRemainder >= 0);
        -: 6542:            assert(*lowRemainder < RADIX);
     8479: 6543:            carry = 0;
        -: 6544:            }
     8480: 6545:        --lowRemainder;
        -: 6546:        }
     7320: 6547:    return carry;
        -: 6548:    }
        -: 6549:
        -: 6550:
     1191: 6551:static LONG iop(LONG *highRemainder,LONG *lowRemainder,LONG *highDivisor,LONG *lowDivisor)
        -: 6552:    {
     1191: 6553:    LONG carry = 0;
        -: 6554:    do
        -: 6555:        {
        -: 6556:        assert(lowRemainder >= highRemainder);
    13203: 6557:        carry += (*lowRemainder + *lowDivisor);
    13203: 6558:        if(carry >= RADIX)
        -: 6559:            {
     8994: 6560:            *lowRemainder = carry - RADIX;
        -: 6561:            assert(*lowRemainder >= 0);
        -: 6562:            assert(*lowRemainder < RADIX);
     8994: 6563:            carry = 1;
        -: 6564:            }
        -: 6565:        else
        -: 6566:            {
     4209: 6567:            *lowRemainder = carry;
        -: 6568:            assert(*lowRemainder >= 0);
        -: 6569:            assert(*lowRemainder < RADIX);
     4209: 6570:            carry = 0;
        -: 6571:            }
    13203: 6572:        --lowRemainder;
    13203: 6573:        --lowDivisor;
        -: 6574:        }
    13203: 6575:    while(highDivisor <= lowDivisor );
     1191: 6576:    return iopaffinal(highRemainder,lowRemainder,carry);
        -: 6577:    }
        -: 6578:
     6129: 6579:static LONG iaf( LONG *highRemainder
        -: 6580:              , LONG *lowRemainder
        -: 6581:              , LONG *highDivisor
        -: 6582:              , LONG *lowDivisor
        -: 6583:              , LONG factor
        -: 6584:              )
        -: 6585:    {
     6129: 6586:    LONG carry = 0;
        -: 6587:    do
        -: 6588:        {
        -: 6589:        assert(lowRemainder >= highRemainder);
        -: 6590:        assert(*lowDivisor >= 0);
     6361: 6591:        carry += (*lowRemainder - factor * (*lowDivisor));
     6361: 6592:        if(carry < 0)
        -: 6593:            {
       80: 6594:            LONG f = 1 + ((-carry - 1) / RADIX);
       80: 6595:            *lowRemainder = carry + f*RADIX;
        -: 6596:            assert(*lowRemainder >= 0);
        -: 6597:            assert(*lowRemainder < RADIX);
       80: 6598:            carry = -f;
        -: 6599:            }
        -: 6600:        else
        -: 6601:            {
     6281: 6602:            *lowRemainder = carry;
        -: 6603:            assert(*lowRemainder >= 0);
        -: 6604:            assert(*lowRemainder < RADIX);
     6281: 6605:            carry = 0;
        -: 6606:            }
     6361: 6607:        --lowRemainder;
     6361: 6608:        --lowDivisor;
        -: 6609:        }
     6361: 6610:    while(highDivisor <= lowDivisor );
     6129: 6611:    return iopaffinal(highRemainder,lowRemainder,carry);
        -: 6612:    }
        -: 6613:
   291114: 6614:static LONG iaf2( LONG *highRemainder
        -: 6615:               , LONG *lowRemainder
        -: 6616:               , LONG *highDivisor
        -: 6617:               , LONG *lowDivisor
        -: 6618:               , LONG factor
        -: 6619:               )
        -: 6620:    {
   291114: 6621:    int allzero = TRUE;
   291114: 6622:    LONG carry = 0;
   291114: 6623:    LONG *slowRemainder = lowRemainder;
        -: 6624:    do
        -: 6625:        {
        -: 6626:        assert(highRemainder <= lowRemainder);
        -: 6627:        assert(*lowDivisor >= 0);
  1544246: 6628:        carry += (*lowRemainder - factor * (*lowDivisor));
  1544246: 6629:        if(carry < 0)
        -: 6630:            {
   910816: 6631:            LONG f = 1 + ((-carry - 1) / RADIX);
   910816: 6632:            *lowRemainder = carry + f*RADIX;
        -: 6633:            assert(*lowRemainder >= 0);
        -: 6634:            assert(*lowRemainder < RADIX);
   910816: 6635:            carry = -f;
        -: 6636:            }
        -: 6637:        else
        -: 6638:            {
   633430: 6639:            *lowRemainder = carry;
        -: 6640:            assert(*lowRemainder >= 0);
        -: 6641:            assert(*lowRemainder < RADIX);
   633430: 6642:            carry = 0;
        -: 6643:            }
  1544246: 6644:        if(*lowRemainder)
  1466175: 6645:            allzero = FALSE;
  1544246: 6646:        --lowRemainder;
  1544246: 6647:        --lowDivisor;
        -: 6648:        }
  1544246: 6649:    while(highDivisor <= lowDivisor );
        -: 6650:    assert(highRemainder > lowRemainder);
   291114: 6651:    if(carry == 0)
        -: 6652:        {
        -: 6653:        assert(carry == 0);
        -: 6654:        assert(0 <= *highRemainder);
        -: 6655:        assert(*highRemainder < RADIX);
   288790: 6656:        return *highRemainder == 0 ? (allzero ? 0 : 1) : 1;
        -: 6657:        }
     2324: 6658:    ++lowRemainder;
        -: 6659:    assert(carry != 0);
        -: 6660:    /* negative result */
        -: 6661:    assert(carry < 0);
        -: 6662:        {
        -: 6663:        assert(lowRemainder == highRemainder);
     2324: 6664:        *lowRemainder += carry * RADIX;
        -: 6665:        assert(*lowRemainder < 0);
        -: 6666:        assert(-((HEADROOM + 1)*RADIX) < HEADROOM * *lowRemainder && HEADROOM * *lowRemainder < ((HEADROOM + 1)*RADIX));
     2324: 6667:        lowRemainder = slowRemainder;
     2324: 6668:        carry = 0;
    32946: 6669:        while(lowRemainder >= highRemainder)
        -: 6670:            {
    28298: 6671:            *lowRemainder = carry - *lowRemainder;
    28298: 6672:            if(*lowRemainder < 0)
        -: 6673:                {
    25962: 6674:                *lowRemainder += RADIX;
    25962: 6675:                carry = -1;
        -: 6676:                }
        -: 6677:            else
     2336: 6678:                carry = 0;
        -: 6679:            assert(0 <= *lowRemainder && (*lowRemainder < RADIX || (lowRemainder == highRemainder && HEADROOM * *lowRemainder < ((HEADROOM + 1)*RADIX))));
    28298: 6680:            if(*lowRemainder)
    28227: 6681:                allzero = FALSE;
    28298: 6682:            --lowRemainder;
        -: 6683:            }
        -: 6684:        assert(carry == 0);
        -: 6685:
        -: 6686:        assert(0 <= *++lowRemainder && HEADROOM * *lowRemainder < ((HEADROOM + 1)*RADIX));
     2324: 6687:        if(*lowRemainder == 0)
     2300: 6688:            return allzero ? 0 : -1;
        -: 6689:        else
       24: 6690:            return -1;
        -: 6691:        }
        -: 6692:    }
        -: 6693:
   240728: 6694:static LONG nndeel(ngetal * dividend,ngetal * divisor,ngetal * quotient, ngetal * remainder)
        -: 6695:    {
        -: 6696:    LONG *low,*quot,*head,*oldhead;
        -: 6697:    /* Remainder starts out as copy of dividend. As the division progresses,
        -: 6698:       the leading element of the remainder moves to the right.
        -: 6699:       The movement is interupted if the divisor is greater than the
        -: 6700:       leading elements of the dividend.
        -: 6701:    */
        -: 6702:    LONG divRADIX,divRADIX2; /* leading one or two elements of divisor */
        -: 6703:    assert(!(divisor->sign & QNUL));
        -: 6704:
        -: 6705:    assert(remainder->length == 0);
        -: 6706:    assert(remainder->ilength == 0);
        -: 6707:    assert(remainder->alloc == 0);
        -: 6708:    assert(remainder->ialloc == 0);
        -: 6709:    assert(quotient->length == 0);
        -: 6710:    assert(quotient->ilength == 0);
        -: 6711:    assert(quotient->alloc == 0);
        -: 6712:    assert(quotient->ialloc == 0);
        -: 6713:
   240728: 6714:    remainder->ilength = remainder->iallocated = dividend->sign & QNUL ? 1 : dividend->ilength;
        -: 6715:    assert(remainder->iallocated > 0);
        -: 6716:    assert((LONG)TEN_LOG_RADIX * remainder->ilength >= dividend->length);
   240728: 6717:    remainder->inumber = remainder->ialloc = (LONG *)bmalloc(__LINE__,sizeof(LONG) * remainder->iallocated);
   240728: 6718:    *(remainder->inumber) = 0;
        -: 6719:
   240728: 6720:    if(dividend->ilength == 0)
    #####: 6721:        remainder->inumber[0] = 0;
        -: 6722:    else
   240728: 6723:        memcpy(remainder->inumber,dividend->inumber,dividend->ilength*sizeof(LONG));
        -: 6724:
   240728: 6725:    if(dividend->ilength >= divisor->ilength)
   240675: 6726:        quotient->ilength = quotient->iallocated = 1 + dividend->ilength - divisor->ilength;
        -: 6727:    else
       53: 6728:        quotient->ilength = quotient->iallocated = 1;
        -: 6729:
   240728: 6730:    quotient->inumber = quotient->ialloc = (LONG *)bmalloc(__LINE__,(size_t)(quotient->iallocated)*sizeof(LONG));
   240728: 6731:    memset(quotient->inumber,0,(size_t)(quotient->iallocated)*sizeof(LONG));
   240728: 6732:    quot = quotient->inumber;
        -: 6733:
   240728: 6734:    divRADIX = divisor->inumber[0];
   240728: 6735:    if(divisor->ilength > 1)
        -: 6736:        {
   189401: 6737:        divRADIX2 = RADIX*divisor->inumber[0]+divisor->inumber[1];
        -: 6738:        }
        -: 6739:    else
        -: 6740:        {
    51327: 6741:        divRADIX2 = 0;
        -: 6742:        }
        -: 6743:    assert(divRADIX > 0);
  1043304: 6744:    for( low = remainder->inumber + (size_t)divisor->ilength - 1
   240728: 6745:        ,head = oldhead = remainder->inumber
   561848: 6746:       ; low < remainder->inumber + dividend->ilength
   321120: 6747:       ; ++low,++quot,++head
        -: 6748:       )
        -: 6749:        {
   321120: 6750:        LONG sign = 1;
        -: 6751:        LONG factor;
   321120: 6752:        *quot = 0;
   321120: 6753:        if(head > oldhead)
        -: 6754:            {
    80445: 6755:            *head += RADIX * *oldhead;
    80445: 6756:            *oldhead = 0;
    80445: 6757:            oldhead = head;
        -: 6758:            }
        -: 6759:        do
        -: 6760:            {
        -: 6761:            assert(low < remainder->inumber+remainder->ilength);
        -: 6762:            assert(quot < quotient->inumber+quotient->ilength);
        -: 6763:            assert(sign != 0);
        -: 6764:
        -: 6765:            assert(*head >= 0);
   323395: 6766:            factor = *head / divRADIX;
   323395: 6767:            if(sign == -1 && factor == 0)
     1157: 6768:                ++factor;
        -: 6769:
   323395: 6770:            if(factor == 0)
        -: 6771:                {
    32281: 6772:                break;
        -: 6773:                }
        -: 6774:            else
        -: 6775:                {
        -: 6776:                LONG nsign;
        -: 6777:                assert(factor > 0);
   291114: 6778:                if(divRADIX2)
        -: 6779:                    {
        -: 6780:                    assert(head + 1 <= low);
   193833: 6781:                    if(head[0] < HEADROOM * RADIX)
        -: 6782:                        {
   191661: 6783:                        factor = (RADIX * head[0] + head[1]) / divRADIX2;
   191661: 6784:                        if(/*direction*/ sign == -1 && factor == 0)
     1157: 6785:                            ++factor;
        -: 6786:                        }
        -: 6787:                    }
        -: 6788:                /*
        -: 6789:                div$(20999900000000,2099990001) -> factor 10499 
        -: 6790:                    (RADIX 4 HEADROOM 20)
        -: 6791:                div$(2999000000,2999001)        -> factor 1499
        -: 6792:                    (RADIX 3 HEADROOM 2)
        -: 6793:                */
        -: 6794:                assert(factor * HEADROOM < RADIX * (HEADROOM + 1));
   291114: 6795:                *quot += sign * factor;
        -: 6796:                assert(0 <= *quot);
        -: 6797:                /*assert(*quot < RADIX);*/
   291114: 6798:                nsign = iaf2( head
        -: 6799:                            , low
        -: 6800:                            , divisor->inumber
   291114: 6801:                            , divisor->inumber + divisor->ilength - 1
        -: 6802:                            , factor
        -: 6803:                            );
        -: 6804:                assert(*head >= 0);
        -: 6805:                assert(sign != 0);
   291114: 6806:                if(nsign < 0)
     2324: 6807:                    sign = -sign;
   288790: 6808:                else if(nsign == 0)
    52513: 6809:                    sign = 0;
        -: 6810:                }
        -: 6811:            }
   291114: 6812:        while(sign < 0);
        -: 6813:/*
        -: 6814:checkBounds(remainder->ialloc);
        -: 6815:checkBounds(quotient->ialloc);
        -: 6816:checkBounds(remainder->ialloc);
        -: 6817:checkBounds(quotient->ialloc);
        -: 6818:*/
        -: 6819:        assert(*quot < RADIX);
        -: 6820:        }
        -: 6821:/*
        -: 6822:checkBounds(remainder->ialloc);
        -: 6823:checkBounds(quotient->ialloc);
        -: 6824:*/
   346673: 6825:    for(low = remainder->inumber;remainder->ilength > 1 && *low == 0;++low)
        -: 6826:        {
   105945: 6827:        --(remainder->ilength);
   105945: 6828:        ++(remainder->inumber);
        -: 6829:        }
        -: 6830:
        -: 6831:    assert(remainder->ilength >= 1);
        -: 6832:    assert(remainder->inumber >= (LONG*)remainder->ialloc);
        -: 6833:    assert(remainder->inumber < (LONG*)remainder->ialloc + remainder->iallocated);
        -: 6834:    assert(remainder->inumber + remainder->ilength <= (LONG*)remainder->ialloc + remainder->iallocated);
        -: 6835:
   268117: 6836:    for(low = quotient->inumber;quotient->ilength > 1 && *low == 0;++low)
        -: 6837:        {
    27389: 6838:        --(quotient->ilength);
    27389: 6839:        ++(quotient->inumber);
        -: 6840:        }
        -: 6841:
        -: 6842:    assert(quotient->ilength >= 1);
        -: 6843:    assert(quotient->inumber >= (LONG*)quotient->ialloc);
        -: 6844:    assert(quotient->inumber < (LONG*)quotient->ialloc + quotient->iallocated);
        -: 6845:    assert(quotient->inumber + quotient->ilength <= (LONG*)quotient->ialloc + quotient->iallocated);
   240728: 6846:    remainder->sign = remainder->inumber[0] ? ((dividend->sign ^ divisor->sign) & MINUS) : QNUL;
   240728: 6847:    quotient->sign = quotient->inumber[0] ? ((dividend->sign ^ divisor->sign) & MINUS) : QNUL;
        -: 6848:    /*
        -: 6849:    checkBounds(remainder->ialloc);
        -: 6850:    checkBounds(quotient->ialloc);
        -: 6851:    */
   240728: 6852:    return TRUE;
        -: 6853:    }
        -: 6854:
        -: 6855:
     8925: 6856:static Qgetal nn2q(ngetal * num,ngetal * den)
        -: 6857:    {
        -: 6858:    Qgetal res;
        -: 6859:
     8925: 6860:    if(num->sign & QNUL)
    #####: 6861:        return copievan(&nulk);
     8925: 6862:    else if(den->sign & QNUL)
    #####: 6863:        return not_a_number();
        -: 6864:    
     8925: 6865:    num->sign ^= (den->sign & MINUS);
        -: 6866:
     8925: 6867:    if(den->ilength == 1 && den->inumber[0] == 1)
        -: 6868:        {
      395: 6869:        res = inumberNode(num);
        -: 6870:        }
        -: 6871:    else
        -: 6872:        {
        -: 6873:        char * endp;
     8530: 6874:        size_t len = offsetof(sk,u.obj) + 2 + numlength(num) + numlength(den);
     8530: 6875:        res = (psk)bmalloc(__LINE__,len);
     8530: 6876:        endp = iconvert2decimal(num,(char *)POBJ(res));
     8530: 6877:        *endp++ = '/';
     8530: 6878:        endp = iconvert2decimal(den,endp);
        -: 6879:        assert(endp - (char *)res <= len);
     8530: 6880:        res->v.fl = READY | SUCCESS | QGETAL | QBREUK;
     8530: 6881:        res->ops |= num->sign;
        -: 6882:        }
     8925: 6883:    return res;
        -: 6884:    }
        -: 6885:
     9453: 6886:static Qgetal _qndeel(ngetal * x,ngetal * y)
        -: 6887:    {
        -: 6888:    Qgetal res;
     9453: 6889:    ngetal gcd = {0},hrem = {0};
     9453: 6890:    ngetal quotientx = {0},remainderx = {0};
     9453: 6891:    ngetal quotienty = {0},remaindery = {0};
        -: 6892:
        -: 6893:#ifndef NDEBUG
        -: 6894:    valid(x);
        -: 6895:    valid(y);
        -: 6896:#endif
     9453: 6897:    if(x->sign & QNUL)
      525: 6898:        return copievan(&nulk);
     8928: 6899:    else if(y->sign & QNUL)
        3: 6900:        return not_a_number();
        -: 6901:
     8925: 6902:    gcd = *x;
     8925: 6903:    gcd.alloc = NULL;
     8925: 6904:    gcd.ialloc = NULL;
     8925: 6905:    hrem = *y;
     8925: 6906:    hrem.alloc = NULL;
     8925: 6907:    hrem.ialloc = NULL;
        -: 6908:    do
        -: 6909:        {
   222747: 6910:        nndeel(&gcd,&hrem,&quotientx,&remainderx);
        -: 6911:#ifndef NDEBUG
        -: 6912:        valid(&gcd);
        -: 6913:        valid(&hrem);
        -: 6914:        valid(&quotientx);
        -: 6915:        valid(&remainderx);
        -: 6916:#endif
   222747: 6917:        if(gcd.ialloc)
        -: 6918:            {
   205292: 6919:            bfree(gcd.ialloc);
        -: 6920:            }
   222747: 6921:        gcd = hrem;
   222747: 6922:        hrem = remainderx;
   222747: 6923:        remainderx.alloc = 0;
   222747: 6924:        remainderx.length = 0;
   222747: 6925:        bfree(quotientx.ialloc);
   222747: 6926:        remainderx.ialloc = 0;
   222747: 6927:        remainderx.ilength = 0;
   222747: 6928:        quotientx.ialloc = 0;
   222747: 6929:        quotientx.alloc = 0;
   222747: 6930:        quotientx.ilength = 0;
   222747: 6931:        quotientx.length = 0;
        -: 6932:        }
   222747: 6933:    while(!(hrem.sign & QNUL));
        -: 6934:
     8925: 6935:    if(hrem.ialloc)
     8925: 6936:        bfree(hrem.ialloc);
        -: 6937:
     8925: 6938:    nndeel(x,&gcd,&quotientx,&remainderx);
        -: 6939:#ifndef NDEBUG
        -: 6940:        valid(&gcd);
        -: 6941:        valid(x);
        -: 6942:        valid(&quotientx);
        -: 6943:        valid(&remainderx);
        -: 6944:#endif
     8925: 6945:    bfree(remainderx.ialloc);
     8925: 6946:    nndeel(y,&gcd,&quotienty,&remaindery);
        -: 6947:#ifndef NDEBUG
        -: 6948:        valid(&gcd);
        -: 6949:        valid(y);
        -: 6950:        valid(&quotienty);
        -: 6951:        valid(&remaindery);
        -: 6952:#endif
     8925: 6953:    bfree(remaindery.ialloc);
        -: 6954:
     8925: 6955:    if(gcd.ialloc)
     8530: 6956:        bfree(gcd.ialloc);
     8925: 6957:    res = nn2q(&quotientx,&quotienty);
     8925: 6958:    bfree(quotientx.ialloc);
     8925: 6959:    bfree(quotienty.ialloc);
     8925: 6960:    return res;
        -: 6961:    }
        -: 6962:
        -: 6963:
   373412: 6964:static ngetal nplus(ngetal * x,ngetal * y)
        -: 6965:    {
   373412: 6966:    ngetal res = {0};
        -: 6967:    char *hres;
        -: 6968:    ptrdiff_t xgrotery;
   373412: 6969:    res.length = 1+(x->length > y->length ? x->length : y->length);
   373412: 6970:    res.allocated = (size_t)res.length + offsetof(sk,u.obj);/*sizeof(tFlags);*/
   373412: 6971:    res.alloc = res.number = (char *)bmalloc(__LINE__,res.allocated);
   373412: 6972:    *res.number = '0';
   373412: 6973:    hres = res.number+(size_t)res.length - 1;
   373412: 6974:    if(x->length == y->length)
    21689: 6975:        xgrotery = strncmp(x->number,y->number,(size_t)res.length);
        -: 6976:    else
   351723: 6977:        xgrotery = x->length - y->length;
   373412: 6978:    if(xgrotery < 0)
        -: 6979:        {
    22238: 6980:        ngetal * hget = x;
    22238: 6981:        x = y;
    22238: 6982:        y = hget;
        -: 6983:        }
   373412: 6984:    if(x->sign == y->sign)
        -: 6985:        {
    11590: 6986:        if(op(&hres,x->number,x->number + x->length - 1,y->number,y->number + y->length - 1))
       69: 6987:            *--hres = '1';
        -: 6988:        }
        -: 6989:    else
   361822: 6990:        af(&hres,x->number,x->number + x->length - 1,y->number,y->number + y->length - 1);
   373412: 6991:    skipnullen(&res,x->sign);
   373412: 6992:    return res;
        -: 6993:    }
        -: 6994:
     7320: 6995:static void inplus(ngetal * x,ngetal * y,ngetal * som)
        -: 6996:    {
        -: 6997:    LONG * hres, * px, * py, * ex;
        -: 6998:    ptrdiff_t xgrotery;
        -: 6999:
     7320: 7000:    som->ilength = 1+(x->ilength > y->ilength ? x->ilength : y->ilength);
     7320: 7001:    som->iallocated = som->ilength;
     7320: 7002:    som->ialloc = som->inumber = (LONG *)bmalloc(__LINE__,sizeof(LONG)*som->iallocated);
     7320: 7003:    *som->inumber = 0;
     7320: 7004:    hres = som->inumber + som->ilength;
        -: 7005:
     7320: 7006:    if(x->ilength == y->ilength)
        -: 7007:        {
     6263: 7008:        px = x->inumber;
     6263: 7009:        ex = px + x->ilength;
     6263: 7010:        py = y->inumber;
        -: 7011:        do
        -: 7012:            {
     6308: 7013:            xgrotery = *px++ - *py++;
        -: 7014:            }
     6308: 7015:        while(!xgrotery && px < ex);
        -: 7016:        }
        -: 7017:    else
     1057: 7018:        xgrotery = x->ilength - y->ilength;
     7320: 7019:    if(xgrotery < 0)
        -: 7020:        {
     3398: 7021:        ngetal * hget = x;
     3398: 7022:        x = y;
     3398: 7023:        y = hget;
        -: 7024:        }
        -: 7025:
    35364: 7026:    for(px = x->inumber + x->ilength;px > x->inumber;)
    20724: 7027:        *--hres = *--px;
     7320: 7028:    if(x->sign == y->sign)
        -: 7029:        {
        -: 7030:#ifndef NDEBUG
        -: 7031:        LONG carry = 
        -: 7032:#endif
     1191: 7033:            iop(som->inumber,som->inumber + som->ilength - 1,y->inumber,y->inumber + y->ilength - 1);
        -: 7034:        assert(carry == 0);
        -: 7035:        }
        -: 7036:    else
        -: 7037:        {
     6129: 7038:        iaf(som->inumber,som->inumber + som->ilength - 1,y->inumber,y->inumber + y->ilength - 1,1);
        -: 7039:        }
    14685: 7040:    for(hres = som->inumber;som->ilength > 1 && *hres == 0;++hres)
        -: 7041:        {
     7365: 7042:        --(som->ilength);
     7365: 7043:        ++(som->inumber);
        -: 7044:        }
        -: 7045:
     7320: 7046:    som->sign = som->inumber[0] ? (x->sign & MINUS) : QNUL;
     7320: 7047:    }
        -: 7048:
   380732: 7049:static Qgetal _qplus(Qgetal _qx,Qgetal _qy,int minus)
        -: 7050:    {
   380732: 7051:    ngetal xt = {0},xn = {0},yt = {0},yn = {0};
        -: 7052:    
        -: 7053:    char *xb,*yb;
   380732: 7054:    xb = splits(_qx,&xt,&xn);
   380732: 7055:    yb = splits(_qy,&yt,&yn);
   380732: 7056:    yt.sign ^= minus;
        -: 7057:
   380732: 7058:    if(!xb && !yb)
        -: 7059:        {
   373412: 7060:        ngetal g = nplus(&xt,&yt);
   373412: 7061:        psk res = numberNode2(&g);
   373412: 7062:        return res;
        -: 7063:        }
        -: 7064:    else
        -: 7065:        {
     7320: 7066:        ngetal pa = {0},pb = {0},som = {0};
        -: 7067:        Qgetal res;
     7320: 7068:        convert2binary(&xt);
     7320: 7069:        convert2binary(&xn);
     7320: 7070:        convert2binary(&yt);
     7320: 7071:        convert2binary(&yn);
     7320: 7072:        nmaal(&xt,&yn,&pa);
     7320: 7073:        nmaal(&yt,&xn,&pb);
     7320: 7074:        inplus(&pa,&pb,&som);
     7320: 7075:        bfree(pa.ialloc);
     7320: 7076:        bfree(pb.ialloc);
     7320: 7077:        pa.ilength = 0;
     7320: 7078:        pa.ialloc = 0;
     7320: 7079:        pa.length = 0;
     7320: 7080:        pa.alloc = 0;
     7320: 7081:        nmaal(&xn,&yn,&pa);
     7320: 7082:        res = _qndeel(&som,&pa);
     7320: 7083:        if(som.ialloc)
     7320: 7084:            bfree(som.ialloc);
     7320: 7085:        bfree(pa.ialloc);
     7320: 7086:        bfree(xt.ialloc);
     7320: 7087:        bfree(xn.ialloc);
     7320: 7088:        bfree(yt.ialloc);
     7320: 7089:        bfree(yn.ialloc);
     7320: 7090:        return res;
        -: 7091:        }
        -: 7092:    }
        -: 7093:
        -: 7094:#if 1
        -: 7095:/*
        -: 7096:
        -: 7097:{?} 0:?n&whl'(1+!n:<1000:?n&5726597846592437657823456/67678346259784659237457297*5364523564325982435082458045728395/543895704328725085743289570+1:?T)&!T
        -: 7098:{!} 62694910002908910202610946081623305253537463604246972909/75122371034222274084834066940872899586533484041821
        -: 7099:    S   0,98 sec  (16500.31292.1022)
        -: 7100:
        -: 7101:    
        -: 7102:70
        -: 7103:1,71*10E0 s Loop implemented as circular datastructure.
        -: 7104:1,79*10E0 s Loop implemented with variable name evaluation.
        -: 7105:1,85*10E0 s Loop implemented with member name evaluation
        -: 7106:1,49*10E0 s Loop implemented with whl built-in function
        -: 7107:80
        -: 7108:210
        -: 7109:Done. No errors. See valid.txt
        -: 7110:ok
        -: 7111:{!} ok
        -: 7112:    S   7,29 sec  (16497.31239.1022)
        -: 7113:*/
        -: 7114:
     2026: 7115:static Qgetal _qdema(ngetal * x1,ngetal * x2,ngetal * y1,ngetal * y2)
        -: 7116:    {
     2026: 7117:    ngetal pa = {0},pb = {0};
        -: 7118:    Qgetal res;
        -: 7119:    
     2026: 7120:    nmaal(x1,y1,&pa);
     2026: 7121:    nmaal(x2,y2,&pb);
     2026: 7122:    res = _qndeel(&pa,&pb);
     2026: 7123:    bfree(pa.ialloc);
     2026: 7124:    bfree(pb.ialloc);
     2026: 7125:    return(res);
        -: 7126:    }
        -: 7127:#else
        -: 7128:/*
        -: 7129:{?} 0:?n&whl'(1+!n:<1000:?n&707957265978333334659243765782345642321377768009873333/676799876699834625978465923745729787673565217476876234*536452356432598243508245804572839536543879878347777777/113555480476987659789060958543895703333333333333333333+1:?T)&!T
        -: 7130:{!} 62694910002908910202610946081623305253537463604246972909/75122371034222274084834066940872899586533484041821
        -: 7131:    S   1,03 sec  (1437.1463.2)
        -: 7132:
        -: 7133:
        -: 7134:70
        -: 7135:1,69*10E0 s Loop implemented as circular datastructure.
        -: 7136:1,76*10E0 s Loop implemented with variable name evaluation.
        -: 7137:1,87*10E0 s Loop implemented with member name evaluation
        -: 7138:1,45*10E0 s Loop implemented with whl built-in function
        -: 7139:80
        -: 7140:210
        -: 7141:Done. No errors. See valid.txt
        -: 7142:ok
        -: 7143:{!} ok
        -: 7144:    S   7,32 sec  (16497.31239.1022)
        -: 7145:
        -: 7146:70
        -: 7147:1,82*10E0 s Loop implemented as circular datastructure.
        -: 7148:2,06*10E0 s Loop implemented with variable name evaluation.
        -: 7149:1,89*10E0 s Loop implemented with member name evaluation
        -: 7150:1,45*10E0 s Loop implemented with whl built-in function
        -: 7151:80
        -: 7152:210
        -: 7153:Done. No errors. See valid.txt
        -: 7154:ok
        -: 7155:{!} ok
        -: 7156:    S   7,89 sec  (16497.31292.1022)
        -: 7157:
        -: 7158:70
        -: 7159:1,68*10E0 s Loop implemented as circular datastructure.
        -: 7160:1,79*10E0 s Loop implemented with variable name evaluation.
        -: 7161:1,90*10E0 s Loop implemented with member name evaluation
        -: 7162:1,45*10E0 s Loop implemented with whl built-in function
        -: 7163:80
        -: 7164:210
        -: 7165:Done. No errors. See valid.txt
        -: 7166:ok
        -: 7167:{!} ok
        -: 7168:    S   7,26 sec  (16497.31292.1022)
        -: 7169:*/
        -: 7170:
        -: 7171:static Qgetal _qdema2(ngetal * x1,ngetal * x2,ngetal * y1,ngetal * y2)
        -: 7172:    {
        -: 7173:    ngetal pa = {0},pb = {0};
        -: 7174:    Qgetal res;
        -: 7175:    nmaal(x1,y1,&pa);
        -: 7176:    nmaal(x2,y2,&pb);
        -: 7177:    res = nn2q(&pa,&pb);
        -: 7178:    bfree(pa.alloc);
        -: 7179:    bfree(pb.alloc);
        -: 7180:    return(res);
        -: 7181:    }
        -: 7182:
        -: 7183:static Qgetal _qmaal2(Qgetal _qx,Qgetal _qy)
        -: 7184:    {
        -: 7185:    ngetal xt = {0},xn = {0},yt = {0},yn = {0};
        -: 7186:    char *xb,*yb;
        -: 7187:    xb = splits(_qx,&xt,&xn);
        -: 7188:    yb = splits(_qy,&yt,&yn);
        -: 7189:    if(!xb && !yb)
        -: 7190:        {
        -: 7191:        ngetal g = {0};
        -: 7192:        nmaal(&xt,&yt,&g);
        -: 7193:        psk res = numberNode2(&g);
        -: 7194:        return res;
        -: 7195:        }
        -: 7196:    else
        -: 7197:        {
        -: 7198:        Qgetal res;
        -: 7199:        res = _qdema2(&xt,&xn,&yt,&yn);
        -: 7200:        return res;
        -: 7201:        }
        -: 7202:    }
        -: 7203:
        -: 7204:static int _nndeel(ngetal * x,ngetal * y)
        -: 7205:    {
        -: 7206:    division resx,resy;
        -: 7207:    ngetal gcd = {0},hrem = {0};
        -: 7208:
        -: 7209:    if(x->sign & QNUL)
        -: 7210:        return 0; /* zero */
        -: 7211:    else if(y->sign & QNUL)
        -: 7212:        return -1; /* not a number */
        -: 7213:
        -: 7214:    gcd = *x;
        -: 7215:    gcd.alloc = NULL;
        -: 7216:    hrem = *y;
        -: 7217:    hrem.alloc = NULL;
        -: 7218:    do
        -: 7219:        {
        -: 7220:        nndeel(&gcd,&hrem,&resx);
        -: 7221:        if(gcd.alloc)
        -: 7222:            bfree(gcd.alloc);
        -: 7223:        gcd = hrem;
        -: 7224:        hrem = resx.remainder;
        -: 7225:        bfree(resx.quotient.alloc);
        -: 7226:        }
        -: 7227:    while(!(hrem.sign & QNUL));
        -: 7228:
        -: 7229:    if(hrem.alloc)
        -: 7230:        bfree(hrem.alloc);
        -: 7231:
        -: 7232:    nndeel(x,&gcd,&resx);
        -: 7233:    bfree(resx.remainder.alloc);
        -: 7234:
        -: 7235:    nndeel(y,&gcd,&resy);
        -: 7236:    bfree(resy.remainder.alloc);
        -: 7237:    if(gcd.alloc)
        -: 7238:        bfree(gcd.alloc);
        -: 7239:    if(x->alloc)
        -: 7240:        bfree(x->alloc);
        -: 7241:    if(y->alloc)
        -: 7242:        bfree(y->alloc);
        -: 7243:    *x = resx.quotient;
        -: 7244:    *y = resy.quotient;
        -: 7245:    return 2; /* */
        -: 7246:    }
        -: 7247:
        -: 7248:/*Meant to be a faster multiplication of rational numbers
        -: 7249:Assuming that the two numbers are reduced, we only need to
        -: 7250:reduce the numerators with the denominators of the other
        -: 7251:number. Numerators and denominators may get smaller, speeding
        -: 7252:up the following multiplication.
        -: 7253:*/
        -: 7254:static Qgetal _qdema(ngetal * x1,ngetal * x2,ngetal * y1,ngetal * y2)
        -: 7255:    {
        -: 7256:    Qgetal res;
        -: 7257:    ngetal z1 = {0},z2 = {0};
        -: 7258:    _nndeel(x1,y2);
        -: 7259:    _nndeel(y1,x2);
        -: 7260:    _nndeel(x1,x2);
        -: 7261:    _nndeel(y1,y2);
        -: 7262:    nmaal(x1,y1,&z1);
        -: 7263:    nmaal(x2,y2,&z2);
        -: 7264:    if(x1->alloc) bfree(x1->alloc);
        -: 7265:    if(x2->alloc) bfree(x2->alloc);
        -: 7266:    if(y1->alloc) bfree(y1->alloc);
        -: 7267:    if(y2->alloc) bfree(y2->alloc);
        -: 7268:    res = nn2q(&z1,&z2);
        -: 7269:    if(z1.alloc) bfree(z1.alloc);
        -: 7270:    if(z2.alloc) bfree(z2.alloc);
        -: 7271:    return res;
        -: 7272:    }
        -: 7273:#endif
        -: 7274:
     2305: 7275:static Qgetal _qmaal(Qgetal _qx,Qgetal _qy)
        -: 7276:    {
        -: 7277:    Qgetal res;
     2305: 7278:    ngetal xt = {0},xn = {0},yt = {0},yn = {0};
        -: 7279:    char *xb,*yb;
        -: 7280:    
     2305: 7281:    xb = isplits(_qx,&xt,&xn);
     2305: 7282:    yb = isplits(_qy,&yt,&yn);
     2305: 7283:    if(!xb && !yb)
        -: 7284:        {
      411: 7285:        ngetal g = {0};
      411: 7286:        nmaal(&xt,&yt,&g);
      411: 7287:        bfree(xt.ialloc);
      411: 7288:        bfree(xn.ialloc);
      411: 7289:        bfree(yt.ialloc);
      411: 7290:        bfree(yn.ialloc);
      411: 7291:        res = inumberNode(&g);
      411: 7292:        bfree(g.ialloc);
      411: 7293:        return res;
        -: 7294:        }
        -: 7295:    else
        -: 7296:        {
     1894: 7297:        res = _qdema(&xt,&xn,&yt,&yn);
     1894: 7298:        bfree(xt.ialloc);
     1894: 7299:        bfree(xn.ialloc);
     1894: 7300:        bfree(yt.ialloc);
     1894: 7301:        bfree(yn.ialloc);
     1894: 7302:        return res;
        -: 7303:        }
        -: 7304:    }
        -: 7305:
      239: 7306:static Qgetal _q_qdeel(Qgetal _qx,Qgetal _qy)
        -: 7307:    {
      239: 7308:    ngetal xt = {0},xn = {0},yt = {0},yn = {0};
        -: 7309:    char *xb,*yb;
        -: 7310:    
      239: 7311:    xb = isplits(_qx,&xt,&xn);
      239: 7312:    yb = isplits(_qy,&yt,&yn);
      239: 7313:    if(!xb && !yb)
        -: 7314:        {
      107: 7315:        Qgetal res = _qndeel(&xt,&yt);
      107: 7316:        bfree(xt.ialloc);
      107: 7317:        bfree(xn.ialloc);
      107: 7318:        bfree(yt.ialloc);
      107: 7319:        bfree(yn.ialloc);
      107: 7320:        return res;
        -: 7321:        }
        -: 7322:    else
        -: 7323:        {
        -: 7324:        Qgetal res;
      132: 7325:        res = _qdema(&xt,&xn,&yn,&yt);
      132: 7326:        bfree(xt.ialloc);
      132: 7327:        bfree(xn.ialloc);
      132: 7328:        bfree(yt.ialloc);
      132: 7329:        bfree(yn.ialloc);
      132: 7330:        return res;
        -: 7331:        }
        -: 7332:    }
        -: 7333:
        -: 7334:
      131: 7335:static Qgetal _qheeldeel(Qgetal _qx,Qgetal _qy)
        -: 7336:    {
        -: 7337:    Qgetal res,hulp;
      131: 7338:    ngetal xt = {0},xn = {0},yt = {0},yn = {0},p1 = {0},p2 = {0},quotient = {0},remainder = {0};
        -: 7339:
      131: 7340:    isplits(_qx,&xt,&xn);
      131: 7341:    isplits(_qy,&yt,&yn);
        -: 7342:
      131: 7343:    nmaal(&xt,&yn,&p1);
      131: 7344:    nmaal(&xn,&yt,&p2);
      131: 7345:    nndeel(&p1,&p2,&quotient,&remainder);
      131: 7346:    bfree(p1.ialloc);
      131: 7347:    bfree(p2.ialloc);
      262: 7348:    res = _qplus
      135: 7349:        (      (remainder.sign & QNUL)
       80: 7350:            || !(_qx->ops & MINUS)
        -: 7351:          ? &nulk
       80: 7352:          :   (_qy->ops & MINUS)
        -: 7353:            ? &eenk
        4: 7354:            : &mineenk
        -: 7355:            , (hulp = inumberNode(&quotient))
        -: 7356:        , 0
        -: 7357:        );
      131: 7358:    pskfree(hulp);
      131: 7359:    bfree(quotient.ialloc);
      131: 7360:    bfree(remainder.ialloc);
      131: 7361:    bfree(xt.ialloc);
      131: 7362:    bfree(xn.ialloc);
      131: 7363:    bfree(yt.ialloc);
      131: 7364:    bfree(yn.ialloc);
      131: 7365:    return res;
        -: 7366:    }
        -: 7367:
       70: 7368:static Qgetal _qmodulo(Qgetal _qx,Qgetal _qy)
        -: 7369:    {
        -: 7370:    Qgetal res,_q2,_q3;
        -: 7371:    
       70: 7372:    _q2 = _qheeldeel(_qx,_qy);
       70: 7373:    _q3 = _qmaal(_qy,_q2);
       70: 7374:    pskfree(_q2);
       70: 7375:    res = _qplus(_qx,_q3,MINUS);
       70: 7376:    pskfree(_q3);
       70: 7377:    return res;
        -: 7378:    }
        -: 7379:
      213: 7380:static Qgetal _qdenominator(Qgetal _qx)
        -: 7381:    {
      213: 7382:    ngetal xt = {0},xn = {0};
      213: 7383:    splits(_qx,&xt,&xn);
      213: 7384:    return numberNode(&xn);
        -: 7385:    }
        -: 7386:
   199573: 7387:static int _qvergelijk(Qgetal _qx,Qgetal _qy)
        -: 7388:    {
        -: 7389:    Qgetal som;
        -: 7390:    int res;
   199573: 7391:    som = _qplus(_qx,_qy,MINUS);
   199573: 7392:    res = som->ops & (MINUS|QNUL);
   199573: 7393:    pskfree(som);
   199573: 7394:    return res;
        -: 7395:    }
        -: 7396:
        -: 7397:static int vgl(psk kn1,psk kn2);
        -: 7398:
       60: 7399:static int vglsub(psk kn1,psk kn2)
        -: 7400:    {
        -: 7401:    int ret;
       60: 7402:    psk kn = NULL;
       60: 7403:    adr[1] = kn1;
       60: 7404:    kn = opb(kn,"1+\1+-1)",NULL);
       60: 7405:    kn = eval(kn);
       60: 7406:    ret = vgl(kn,kn2);
       60: 7407:    wis(kn);
       60: 7408:    return ret;
        -: 7409:    }
        -: 7410:
    40774: 7411:static int vgl(psk kn1,psk kn2)
        -: 7412:    {
        -: 7413:    DBGSRC(Printf("vgl(");result(kn1);Printf(",");result(kn2);Printf(")\n");)
    89065: 7414:    while(kn1 != kn2)
        -: 7415:        {
        -: 7416:        int r;
    42208: 7417:        if(is_op(kn1))
        -: 7418:            {
    16875: 7419:            if(is_op(kn2))
        -: 7420:                {
    15394: 7421:                r = (int)kop(kn2) - (int)kop(kn1);
    15394: 7422:                if(r)
        -: 7423:                    {
        -: 7424:                    /* 20080911 */ /*{?} x^(y*(a+b))+-1*x^(a*y+b*y) => 0 */ /*{!} 0 */
     1073: 7425:                    if(  kop(kn1) == MAAL
      499: 7426:                      && kop(kn2) == PLUS
      295: 7427:                      && is_op(kn1->RIGHT)
      218: 7428:                      && kop(kn1->RIGHT) == PLUS
        -: 7429:                      )
        -: 7430:                        {
       25: 7431:                        return vglsub(kn1,kn2);
        -: 7432:                        }
     1048: 7433:                    else if(  kop(kn2) == MAAL
      504: 7434:                      && kop(kn1) == PLUS
       87: 7435:                      && is_op(kn2->RIGHT)
       76: 7436:                      && kop(kn2->RIGHT) == PLUS
        -: 7437:                      )
        -: 7438:                        {
        -: 7439:                        /* 20111030 */
        -: 7440:                        /*{?} a^(b*d+c*d) * (a^(b*f+c*f)+a^(e*b+e*c)) + -1*(a^((b+c)*(d+e))+a^((b+c)*(d+f))) => 0 */
       35: 7441:                        return -vglsub(kn2,kn1);
        -: 7442:                        }
     1013: 7443:                    return r;
        -: 7444:                    }
    14321: 7445:                r = vgl(kn1->LEFT,kn2->LEFT);
    14321: 7446:                if(r)
     6804: 7447:                    return r;
     7517: 7448:                kn1 = kn1->RIGHT;
     7517: 7449:                kn2 = kn2->RIGHT;
        -: 7450:                }
        -: 7451:            else
     1481: 7452:                return 1;
        -: 7453:            }
    25333: 7454:        else if(is_op(kn2))
     5664: 7455:            return -1;
    19669: 7456:        else if(RATIONAAL_COMP(kn1))
        -: 7457:            {
     5021: 7458:            if(RATIONAAL_COMP(kn2))
        -: 7459:                {
     1560: 7460:                switch(_qvergelijk(kn1,kn2))
        -: 7461:                    {
      613: 7462:                    case MINUS: return -1;
        -: 7463:                    case QNUL:
        -: 7464:                        {
      829: 7465:                        return 0;
        -: 7466:                        }
      118: 7467:                    default: return 1;
        -: 7468:                    }
        -: 7469:                }
        -: 7470:            else
     3461: 7471:                return -1; /*20120204*/
        -: 7472:            }
    14648: 7473:        else if(RATIONAAL_COMP(kn2))
        -: 7474:            {
      700: 7475:            return 1; /*20120204*/
        -: 7476:            }
        -: 7477:        else
    27896: 7478:            return (r = HAS_MINUS_SIGN(kn1) - HAS_MINUS_SIGN(kn2)) == 0
    13792: 7479:                    ? strcmp((char *)POBJ(kn1),(char *)POBJ(kn2))
    27740: 7480:                    : r;
        -: 7481:        }
     6083: 7482:    return 0;
        -: 7483:    }
        -: 7484:
        -: 7485:/*
        -: 7486:name must be atom or <atom>.<atom>.<atom>...
        -: 7487:*/
       69: 7488:static int setmember(psk name,psk tree,psk nieuw)
        -: 7489:    {
      176: 7490:    while(is_op(tree))
        -: 7491:        {
       81: 7492:        if(kop(tree) == WORDT)
        -: 7493:            {
        -: 7494:            psk nname;
       36: 7495:            if(kop(name) == DOT)
        6: 7496:                nname = name->LEFT;
        -: 7497:            else
       30: 7498:                nname = name;
       36: 7499:            if(vgl(tree->LEFT,nname))
        -: 7500:                {
        6: 7501:                return FALSE;
        -: 7502:                }
       30: 7503:            else if(nname == name)
        -: 7504:                {
       24: 7505:                wis(tree->RIGHT);
       24: 7506:                tree->RIGHT = zelfde_als_w(nieuw);
       24: 7507:                return TRUE;
        -: 7508:                }
        -: 7509:            else /* Found partial match for member name,
        -: 7510:                    recurse in both name and member */
        -: 7511:                {
        6: 7512:                name = name->RIGHT;
        -: 7513:                }
        -: 7514:            }
       45: 7515:        else if(setmember(name,tree->LEFT,nieuw))
        -: 7516:            {
       13: 7517:            return TRUE;
        -: 7518:            }
       38: 7519:        tree = tree->RIGHT;
        -: 7520:        }
       26: 7521:    return FALSE;
        -: 7522:    }
        -: 7523:
       28: 7524:static int update(psk name,psk pknoop) /* name = tree with DOT in root */
        -: 7525:/*
        -: 7526:    x:?(k.b)
        -: 7527:    x:?((=(a=) (b=)).b)
        -: 7528:*/
        -: 7529:    {
        -: 7530:    vars * navar;
        -: 7531:    vars * voorvar;
       28: 7532:    if(is_op(name->LEFT))
        -: 7533:        {
        3: 7534:        if(kop(name->LEFT) == WORDT)
        -: 7535:            /*{?} x:?((=(a=) (b=)).b) => x */
        -: 7536:            /*          ^              */
        2: 7537:            return setmember(name->RIGHT,name->LEFT->RIGHT,pknoop);
        -: 7538:        else
        -: 7539:            {
        -: 7540:            /*{?} b:?((x.y).z) => x */
        1: 7541:            return FALSE;
        -: 7542:            }
        -: 7543:        }
       25: 7544:    if(kop(name) == WORDT) /* 20110912 {?} (=a+b)=5 ==> =5 */
        -: 7545:        {
        1: 7546:        wis(name->RIGHT);
        1: 7547:        name->RIGHT = zelfde_als_w(pknoop);
        1: 7548:        return TRUE;
        -: 7549:        }
       24: 7550:    else if(zoeknaam(name->LEFT,
        -: 7551:        &voorvar,
        -: 7552:        &navar))
        -: 7553:        {
        -: 7554:        assert(navar->pvaria);
       22: 7555:        return setmember(name->RIGHT,Entry2(navar->n,navar->selector,navar->pvaria),pknoop);
        -: 7556:        }
        -: 7557:    else
        -: 7558:        {
        2: 7559:        return FALSE; /*{?} 66:?(someUnidentifiableObject.x) */
        -: 7560:        }
        -: 7561:    }
        -: 7562:
        -: 7563:
   462939: 7564:static int insert(psk name,psk pknoop)
        -: 7565:    {
        -: 7566:    vars *navar,*voorvar,*nieuwvar;
        -: 7567:
   462939: 7568:    if(is_op(name))
        -: 7569:        {
       31: 7570:        if(kop(name) == WORDT)
        -: 7571:            {
        5: 7572:            wis(name->RIGHT);
        5: 7573:            name->RIGHT = zelfde_als_w(pknoop);  /*{?} monk2:?(=monk1) => monk2 */
        5: 7574:            return TRUE;
        -: 7575:            }
        -: 7576:        else
        -: 7577:            { /* This allows, in fact, other operators than DOT, e.g. b:?(x y) */
       26: 7578:            return update(name,pknoop); /*{?} (borfo=klot=)&bk:?(borfo klot)&!(borfo.klot):bk => bk */
        -: 7579:    /*        return FALSE;*/
        -: 7580:            }
        -: 7581:        }
   462908: 7582:    if(zoeknaam(name,
        -: 7583:                &voorvar,
        -: 7584:                &navar))
        -: 7585:        {
        -: 7586:        ppsk ppkn;
   456355: 7587:        wis(*(ppkn = Entry(navar->n,navar->selector,&navar->pvaria)));
   456355: 7588:        *ppkn = zelfde_als_w(pknoop);
        -: 7589:        }
        -: 7590:    else
        -: 7591:        {
        -: 7592:        size_t len;
        -: 7593:        unsigned char *string;
     6553: 7594:        string = POBJ(name);
     6553: 7595:        len = strlen((char *)string);
        -: 7596:#if PVNAME
        -: 7597:        nieuwvar = (vars*)bmalloc(__LINE__,sizeof(vars));
        -: 7598:        if(*string)
        -: 7599:            {
        -: 7600:#if ICPY
        -: 7601:            MEMCPY(nieuwvar->vname = (unsigned char *)
        -: 7602:                 bmalloc(__LINE__,len+1),string,(len >> LOGWORDLENGTH)+1);
        -: 7603:#else
        -: 7604:            MEMCPY(nieuwvar->vname = (unsigned char *)
        -: 7605:                 bmalloc(__LINE__,len+1),string,((len / sizeof(LONG))+1) * sizeof(LONG));
        -: 7606:#endif
        -: 7607:            }
        -: 7608:#else
     6553: 7609:        if(len < 4)
     4571: 7610:            nieuwvar = (vars*)bmalloc(__LINE__,sizeof(vars));
        -: 7611:        else
     1982: 7612:            nieuwvar = (vars*)bmalloc(__LINE__,sizeof(vars) - 3 + len);
     6553: 7613:        if(*string)
        -: 7614:            {
        -: 7615:#if ICPY
        -: 7616:            MEMCPY(&nieuwvar->u.Obj,string,(len / sizeof(LONG))+1);
        -: 7617:#else
     6242: 7618:            MEMCPY(&nieuwvar->u.Obj,string,((len / sizeof(LONG))+1) * sizeof(LONG));
        -: 7619:#endif
        -: 7620:            }
        -: 7621:#endif
        -: 7622:        else
        -: 7623:            {
        -: 7624:#if PVNAME
        -: 7625:            nieuwvar->vname = OBJ(nilk);
        -: 7626:#else
      311: 7627:            nieuwvar->u.Lobj = LOBJ(nilk);
        -: 7628:#endif
        -: 7629:            }
     6553: 7630:        nieuwvar->next = navar;
     6553: 7631:        if(voorvar == NULL)
     4132: 7632:            variabelen[*string] = nieuwvar;
        -: 7633:        else
     2421: 7634:            voorvar->next = nieuwvar;
     6553: 7635:        nieuwvar->n = 0;
     6553: 7636:        nieuwvar->selector = 0;
     6553: 7637:        nieuwvar->pvaria = (varia*)zelfde_als_w(pknoop);
        -: 7638:        }
   462908: 7639:    return TRUE;
        -: 7640:    }
        -: 7641:
   449784: 7642:static int copy_insert(psk name,psk pknoop,psk snijaf)
        -: 7643:    {
        -: 7644:    psk kn;
        -: 7645:    int ret;
        -: 7646:    assert((pknoop->RIGHT == 0 && snijaf == 0) || pknoop->RIGHT != snijaf);
        -: 7647:    DBGSRC(printf("copy_insert:");result(pknoop);printf("\n");)
   449784: 7648:    if(  (pknoop->v.fl & INDIRECT) 
        3: 7649:      && (pknoop->v.fl & READY)
        -: 7650:        /* 20110331 
        -: 7651:        {?} !dagj a:?dagj a
        -: 7652:        {!} !dagj
        -: 7653:        The test (pknoop->v.fl & READY) does not solve stackoverflow 
        -: 7654:        in the following examples:
        -: 7655:
        -: 7656:        {?} (=!y):(=?y)
        -: 7657:        {?} !y
        -: 7658:
        -: 7659:        {?} (=!y):(=?x)
        -: 7660:        {?} (=!x):(=?y)
        -: 7661:        {?} !x
        -: 7662:        */
        -: 7663:      )
        -: 7664:        {
        -: 7665:        DBGSRC(printf("A\n");)
    #####: 7666:        return FALSE;
        -: 7667:        }
   449784: 7668:    else if(pknoop->v.fl & IDENT)
        -: 7669:        {
        -: 7670:        DBGSRC(printf("B\n");)
    41614: 7671:        kn = copievan(pknoop);
        -: 7672:        }
   408170: 7673:    else if(snijaf == NULL)
        -: 7674:        {
        -: 7675:        DBGSRC(printf("C\n");)
   397424: 7676:        return insert(name,pknoop);
        -: 7677:        }
        -: 7678:    else
        -: 7679:        {
        -: 7680:        DBGSRC(printf("D\n");)
        -: 7681:        assert(!is_object(pknoop));
    10746: 7682:        if((shared(pknoop) != ALL_REFCOUNT_BITS_SET) && !all_refcount_bits_set(snijaf))
        -: 7683:            {/* snijaf: either node with headroom in the small refcounter 
        -: 7684:                        or object */
        -: 7685:            DBGSRC(printf("name:[");result(name);printf("] pknoop:[");result(pknoop);printf("] snijaf(%d):[",snijaf->v.fl/ONE);result(snijaf);printf("]\n");)
     9612: 7686:            kn = new_operator_like(pknoop);
     9612: 7687:            kn->ops = (pknoop->ops & ~ALL_REFCOUNT_BITS_SET) | LATEBIND;
     9612: 7688:            pknoop->ops += ONE;
     9612: 7689:            if(shared(snijaf) == ALL_REFCOUNT_BITS_SET)
        -: 7690:                {
        -: 7691:/*
        -: 7692:(T=
        -: 7693:  1100:?I
        -: 7694:& tbl$(AA,!I)
        -: 7695:& (OBJ==(=a) (=b) (=c))
        -: 7696:&   !OBJ
        -: 7697:  : (
        -: 7698:    =   %
        -: 7699:        %
        -: 7700:        (?m:?n:?o:?p:?q:?r:?s) { increase refcount of (=c) to 7}
        -: 7701:    )
        -: 7702:&   whl
        -: 7703:  ' ( !I+-1:~<0:?I
        -: 7704:    & !OBJ:(=(% %:?(!I$?AA)) ?)
        -: 7705:    )
        -: 7706:& !I);
        -: 7707:{due to late binding, the refcount of (=c) has just come above 1023, and then
        -: 7708:late binding stops for the last 80 or so iterations. The left hand side of the
        -: 7709:late bound node is not an object, and therefore can only count to 1024. 
        -: 7710:Thereafter copies must be made.}
        -: 7711:*/
        2: 7712:                INCREFCOUNT(snijaf);
        -: 7713:                }
        -: 7714:            else
     9610: 7715:                snijaf->ops += ONE;
        -: 7716:
     9612: 7717:            kn->LEFT = pknoop;
     9612: 7718:            kn->RIGHT = snijaf;
        -: 7719:            }
        -: 7720:        else
        -: 7721:            {
     1134: 7722:            copyToSnijaf(&kn,pknoop,snijaf); /*{?} a b c:(?z:?x:?y:?a:?b) c => a b c */
        -: 7723:            /*{?} 0:?n&a b c:?abc&whl'(!n+1:?n:<2000&str$(v !n):?v&!abc:?!v c) =>   whl
        -: 7724:    ' ( !n+1:?n:<2000
        -: 7725:      & str$(v !n):?v
        -: 7726:      & !abc:?!v c
        -: 7727:      ) */
        -: 7728:            }
        -: 7729:        }
        -: 7730:
        -: 7731:    DBGSRC(printf("E\n");)
    52360: 7732:    ret = insert(name,kn);
    52360: 7733:    wis(kn);
    52360: 7734:    return ret;
        -: 7735:    }
        -: 7736:
   263712: 7737:static psk scopy(char * str)
        -: 7738:    {
   263712: 7739:    int nr = fullnumbercheck(str,NULL) & ~DEFINITELYNONUMBER;
        -: 7740:    psk kn;
   263712: 7741:    if(nr & MINUS)
        -: 7742:        { /* bracmat out$arg$() -123 */
    #####: 7743:        kn = (psk)bmalloc(__LINE__,sizeof(unsigned LONG) + strlen((const char *)str));
    #####: 7744:        strcpy((char *)(kn)+sizeof(unsigned LONG),str + 1);
        -: 7745:        }
        -: 7746:    else
        -: 7747:        {
   263712: 7748:        kn = (psk)bmalloc(__LINE__,sizeof(unsigned LONG) + 1 + strlen((const char *)str));
   263712: 7749:        strcpy((char *)(kn)+sizeof(unsigned LONG),str);
        -: 7750:        }
   263712: 7751:    kn->v.fl = READY | SUCCESS | nr;
   263712: 7752:    return kn;
        -: 7753:    }
        -: 7754:
       59: 7755:static int scopy_insert(psk name,char * str)
        -: 7756:    {
        -: 7757:    int ret;
        -: 7758:    psk kn;
       59: 7759:    kn = scopy(str);
       59: 7760:    ret = insert(name,kn);
       59: 7761:    wis(kn);
       59: 7762:    return ret;
        -: 7763:    }
        -: 7764:
       59: 7765:static int icopy_insert(psk name,LONG number)
        -: 7766:    {
        -: 7767:    char buf[22];
       59: 7768:    sprintf((char*)buf,"%ld",number);
       59: 7769:    return scopy_insert(name,buf);
        -: 7770:    }
        -: 7771:
     1655: 7772:static int string_copy_insert(psk name,psk pknoop,char * str,char * snijaf)
        -: 7773:    {
     1655: 7774:    char sav = *snijaf;
        -: 7775:    int ret;
     1655: 7776:    *snijaf = '\0';
     1655: 7777:    if((pknoop->v.fl & IDENT) || all_refcount_bits_set(pknoop))
        -: 7778:        {
    #####: 7779:        ret = scopy_insert(name,str);
        -: 7780:        }
        -: 7781:    else
        -: 7782:        {
        -: 7783:        stringrefknoop * kn;
        -: 7784:        int nr;
     1655: 7785:        nr = fullnumbercheck(str,NULL) & ~DEFINITELYNONUMBER;
     1655: 7786:        if((nr & MINUS) && !(name->v.fl & NUMBER))
    #####: 7787:            nr = 0; /* "-1" is only converted to -1 if the # flag is present on the pattern */
     1655: 7788:        kn = (stringrefknoop *)bmalloc(__LINE__,sizeof(stringrefknoop));
     1655: 7789:        kn->ops = /*(pknoop->ops & ~(ALL_REFCOUNT_BITS_SET|VISIBLE_FLAGS)) 20080911 substring doesn't inherit flags like */
     1655: 7790:            READY | SUCCESS | LATEBIND | nr;
        -: 7791:        /*kn->ops |= SUCCESS;*/ /*20080113 */ /*{?} @(~`ab:%?x %?y)&!x => a */ /*{!} a */
     1655: 7792:        kn->kn = zelfde_als_w(pknoop);
     1655: 7793:        if(nr & MINUS)
        -: 7794:            {
    #####: 7795:            kn->str = str+1;
    #####: 7796:            kn->length = snijaf - str - 1;
        -: 7797:            }
        -: 7798:        else
        -: 7799:            {
     1655: 7800:            kn->str = str;
     1655: 7801:            kn->length = snijaf - str;
        -: 7802:            }
        -: 7803:        DBGSRC(int redMooi;int redhum;redMooi = mooi;\
        -: 7804:            redhum = hum;mooi = FALSE;hum = FALSE;\
        -: 7805:            Printf("str [%s] length %lu\n",kn->str,(unsigned LONG int)kn->length);\
        -: 7806:            mooi = redMooi;hum = redhum;)
     1655: 7807:        ret = insert(name,(psk)kn);
     1655: 7808:        if(ret)
     1655: 7809:            dec_refcount((psk)kn);
        -: 7810:        else
        -: 7811:            {
    #####: 7812:            wis(pknoop);
    #####: 7813:            bfree((void*)kn);
        -: 7814:            }
        -: 7815:        }
     1655: 7816:    *snijaf = sav;
     1655: 7817:    return ret;
        -: 7818:    }
        -: 7819:
   228772: 7820:static int getCodePoint(const char ** ps)
        -: 7821:    {
        -: 7822:    /*
        -: 7823:    return values:
        -: 7824:    > 0:    code point
        -: 7825:    -1:     no UTF-8
        -: 7826:    -2:     too short for being UTF-8
        -: 7827:    */
        -: 7828:    int K;
   228772: 7829:    const char * s = *ps;
   228772: 7830:    if((K = (const unsigned char)*s++) != 0)
        -: 7831:        {
   228741: 7832:        if((K & 0xc0) == 0xc0) /* 11bbbbbb */
        -: 7833:            {
        -: 7834:            int k[6];
        -: 7835:            int i;
        -: 7836:            int I;
   205686: 7837:            if((K & 0xfe) == 0xfe) /* 11111110 */
        -: 7838:                {
    #####: 7839:                return -1;
        -: 7840:                }
        -: 7841:            /* Start of multibyte */
        -: 7842:
   205686: 7843:            k[0] = K;
   604414: 7844:            for(i = 1;(K << i) & 0x80;++i)
        -: 7845:                {
   398770: 7846:                k[i] = (const unsigned char)*s++;
   398770: 7847:                if((k[i] & 0xc0) != 0x80) /* 10bbbbbb */
        -: 7848:                    {
       42: 7849:                    if(k[i])
        -: 7850:                        {
       13: 7851:                        return -1;
        -: 7852:                        }
       29: 7853:                    return -2;
        -: 7854:                    }
        -: 7855:                }
   205644: 7856:            K = ((k[0] << i) & 0xff) << (5 * i - 6);
   205644: 7857:            I = --i;
   809989: 7858:            while(i > 0)
        -: 7859:                {
   398701: 7860:                K |= (k[i] & 0x3f) << ((I - i) * 6);
   398701: 7861:                --i;
        -: 7862:                }
   205644: 7863:            if(K <= 0x7F) /* ASCII, must be a single byte */
        -: 7864:                {
    #####: 7865:                return -1;
        -: 7866:                }
        -: 7867:            }
    23055: 7868:        else if((K & 0xc0) == 0x80) /* 10bbbbbb, wrong first byte */
        -: 7869:            {
       14: 7870:            return -1;
        -: 7871:            }
        -: 7872:        }
   228716: 7873:    *ps = s; /* next character */
   228716: 7874:    return K;
        -: 7875:    }
        -: 7876:
   228720: 7877:static int getCodePoint2(const char ** ps,int * isutf)
        -: 7878:    {
   228720: 7879:    int ks = *isutf ? getCodePoint(ps) : (const unsigned char)*(*ps)++;
   228720: 7880:    if(ks < 0)
        -: 7881:        {
       12: 7882:        *isutf = 0;
       12: 7883:        ks = (const unsigned char)*(*ps)++;
        -: 7884:        }
        -: 7885:    assert(ks >= 0);
   228720: 7886:    return ks;
        -: 7887:    }
        -: 7888:
   197628: 7889:static int utf8bytes(unsigned LONG val)
        -: 7890:    {
   197628: 7891:    if(val < 0x80)
        -: 7892:        {
      427: 7893:        return 1;
        -: 7894:        }
   197201: 7895:    else if(val < 0x0800) /* 7FF = 1 1111 111111 */
        -: 7896:        {
     6213: 7897:        return 2;
        -: 7898:        }
   190988: 7899:    else if(val < 0x10000) /* FFFF = 1111 111111 111111 */
        -: 7900:        {
   190984: 7901:        return 3;
        -: 7902:        }
        4: 7903:    else if(val < 0x200000)
        -: 7904:        { /* 10000 = 010000 000000 000000, 10ffff = 100 001111 111111 111111 */
        4: 7905:        return 4;
        -: 7906:        }
    #####: 7907:    else if(val < 0x4000000)
        -: 7908:        {
    #####: 7909:        return 5;
        -: 7910:        }
        -: 7911:    else
        -: 7912:        {
    #####: 7913:        return 6;
        -: 7914:        }
        -: 7915:    }
        -: 7916:
        -: 7917:/* extern, is called from xml.c */
   270971: 7918:char * putCodePoint(unsigned LONG val,char * s)
        -: 7919:    {
        -: 7920:    /* Converts Unicode character w to 1,2,3 or 4 bytes of UTF8 in s. */
   270971: 7921:    if(val < 0x80)
        -: 7922:        {
     6329: 7923:        *s++ = (char)val;
        -: 7924:        }
        -: 7925:    else
        -: 7926:        {
   264642: 7927:        if(val < 0x0800) /* 7FF = 1 1111 111111 */
        -: 7928:            {
     8153: 7929:            *s++ = (char)(0xc0 | (val >> 6 ));
        -: 7930:            }
        -: 7931:        else
        -: 7932:            {
   256489: 7933:            if(val < 0x10000) /* FFFF = 1111 111111 111111 */
        -: 7934:                {
   256474: 7935:                *s++ = (char)(0xe0 | (val >> 12));
        -: 7936:                }
        -: 7937:            else
        -: 7938:                {
       15: 7939:                if(val < 0x200000)
        -: 7940:                    { /* 10000 = 010000 000000 000000, 10ffff = 100 001111 111111 111111 */
        7: 7941:                    *s++ = (char)(0xf0 | (val >> 18));
        -: 7942:                    }
        -: 7943:                else
        -: 7944:                    {
        8: 7945:                    if(val < 0x4000000)
        -: 7946:                        {
        3: 7947:                        *s++ = (char)(0xf8 | (val >> 24));
        -: 7948:                        }
        -: 7949:                    else
        -: 7950:                        {
        5: 7951:                        if(val < 0x80000000)
        -: 7952:                            {
        3: 7953:                            *s++ = (char)(0xfc | (val >> 30));
        3: 7954:                            *s++ = (char)(0x80 | ((val >> 24) & 0x3f));
        -: 7955:                            }
        -: 7956:                        else
        2: 7957:                            return NULL;
        -: 7958:                        }
        6: 7959:                    *s++ = (char)(0x80 | ((val >> 18) & 0x3f));
        -: 7960:                    }
       13: 7961:                *s++ = (char)(0x80 | ((val >> 12) & 0x3f));
        -: 7962:                }
   256487: 7963:            *s++ = (char)(0x80 | ((val >> 6) & 0x3f));
        -: 7964:            }
   264640: 7965:        *s++ = (char)(0x80 | (val & 0x3f));
        -: 7966:        }
   270969: 7967:    *s = (char)0;
   270969: 7968:    return s;
        -: 7969:    }
        -: 7970:
      198: 7971:static int strcasecompu(char ** S, char ** P,char * snijaf)
        -: 7972:/* 20100210 Additional argument snijaf */
        -: 7973:    {
      198: 7974:    int sutf = 1;
      198: 7975:    int putf = 1;
      198: 7976:    char * s = *S;
      198: 7977:    char * p = *P;
     5909: 7978:    while(s < snijaf && *s && *p)
        -: 7979:        {
     5533: 7980:        char * ns = s;
     5533: 7981:        char * np = p;
     5533: 7982:        int ks = getCodePoint2((const char **)&ns,&sutf);
     5533: 7983:        int kp = getCodePoint2((const char **)&np,&putf);
     5533: 7984:        if(ks >= 0 && kp >= 0)
     5513: 7985:            {
     5533: 7986:            int diff = toLowerUnicode(ks) - toLowerUnicode(kp);
     5533: 7987:            if(diff)
        -: 7988:                {
       20: 7989:                *S = s;
       20: 7990:                *P = p;
       20: 7991:                return diff;
        -: 7992:                }
        -: 7993:            }
        -: 7994:        else
        -: 7995:            {
    #####: 7996:            *S = s;
    #####: 7997:            *P = p;
        -: 7998:            }
     5513: 7999:        s = ns;
     5513: 8000:        p = np;
        -: 8001:        }
      178: 8002:    *S = s;
      178: 8003:    *P = p;
      178: 8004:    return (s < snijaf ? (int)(unsigned char)*s : 0) - (int)(unsigned char)*p;
        -: 8005:    }
        -: 8006:
        -: 8007:
        9: 8008:static int strcasecomp(const char *s, const char *p)
        -: 8009:    {
        9: 8010:    int sutf = 1; /* assume UTF-8, becomes 0 if it is not */
        9: 8011:    int putf = 1;
     3972: 8012:    while(*s && *p)
        -: 8013:        {
     3957: 8014:        int ks = getCodePoint2((const char **)&s,&sutf);
     3957: 8015:        int kp = getCodePoint2((const char **)&p,&putf);
     3957: 8016:        int diff = toLowerUnicode(ks) - toLowerUnicode(kp);
     3957: 8017:        if(diff)
        -: 8018:            {
        3: 8019:            return diff;
        -: 8020:            }
        -: 8021:        }
        6: 8022:    return (int)(const unsigned char)*s - (int)(const unsigned char)*p;
        -: 8023:    }
        -: 8024:
        -: 8025:#if CODEPAGE850
        -: 8026:static int strcasecmpDOS(const char *s, const char *p)
        -: 8027:    {
        -: 8028:    while(*s && *p)
        -: 8029:        {
        -: 8030:        int diff = (int)ISO8859toCodePage850(lowerEquivalent[CodePage850toISO8859((unsigned char)*s)]) - (int)ISO8859toCodePage850(lowerEquivalent[CodePage850toISO8859((unsigned char)*p)]);
        -: 8031:        if(diff)
        -: 8032:            return diff;
        -: 8033:        ++s;
        -: 8034:        ++p;
        -: 8035:        }
        -: 8036:    return (int)*s - (int)*p;
        -: 8037:    }
        -: 8038:#endif
        -: 8039:
        -: 8040:#define NIET ((p->v.fl & NOT) && (p->v.fl & FLGS) < NUMBER)
        -: 8041:#define PGRT (p->v.fl & GREATER_THAN)
        -: 8042:#define PKLN (p->v.fl & SMALLER_THAN)
        -: 8043:#define PONG  (PGRT && PKLN)
        -: 8044:#define EPGRT (PGRT && !PKLN)
        -: 8045:#define EPKLN (PKLN && !PGRT)
        -: 8046:
   477586: 8047:static int compare(psk s,psk p)
        -: 8048:    {
        -: 8049:    int teken;
        -: 8050:    /*if(RATIONAAL_COMP(s) && RATIONAAL_COMP(p))*/
   477586: 8051:    if(RATIONAAL_COMP(s) && RATIONAAL_WEAK(p))
   197639: 8052:        teken = _qvergelijk /*bereken_verschil*/(s,p);
        -: 8053:    else
        -: 8054:        {
   279947: 8055:        if(is_op(s))
    17631: 8056:            return NIKS(p);
   262316: 8057:        if(PLOBJ(s) == IM && PLOBJ(p) == IM)
        -: 8058:            {
      200: 8059:            int TMP = ((s->v.fl & MINUS) ^ (p->v.fl & MINUS));
      200: 8060:            int Niet = (p->v.fl & FLGS) < NUMBER && ((p->v.fl & NOT) && 1);
      200: 8061:            int ul = (p->v.fl & (GREATER_THAN|SMALLER_THAN)) == (GREATER_THAN|SMALLER_THAN);
      200: 8062:            int e1 = ((p->v.fl & GREATER_THAN) && 1);
      200: 8063:            int e2 = ((p->v.fl & SMALLER_THAN) && 1);
      200: 8064:            int ee = (e1 ^ e2) && 1;
      200: 8065:            int R = !ee && (Niet ^ ul ^ !TMP);
      200: 8066:            return R;
        -: 8067:            }
   262116: 8068:        if((p->v.fl & (NOT|BREUK|NUMBER|GREATER_THAN|SMALLER_THAN)) == (NOT|GREATER_THAN|SMALLER_THAN))
        -: 8069:            { /* 20040223 Case insensitive match: ~<> means "not different" */
        5: 8070:            teken = strcasecomp((char *)POBJ(s),(char *)POBJ(p));
        -: 8071:            }
        -: 8072:        else
        -: 8073:            {
   262111: 8074:            teken = strcmp((char *)POBJ(s),(char *)POBJ(p));
        -: 8075:            }
   262116: 8076:        if(teken > 0)
     8660: 8077:            teken = 0;
   253456: 8078:        else if(teken < 0)
   114049: 8079:            teken = MINUS;
        -: 8080:        else
   139407: 8081:            teken = QNUL;
        -: 8082:        }
   459755: 8083:    switch(teken)
        -: 8084:        {
        -: 8085:        case 0 :
        -: 8086:            {
   182536: 8087:            if(s->v.fl & SMALLER_THAN)
    #####: 8088:                return FALSE;
   182536: 8089:            return NIET ^ (PGRT && 1);
        -: 8090:            }
        -: 8091:        case QNUL :
        -: 8092:            {
   144958: 8093:            switch(s->v.fl & (GREATER_THAN|SMALLER_THAN))
        -: 8094:                {
        -: 8095:                case GREATER_THAN|SMALLER_THAN :
    #####: 8096:                    return NIET ^ PONG;
        -: 8097:                case GREATER_THAN :
    #####: 8098:                    return NIET ^ PONG ^ EPGRT;
        -: 8099:                case SMALLER_THAN :
    #####: 8100:                    return NIET ^ PONG ^ EPKLN;
        -: 8101:                default :
   144958: 8102:                    return !NIET ^ (PGRT || PKLN);
        -: 8103:                }
        -: 8104:            }
        -: 8105:        default :
        -: 8106:            {
   132261: 8107:            if(s->v.fl & GREATER_THAN)
    #####: 8108:                return FALSE;
   132261: 8109:            return NIET ^ (PKLN && 1);
        -: 8110:            }
        -: 8111:        }
        -: 8112:    }
        -: 8113:
        -: 8114:
        -: 8115:
        -: 8116:#if CUTOFFSUGGEST
        -: 8117:#define scompare(wh,s,c,p,suggestedCutOff,mayMoveStartOfSubject) scompare(s,c,p,suggestedCutOff,mayMoveStartOfSubject)
        -: 8118:#else
        -: 8119:#define scompare(wh,s,c,p) scompare(s,c,p)
        -: 8120:#endif
        -: 8121:
        -: 8122:
        -: 8123:/* 20101125 
        -: 8124:(1) Fractions are now matched.
        -: 8125:(2) With the % flag on an otherwise numeric pattern, the pattern is treated 
        -: 8126:    as a string, not a number.
        -: 8127:*/
        -: 8128:#if CUTOFFSUGGEST
    91739: 8129:static int scompare(char * wh,char * s,char * snijaf,psk p,char ** suggestedCutOff,char ** mayMoveStartOfSubject)
        -: 8130:#else
        -: 8131:static int scompare(char * wh,unsigned char * s,unsigned char * snijaf,psk p)
        -: 8132:#endif
        -: 8133:    {
    91739: 8134:    int teken = 0;
        -: 8135:    char * P;
        -: 8136:#if CUTOFFSUGGEST
    91739: 8137:    char * S = s;
        -: 8138:#endif
        -: 8139:    char sav;
        -: 8140:    int lessIfMoreDigitsAdded;
        -: 8141:    int smallerIfMoreDigitsAdded; /* -1/22 smaller than -1/2 */ /* 1/22 smaller than 1/2 */
        -: 8142:    int samesign;
        -: 8143:    int less;
    91739: 8144:    int Flgs = p->v.fl;
        -: 8145:    enum {NoIndication,AnInteger,NotAFraction,NotANumber,AFraction,ANumber};
    91739: 8146:    int status = NoIndication;
        -: 8147:
    91739: 8148:    if(ONTKENNING(Flgs, NONIDENT))
        -: 8149:        {
    #####: 8150:        Flgs &= ~(NOT|NONIDENT);
        -: 8151:        }
    91739: 8152:    if(ONTKENNING(Flgs, BREUK)) /* 20101122 better check */
        -: 8153:        {
    #####: 8154:        Flgs &= ~(NOT|BREUK);
    #####: 8155:        if(Flgs & NUMBER)
    #####: 8156:            status = AnInteger;
        -: 8157:        else
    #####: 8158:            status = NotAFraction;
        -: 8159:        }
    91739: 8160:    else if(ONTKENNING(Flgs, NUMBER)) /* 20101122 better check */
        -: 8161:        {
       10: 8162:        Flgs &= ~(NOT|NUMBER);
       10: 8163:        status = NotANumber;
        -: 8164:        }
    91729: 8165:    else if(Flgs & BREUK)
    #####: 8166:        status = AFraction;
    91729: 8167:    else if(Flgs & NUMBER)
       15: 8168:        status = ANumber;
        -: 8169:
        -: 8170:
    91739: 8171:    if(  !(Flgs & NONIDENT) /* 20101122 % as flag on number forces comparison as string, not as number */
    91656: 8172:      && RATIONAAL_WEAK(p)
      165: 8173:      && (status != NotANumber)
      165: 8174:      && (  (  ((Flgs & (QBREUK|IS_OPERATOR)) == QBREUK) /*20120209*/
       79: 8175:            && (status != NotAFraction)
        -: 8176:            )
       86: 8177:         || (  ((Flgs & (QBREUK|QGETAL|IS_OPERATOR)) == QGETAL)
       86: 8178:            && (status != AFraction   )
        -: 8179:            )
        -: 8180:         )
        -: 8181:      )
        -: 8182:        {
      165: 8183:        int check = sfullnumbercheck(s,snijaf,NULL);
      165: 8184:        if(check & QGETAL)
        -: 8185:            {
       57: 8186:            int anythingGoes = 0;
       57: 8187:            psk n = NULL;
       57: 8188:            sav = *snijaf;
       57: 8189:            *snijaf = '\0';
       57: 8190:            n = opb(n,s,NULL);
       57: 8191:            *snijaf = sav;
        -: 8192:
       57: 8193:            if(RAT_NEG_COMP(n))
        -: 8194:                {
       27: 8195:                lessIfMoreDigitsAdded = 1;
        -: 8196:                }
        -: 8197:            else
        -: 8198:                {
       30: 8199:                lessIfMoreDigitsAdded = 0;
        -: 8200:                }
        -: 8201:    
       57: 8202:            if(RAT_RAT(n))
        -: 8203:                {
        4: 8204:                smallerIfMoreDigitsAdded = 1;
        -: 8205:                }
        -: 8206:            else
        -: 8207:                {
       53: 8208:                smallerIfMoreDigitsAdded = 0;
        -: 8209:                /* check whether there is a slash followed by non-zero decimal digit coming */
       53: 8210:                if(!RAT_RAT(n))
        -: 8211:                    {
       53: 8212:                    char * t = snijaf;
       90: 8213:                    for(;*t;++t)
        -: 8214:                        {
       90: 8215:                        if(*t == '/')
        -: 8216:                            {
       26: 8217:                            if(('0' < *++t) && (*t <= '9'))
        -: 8218:                                {
       26: 8219:                                anythingGoes = 1;
        -: 8220:                                }
       26: 8221:                            break;
        -: 8222:                            }
       64: 8223:                        if('0' > *t || *t > '9')
        -: 8224:                            break;
        -: 8225:                        }
        -: 8226:                    }
        -: 8227:                }
       57: 8228:            less = lessIfMoreDigitsAdded ^ smallerIfMoreDigitsAdded;
       57: 8229:            teken = _qvergelijk(n,p);
       57: 8230:            samesign = ((n->v.fl & MINUS) == (p->v.fl & MINUS));
       57: 8231:            wis(n);
       57: 8232:            switch(Flgs & (NOT|GREATER_THAN|SMALLER_THAN))
        -: 8233:                {
        -: 8234:                case NOT|GREATER_THAN|SMALLER_THAN:    /* n:~<>p */
        -: 8235:                case 0:                                /* n:p */
        -: 8236:                    {
        -: 8237:    /*
        -: 8238:                    n:p        n == p
        -: 8239:                    n:~<>p  same as n:p
        -: 8240:                        [n == p]
        -: 8241:                            TRUE | ONCE
        -: 8242:                        [n > p]
        -: 8243:                            if n < 0 && p < 0
        -: 8244:                                FALSE
        -: 8245:                            else
        -: 8246:                                ONCE
        -: 8247:                        [n < p]
        -: 8248:                            if n < 0
        -: 8249:                                ONCE
        -: 8250:                            else
        -: 8251:                                FALSE
        -: 8252:    */
       21: 8253:                    switch(teken)
        -: 8254:                        {
        -: 8255:                        case QNUL:    /* n == p */
       10: 8256:                            if(anythingGoes)
        3: 8257:                                return TRUE;
        -: 8258:                            else
        7: 8259:                                return TRUE|ONCE;
        -: 8260:                        case 0:        /* n > p */
        6: 8261:                            if(samesign && (anythingGoes || less))
        6: 8262:                                return FALSE;
        -: 8263:                            else
    #####: 8264:                                return ONCE;
        -: 8265:                        default:    /* n < p */
        5: 8266:                            if(samesign && (anythingGoes || !less))
        5: 8267:                                return FALSE;
        -: 8268:                            else
    #####: 8269:                                return ONCE;
        -: 8270:                        }
        -: 8271:                    }
        -: 8272:                case SMALLER_THAN:    /* n:<p */
        -: 8273:                    {
        -: 8274:    /*
        -: 8275:                    n:<p    n < p
        -: 8276:                        [n == p]
        -: 8277:                            if n < 0
        -: 8278:                                FALSE
        -: 8279:                            else
        -: 8280:                                ONCE
        -: 8281:                        [n > p]
        -: 8282:                            if n < 0
        -: 8283:                                FALSE
        -: 8284:                            else
        -: 8285:                                ONCE
        -: 8286:                        [n < p]
        -: 8287:                            TRUE
        -: 8288:    */
       13: 8289:                    switch(teken)
        -: 8290:                        {
        -: 8291:                        case QNUL:    /* n == p */
    #####: 8292:                            if(anythingGoes || less)
    #####: 8293:                                return FALSE;
        -: 8294:                            else
    #####: 8295:                                return ONCE;
        -: 8296:                        case 0:        /* n > p */
        4: 8297:                            if(samesign && (anythingGoes || less))
        4: 8298:                                return FALSE;
        -: 8299:                            else
    #####: 8300:                                return ONCE;
        -: 8301:                        default:    /* n < p */
        9: 8302:                            return TRUE;
        -: 8303:                        }
        -: 8304:                    }
        -: 8305:                case GREATER_THAN:    /* n:>p */
        -: 8306:                    {
        -: 8307:    /*
        -: 8308:                    n:>p    n > p
        -: 8309:                        [n == p]
        -: 8310:                            if n < 0
        -: 8311:                                ONCE
        -: 8312:                            else
        -: 8313:                                FALSE
        -: 8314:                        [n > p]
        -: 8315:                            TRUE
        -: 8316:                        [n < p]
        -: 8317:                            if n < 0
        -: 8318:                                ONCE
        -: 8319:                            else
        -: 8320:                                FALSE
        -: 8321:    */
        9: 8322:                    switch(teken)
        -: 8323:                        {
        -: 8324:                        case 0:        /* n > p */
        7: 8325:                            return TRUE;
        -: 8326:                        case QNUL:/* n == p */
    #####: 8327:                            if(anythingGoes || !less)
    #####: 8328:                                return FALSE;
        -: 8329:                            else
    #####: 8330:                                return ONCE;
        -: 8331:                        default:    /* n < p */
        2: 8332:                            if(samesign && (anythingGoes || !less))
        2: 8333:                                return FALSE;
        -: 8334:                            else
    #####: 8335:                                return ONCE;
        -: 8336:                        }
        -: 8337:                    }
        -: 8338:                case GREATER_THAN|SMALLER_THAN:    /* n:<>p */
        -: 8339:                case NOT:                        /* n:~p */
        -: 8340:                    {
        -: 8341:    /*
        -: 8342:                    n:<>p   n != p
        -: 8343:                    n:~p    same as n:<>p
        -: 8344:                        [n == p]
        -: 8345:                            FALSE
        -: 8346:                        [n > p]
        -: 8347:                            TRUE
        -: 8348:                        [n < p]
        -: 8349:                            TRUE
        -: 8350:
        -: 8351:    */
        4: 8352:                    switch(teken)
        -: 8353:                        {
        -: 8354:                        case QNUL:    /* n == p */
    #####: 8355:                            return FALSE;
        -: 8356:                        default:    /* n < p, n > p */
        4: 8357:                            return TRUE;
        -: 8358:                        }
        -: 8359:                    }
        -: 8360:                case NOT|SMALLER_THAN:    /* n:~<p */
        -: 8361:                    {
        -: 8362:    /*
        -: 8363:                    n:~<p   n >= p
        -: 8364:                        [n == p]
        -: 8365:                            if n < 0
        -: 8366:                                TRUE | ONCE
        -: 8367:                            else
        -: 8368:                                TRUE
        -: 8369:                        [n > p]
        -: 8370:                            TRUE
        -: 8371:                        [n < p]
        -: 8372:                            if n < 0
        -: 8373:                                ONCE
        -: 8374:                            else
        -: 8375:                                FALSE
        -: 8376:    */
        4: 8377:                    switch(teken)
        -: 8378:                        {
        -: 8379:                        case QNUL:    /* n == p */
    #####: 8380:                            if(anythingGoes || !less)
    #####: 8381:                                return TRUE;
        -: 8382:                            else
    #####: 8383:                                return TRUE|ONCE;
        -: 8384:                        case 0:        /* n > p */
    #####: 8385:                            return TRUE;
        -: 8386:                        default:    /* n < p */
        4: 8387:                            if(samesign && (anythingGoes || !less))
        4: 8388:                                return FALSE;
        -: 8389:                            else
    #####: 8390:                                return ONCE;
        -: 8391:                        }
        -: 8392:                    }
        -: 8393:                case NOT|GREATER_THAN:    /* n:~>p */
        -: 8394:                    {
        -: 8395:    /*
        -: 8396:                    n:~>p   n <= p
        -: 8397:                        [n == p]
        -: 8398:                            if n < p
        -: 8399:                                TRUE
        -: 8400:                            else
        -: 8401:                                TRUE | ONCE
        -: 8402:                        [n > p]
        -: 8403:                            if n < p
        -: 8404:                                FALSE
        -: 8405:                            else
        -: 8406:                                ONCE
        -: 8407:                        [n < p]
        -: 8408:                            TRUE
        -: 8409:    */
        6: 8410:                    switch(teken)
        -: 8411:                        {
        -: 8412:                        case QNUL:    /* n == p */
    #####: 8413:                            if(anythingGoes || less)
    #####: 8414:                                return TRUE;
        -: 8415:                            else
    #####: 8416:                                return TRUE|ONCE;
        -: 8417:                        case 0:        /* n > p */
        1: 8418:                            if(samesign && (anythingGoes || less))
        1: 8419:                                return FALSE;
        -: 8420:                            else
    #####: 8421:                                return ONCE;
        -: 8422:                        default:    /* n < p */
        5: 8423:                            return TRUE;
        -: 8424:                        }
        -: 8425:                    }
        -: 8426:                default:
    #####: 8427:                    return FALSE;
        -: 8428:                }
        -: 8429:            /* End (check & QGETAL) == TRUE. */
        -: 8430:            /*printf("Not expected here!");
        -: 8431:            getchar();*/
        -: 8432:            }
      108: 8433:        else if(  (s < snijaf)
       33: 8434:               && (  ((*s == '-') && (snijaf < s + 2))
       26: 8435:                  || snijaf[-1] == '/'
        -: 8436:                  )
        -: 8437:               )
        -: 8438:            {
        -: 8439:            /* We can not yet discredit the subject as a number.
        -: 8440:            With additional characters it may become a number. */
       11: 8441:            return FALSE;
        -: 8442:            }
        -: 8443:        /* Subject is definitely not a number. */
        -: 8444:        }
        -: 8445:
    91671: 8446:    P = (char *)SPOBJ(p);
        -: 8447:
    91671: 8448:    if((Flgs & (NOT|BREUK|NUMBER|GREATER_THAN|SMALLER_THAN)) == (NOT|GREATER_THAN|SMALLER_THAN))
        -: 8449:        { /* 20040223 Case insensitive match: ~<> means "not different" */
      198: 8450:        teken = strcasecompu(&s,&P,snijaf); /* 20100210 Additional argument snijaf */
        -: 8451:        }
        -: 8452:    else
        -: 8453:        {
        -: 8454:#if CUTOFFSUGGEST
    91473: 8455:        if(suggestedCutOff)
        -: 8456:            {
    76724: 8457:            switch(Flgs & (NOT|GREATER_THAN|SMALLER_THAN))
        -: 8458:                {
        -: 8459:                case NOT|GREATER_THAN:    /* n:~>p */
        -: 8460:                case SMALLER_THAN:    /* n:<p */
        -: 8461:                case GREATER_THAN|SMALLER_THAN:    /* n:<>p */
        -: 8462:                case NOT:                        /* n:~p */
        -: 8463:                    {
       73: 8464:                    while(((teken = (s < snijaf ? *s : 0) - *P) == 0) && *P) /* 20100210 Additional argument snijaf */
        -: 8465:                        {
        9: 8466:                        ++s;
        9: 8467:                        ++P;
        -: 8468:                        }
       32: 8469:                    if(teken > 0)
        -: 8470:                        {
        4: 8471:                        switch(Flgs & (NOT|GREATER_THAN|SMALLER_THAN))
        -: 8472:                            {
        -: 8473:                            case NOT|GREATER_THAN:
        -: 8474:                            case SMALLER_THAN:
        2: 8475:                                return ONCE;
        -: 8476:                            default:
        2: 8477:                                return TRUE;
        -: 8478:                            }
        -: 8479:                        }
       28: 8480:                    else if(teken == 0)
        -: 8481:                        {
        6: 8482:                        switch(Flgs & (NOT|GREATER_THAN|SMALLER_THAN))
        -: 8483:                            {
        -: 8484:                            case NOT|GREATER_THAN:
        1: 8485:                                return TRUE|ONCE;
        -: 8486:                            case SMALLER_THAN:
        3: 8487:                                return ONCE;
        -: 8488:                            default:
        2: 8489:                                return FALSE;
        -: 8490:                            }
        -: 8491:                        }
       22: 8492:                    return TRUE;
        -: 8493:                    }
        -: 8494:                case GREATER_THAN:    /* n:>p */
        -: 8495:                    {
       96: 8496:                    while(((teken = *s - *P) == 0) && *s && *P)
        -: 8497:                        {
       10: 8498:                        ++s;
       10: 8499:                        ++P;
        -: 8500:                        }
       43: 8501:                    if(s >= snijaf)
        -: 8502:                        {
       33: 8503:                        if(teken > 0)
       20: 8504:                            *suggestedCutOff = s + 1;
       33: 8505:                        break;
        -: 8506:                        }
       10: 8507:                    return ONCE;
        -: 8508:                    }
        -: 8509:                case NOT|GREATER_THAN|SMALLER_THAN:    /* n:~<>p */
        -: 8510:                case 0:                                /* n:p */
   154620: 8511:                    while(((teken = *s - *P) == 0) && *s && *P)
        -: 8512:                        {
     1354: 8513:                        ++s;
     1354: 8514:                        ++P;
        -: 8515:                        }
    76633: 8516:                    if(s >= snijaf && *P == 0)
        -: 8517:                        {
      436: 8518:                        *suggestedCutOff = s;
      436: 8519:                        teken = 0;
      436: 8520:                        if(mayMoveStartOfSubject)
      346: 8521:                            *mayMoveStartOfSubject = 0;
      436: 8522:                        return TRUE|ONCE;
        -: 8523:                        }
    76197: 8524:                    if(mayMoveStartOfSubject && *mayMoveStartOfSubject != 0)
        -: 8525:                        {
        -: 8526:                        char * startpos;
        -: 8527:#ifndef NDEBUG
        -: 8528:                        char * pat = (char *)POBJ(p);
        -: 8529:#endif
      435: 8530:                        startpos = strstr((char *)S,(char *)POBJ(p));
      435: 8531:                        if(startpos != 0)
        -: 8532:                            {
      309: 8533:                            if(Flgs & MINUS)
       10: 8534:                                --startpos;
        -: 8535:                            }
        -: 8536:                        /*assert(  startpos == 0 
        -: 8537:                              || (startpos+strlen((char *)POBJ(p)) < snijaf - 1)
        -: 8538:                              || (startpos+strlen((char *)POBJ(p)) >= snijaf)
        -: 8539:                              );*/
      435: 8540:                        *mayMoveStartOfSubject = (char *)startpos;
      435: 8541:                        return ONCE;
        -: 8542:                        }
        -: 8543:
    75762: 8544:                    if(teken > 0 || s < snijaf)
        -: 8545:                        {
    54053: 8546:                        return ONCE;
        -: 8547:                        }
    21709: 8548:                    return FALSE;/*subject too short*/
        -: 8549:                    /*break;*/
        -: 8550:                case NOT|SMALLER_THAN:    /* n:~<p */
        -: 8551:                /*default:*/
       42: 8552:                    while(((teken = *s - *P) == 0) && *s && *P)
        -: 8553:                        {
       10: 8554:                        ++s;
       10: 8555:                        ++P;
        -: 8556:                        }
       16: 8557:                    if(teken >= 0)
        -: 8558:                        {
       12: 8559:                        if(s >= snijaf)
        -: 8560:                            {
       12: 8561:                            *suggestedCutOff = (*P) ? s + 1 : s;
        -: 8562:                            }
       12: 8563:                        return TRUE;
        -: 8564:                        }
        4: 8565:                    return ONCE;
        -: 8566:                }
        -: 8567:            }
        -: 8568:        else
        -: 8569:#endif
        -: 8570:            {
        -: 8571:#if CUTOFFSUGGEST
    14749: 8572:            switch(Flgs & (NOT|GREATER_THAN|SMALLER_THAN))
        -: 8573:                {
        -: 8574:#if 1
        -: 8575:                case NOT|GREATER_THAN|SMALLER_THAN:    /* n:~<>p */
        -: 8576:                case 0:                                /* n:p */
    31845: 8577:                    while(((teken = (s < snijaf ? *s : 0) - *P) == 0) && *s && *P)
        -: 8578:                        {
     3719: 8579:                        ++s;
     3719: 8580:                        ++P;
        -: 8581:                        }
    14063: 8582:                    if(teken != 0 && mayMoveStartOfSubject && *mayMoveStartOfSubject != 0)
        -: 8583:                        {
        -: 8584:                        char * startpos;
      706: 8585:                        char * ep = SPOBJ(p) + strlen((char*)POBJ(p));
      706: 8586:                        char * es = snijaf ? snijaf : S + strlen((char*)S);
     1593: 8587:                        while(ep > SPOBJ(p))
        -: 8588:                            {
      727: 8589:                            if(*--ep != *--es)
        -: 8590:                                {
      546: 8591:                                *mayMoveStartOfSubject = 0;
      546: 8592:                                return ONCE;
        -: 8593:                                }
        -: 8594:                            }
      160: 8595:                        startpos = es;
      160: 8596:                        if(Flgs & MINUS)
    #####: 8597:                            --startpos;
      160: 8598:                        if((char *)startpos > *mayMoveStartOfSubject)
      159: 8599:                            *mayMoveStartOfSubject = (char *)startpos;
      160: 8600:                        return ONCE;
        -: 8601:                        }
        -: 8602:                        
    13357: 8603:                    break;
        -: 8604:#endif
        -: 8605:                default:
        -: 8606:#else
        -: 8607:                {
        -: 8608:#endif
     1457: 8609:                    while(((teken = (s < snijaf ? (int)(unsigned char)*s : 0) - (int)(unsigned char)*P) == 0) && *P) /* 20100210 Additional argument snijaf */
        -: 8610:                        {
       85: 8611:                        ++s;
       85: 8612:                        ++P;
        -: 8613:                        }
        -: 8614:                }
        -: 8615:            }
        -: 8616:        }
        -: 8617:
        -: 8618:
    14274: 8619:    switch(Flgs & (NOT|GREATER_THAN|SMALLER_THAN))
        -: 8620:        {
        -: 8621:        case NOT|GREATER_THAN|SMALLER_THAN:    /* n:~<>p */
        -: 8622:        case 0:                                /* n:p */
        -: 8623:            {
        -: 8624:/*
        -: 8625:            n:p        n == p
        -: 8626:            n:~<>p  same as n:p
        -: 8627:                [n == p]
        -: 8628:                    TRUE | ONCE
        -: 8629:                [n > p]
        -: 8630:                    ONCE
        -: 8631:                [n < p]
        -: 8632:                    FALSE
        -: 8633:*/
    13555: 8634:            if(teken == 0)
        -: 8635:                {
      666: 8636:                return TRUE|ONCE;
        -: 8637:                }
    12889: 8638:            else if(teken < 0 && s >= snijaf)
        -: 8639:                {
     4136: 8640:                return FALSE;
        -: 8641:                }
     8753: 8642:            return ONCE;
        -: 8643:            }
        -: 8644:        case SMALLER_THAN:    /* n:<p */
        -: 8645:            {
        -: 8646:/*
        -: 8647:            n:<p    n < p
        -: 8648:                [n == p]
        -: 8649:                    ONCE
        -: 8650:                [n > p]
        -: 8651:                    ONCE
        -: 8652:                [n < p]
        -: 8653:                    TRUE
        -: 8654:*/
        6: 8655:            if(teken >= 0)
        -: 8656:                {
        4: 8657:                return ONCE;
        -: 8658:                }
        2: 8659:            return TRUE;
        -: 8660:            }
        -: 8661:        case GREATER_THAN:    /* n:>p */
        -: 8662:            {
        -: 8663:/*
        -: 8664:            n:>p    n > p
        -: 8665:                [n == p]
        -: 8666:                    FALSE
        -: 8667:                [n > p]
        -: 8668:                    TRUE
        -: 8669:                [n < p]
        -: 8670:                    FALSE
        -: 8671:*/
      500: 8672:            if(teken > 0)
        -: 8673:                {
       31: 8674:                return TRUE;
        -: 8675:                }
      469: 8676:            else if(teken < 0 && s < snijaf)
        -: 8677:                {
      170: 8678:                return ONCE;
        -: 8679:                }
      299: 8680:            return FALSE;
        -: 8681:            }
        -: 8682:        case GREATER_THAN|SMALLER_THAN:    /* n:<>p */
        -: 8683:        case NOT:                        /* n:~p */
        -: 8684:            {
        -: 8685:/*
        -: 8686:            n:<>p   n != p
        -: 8687:            n:~p    same as n:<>p
        -: 8688:                [n == p]
        -: 8689:                    FALSE
        -: 8690:                [n > p]
        -: 8691:                    TRUE
        -: 8692:                [n < p]
        -: 8693:                    TRUE
        -: 8694:
        -: 8695:*/
      213: 8696:            if(teken == 0)
        -: 8697:                {
       17: 8698:                return FALSE;
        -: 8699:                }
      196: 8700:            return TRUE;
        -: 8701:            }
        -: 8702:        case NOT|SMALLER_THAN:    /* n:~<p */
        -: 8703:            {
        -: 8704:/*
        -: 8705:            n:~<p   n >= p
        -: 8706:                [n == p]
        -: 8707:                    TRUE
        -: 8708:                [n > p]
        -: 8709:                    TRUE
        -: 8710:                [n < p]
        -: 8711:                    FALSE
        -: 8712:*/
    #####: 8713:            if(teken < 0)
        -: 8714:                {
    #####: 8715:                if(s < snijaf)
        -: 8716:                    {
    #####: 8717:                    return ONCE;
        -: 8718:                    }
        -: 8719:                else
        -: 8720:                    {
    #####: 8721:                    return FALSE;
        -: 8722:                    }
        -: 8723:                }
    #####: 8724:            return TRUE;
        -: 8725:            }
        -: 8726:        case NOT|GREATER_THAN:    /* n:~>p */
        -: 8727:        default:
        -: 8728:            {
        -: 8729:/*
        -: 8730:            n:~>p   n <= p
        -: 8731:                [n == p]
        -: 8732:                    TRUE | ONCE
        -: 8733:                [n > p]
        -: 8734:                    ONCE
        -: 8735:                [n < p]
        -: 8736:                    TRUE
        -: 8737:*/
    #####: 8738:            if(teken > 0)
        -: 8739:                {
    #####: 8740:                return ONCE;
        -: 8741:                }
    #####: 8742:            else if(teken < 0)
        -: 8743:                {
    #####: 8744:                return TRUE;
        -: 8745:                }
    #####: 8746:            return TRUE|ONCE;
        -: 8747:            }
        -: 8748:        }
        -: 8749:    }
        -: 8750:
    36073: 8751:static int psh(psk name,psk pknoop,psk dim)
        -: 8752:    {
        -: 8753:    /* string dient aan de eisen van icpy te voldoen */
        -: 8754:    vars *navar,*voorvar;
        -: 8755:    varia *nvaria;
        -: 8756:    psk cknoop;
        -: 8757:    int oldn,n,m2,m22;
    91753: 8758:    while(is_op(name))
        -: 8759:        {
        -: 8760:        /* return psh(name->LEFT,pknoop,dim) && psh(name->RIGHT,pknoop,dim);
        -: 8761:        18 Maart 1997 */
    19607: 8762:        if(!psh(name->LEFT,pknoop,dim))
    #####: 8763:            return FALSE;
    19607: 8764:        name = name->RIGHT;
        -: 8765:        }
    36073: 8766:    if(dim && !INTEGER(dim))
    #####: 8767:        return FALSE;
    36073: 8768:    if(!zoeknaam(name,
        -: 8769:                 &voorvar,
        -: 8770:                 &navar))
        -: 8771:        {
     4431: 8772:        insert(name,pknoop);
     4431: 8773:        if(dim)
        -: 8774:            {
        5: 8775:            zoeknaam(name,
        -: 8776:                     &voorvar,
        -: 8777:                     &navar);
        -: 8778:            }
        -: 8779:        else
        -: 8780:            {
     4426: 8781:            return TRUE;
        -: 8782:            }
        -: 8783:        }
    31647: 8784:    n = oldn = navar->n;
    31647: 8785:    if(dim)
        -: 8786:        {
        -: 8787:        int newn;
     2110: 8788:        errno = 0;
     2110: 8789:        newn = (int)STRTOUL((char *)POBJ(dim),(char **)NULL,10);
     2110: 8790:        if(errno == ERANGE)
    #####: 8791:            return FALSE;
     2110: 8792:        if(RAT_NEG(dim))
    #####: 8793:            newn = oldn - newn + 1;
     2110: 8794:        if(newn < 0)
    #####: 8795:            return FALSE;
     2110: 8796:        navar->n = newn;
     2110: 8797:        if(oldn >= navar->n)
        -: 8798:            {
        -: 8799:            assert(navar->pvaria);
     8528: 8800:            for(;oldn >= navar->n;)
     4314: 8801:                wis(Entry2(n,oldn--,navar->pvaria));
        -: 8802:            }
     2110: 8803:        navar->n--;
     2110: 8804:        if(navar->selector > navar->n)
     2107: 8805:            navar->selector = navar->n;
        -: 8806:        }
        -: 8807:    else
        -: 8808:        {
    29537: 8809:        navar->n++;
    29537: 8810:        navar->selector = navar->n;
        -: 8811:        }
    31647: 8812:    m2 = macht2(n);
    31647: 8813:    if(m2 == 0)
     9065: 8814:        m22 = 1;
        -: 8815:    else
    22582: 8816:        m22 = m2 << 1;
    31647: 8817:    if(navar->n >= m22)
        -: 8818:        /* alloceren */
        -: 8819:        {
    32971: 8820:        for(;navar->n >= m22;m22 <<= 1)
        -: 8821:            {
    16497: 8822:            nvaria = (varia*)bmalloc(__LINE__,sizeof(varia) + (m22-1)*sizeof(psk));
    16497: 8823:            nvaria->prev = navar->pvaria;
    16497: 8824:            navar->pvaria = nvaria;
        -: 8825:            }
        -: 8826:        }
    15173: 8827:    else if(navar->n < m2)
        -: 8828:        /* dealloceren */
        -: 8829:        {
     2133: 8830:        for(;m2 && navar->n < m2;m2 >>= 1)
        -: 8831:            {
       26: 8832:            nvaria = navar->pvaria;
       26: 8833:            navar->pvaria = nvaria->prev;
       26: 8834:            bfree(nvaria);
        -: 8835:            }
     2107: 8836:        if(navar->n < 0)
        -: 8837:            {
     2107: 8838:            if(voorvar)
     2032: 8839:                voorvar->next = navar->next;
        -: 8840:            else
       75: 8841:                variabelen[*POBJ(name)] = navar->next;
        -: 8842:#if PVNAME
        -: 8843:            if(navar->vname != OBJ(nilk))
        -: 8844:                bfree(navar->vname);
        -: 8845:#endif
     2107: 8846:            bfree(navar);
     2107: 8847:            return TRUE; /* 20001222 */
        -: 8848:            }
        -: 8849:        }
        -: 8850:    /*else
        -: 8851:       geen allocatie
        -: 8852:        {
        -: 8853:        }*/
        -: 8854:    assert(navar->pvaria);
   152108: 8855:    for( cknoop = pknoop
    61284: 8856:       ; ++oldn <= navar->n
    31744: 8857:       ; cknoop = *Entry(navar->n,oldn,&navar->pvaria) = zelfde_als_w(cknoop)
        -: 8858:       )
        -: 8859:       ;
    29540: 8860:    return TRUE;
        -: 8861:    }
        -: 8862:
        -: 8863:typedef struct classdef
        -: 8864:    {
        -: 8865:    char * name;
        -: 8866:    method * vtab;
        -: 8867:    } classdef;
        -: 8868:
        -: 8869:typedef struct pskRecord
        -: 8870:    {
        -: 8871:    psk entry;
        -: 8872:    struct pskRecord * next;
        -: 8873:    } pskRecord;
        -: 8874:
        -: 8875:typedef int (*cmpfuncTp)(const char *s, const char *p);
        -: 8876:typedef LONG (*hashfuncTp)(const char *s);
        -: 8877:
        -: 8878:typedef struct Hash
        -: 8879:    {
        -: 8880:    pskRecord **hash_table;
        -: 8881:    unsigned LONG hash_size;
        -: 8882:    unsigned LONG elements;     /* elements >= record_count */
        -: 8883:    unsigned LONG record_count; /* record_count >= size - unoccupied */
        -: 8884:    unsigned LONG unoccupied;
        -: 8885:    cmpfuncTp cmpfunc;
        -: 8886:    hashfuncTp hashfunc;
        -: 8887:    /*
        -: 8888:    unsigned int Dos:1;
        -: 8889:    unsigned int casesensitive:1;
        -: 8890:    */
        -: 8891:    } Hash;
        -: 8892:
       12: 8893:static LONG casesensitivehash(const char * cp)
        -: 8894:    {
       12: 8895:    LONG hash_temp = 0;
       42: 8896:    while (*cp != '\0')
        -: 8897:        {
       18: 8898:        if(hash_temp < 0)
    #####: 8899:            hash_temp = (hash_temp << 1) +1;
        -: 8900:        else
       18: 8901:            hash_temp = hash_temp << 1;
       18: 8902:        hash_temp ^= *cp;
       18: 8903:        ++cp;
        -: 8904:        }
       12: 8905:    return hash_temp;
        -: 8906:    }
        -: 8907:
        4: 8908:static LONG caseinsensitivehash(const char * cp)
        -: 8909:    {
        4: 8910:    LONG hash_temp = 0;
        4: 8911:    int isutf = 1;
       17: 8912:    while (*cp != '\0')
        -: 8913:        {
        9: 8914:        if(hash_temp < 0)
    #####: 8915:            hash_temp = (hash_temp << 1) +1;
        -: 8916:        else
        9: 8917:            hash_temp = hash_temp << 1;
        -: 8918:        /* 20060704 (int) --> (const unsigned char) */
        -: 8919:#if 0
        -: 8920:        hash_temp ^= lowerEquivalent[(const unsigned char)*cp];
        -: 8921:        ++cp;
        -: 8922:#else
        9: 8923:        hash_temp ^= toLowerUnicode(getCodePoint2((const char **)&cp,&isutf));
        -: 8924:#endif
        -: 8925:        }
        4: 8926:    return hash_temp;
        -: 8927:    }
        -: 8928:
        -: 8929:#if CODEPAGE850
        -: 8930:static LONG caseinsensitivehashDOS(const char * cp)
        -: 8931:    {
        -: 8932:    LONG hash_temp = 0;
        -: 8933:    while (*cp != '\0')
        -: 8934:        {
        -: 8935:        if(hash_temp < 0)
        -: 8936:            hash_temp = (hash_temp << 1) +1;
        -: 8937:        else
        -: 8938:            hash_temp = hash_temp << 1;
        -: 8939:        hash_temp ^= ISO8859toCodePage850(lowerEquivalent[CodePage850toISO8859(*cp)]);
        -: 8940:        ++cp;
        -: 8941:        }
        -: 8942:    return hash_temp;
        -: 8943:    }
        -: 8944:#endif
        -: 8945:
        1: 8946:static psk removeFromHash(Hash * temp,psk Arg)
        -: 8947:    {
        1: 8948:    const char * key = (const char *)POBJ(Arg);
        -: 8949:    LONG i;
        -: 8950:    LONG hash_temp;
        -: 8951:    pskRecord ** pr;
        1: 8952:    hash_temp = (*temp->hashfunc)(key);
        -: 8953:    /*i = temp->hash_size ? ((unsigned int)hash_temp) % temp->hash_size : 0;*/
        -: 8954:    assert(temp->hash_size);
        1: 8955:    i = ((unsigned int)hash_temp) % temp->hash_size;
        1: 8956:    pr = temp->hash_table + i;
        1: 8957:    if(*pr)
        -: 8958:        {
        2: 8959:        while(*pr)
        -: 8960:            {
        1: 8961:            if(kop((*pr)->entry) == LUCHT)
        -: 8962:                {
        1: 8963:                if(!(*temp->cmpfunc)(key,(const char *)POBJ((*pr)->entry->LEFT->LEFT)))
        1: 8964:                    break;
        -: 8965:                }
    #####: 8966:            else if(!(*temp->cmpfunc)(key,(const char *)POBJ((*pr)->entry->LEFT)))
    #####: 8967:               break;
    #####: 8968:            pr = &(*pr)->next;
        -: 8969:            }
        1: 8970:        if(*pr)
        -: 8971:            {
        1: 8972:            pskRecord * next = (*pr)->next;
        1: 8973:            psk ret = (*pr)->entry;
        1: 8974:            bfree(*pr);
        1: 8975:            *pr = next;
        1: 8976:            --temp->record_count; /* Bart 20040903 */
        1: 8977:            return ret;
        -: 8978:            }
        -: 8979:        }
    #####: 8980:    return NULL;
        -: 8981:    }
        -: 8982:
        8: 8983:static psk inserthash(Hash * temp,psk Arg)
        -: 8984:    {
        8: 8985:    const char * key = (const char *)POBJ(Arg->LEFT);
        -: 8986:    LONG i;
        -: 8987:    LONG hash_temp;
        -: 8988:    pskRecord * r;
        8: 8989:    hash_temp = (*temp->hashfunc)(key);
        -: 8990:    /*i = temp->hash_size ? ((unsigned int)hash_temp) % temp->hash_size : 0;*/
        -: 8991:    assert(temp->hash_size);
        8: 8992:    i = ((unsigned int)hash_temp) % temp->hash_size;
        8: 8993:    r = temp->hash_table[i];
        8: 8994:    if(!r)
        4: 8995:        --temp->unoccupied;
        -: 8996:    else
        9: 8997:        while(r)
        -: 8998:            {
        4: 8999:            if(kop(r->entry) == LUCHT)
        -: 9000:                {
        2: 9001:                if(!(*temp->cmpfunc)(key,(const char *)POBJ(r->entry->LEFT->LEFT)))
        1: 9002:                    break;
        -: 9003:                }
        2: 9004:            else if(!(*temp->cmpfunc)(key,(const char *)POBJ(r->entry->LEFT)))
        2: 9005:               break;
        1: 9006:            r = r->next;
        -: 9007:            }
        8: 9008:    if(r)
        -: 9009:        {
        3: 9010:        psk goal = (psk)bmalloc(__LINE__,sizeof(kknoop));
        3: 9011:        goal->v.fl = LUCHT | SUCCESS;
        3: 9012:        goal->ops &= ~ALL_REFCOUNT_BITS_SET;
        3: 9013:        goal->LEFT = zelfde_als_w(Arg);
        3: 9014:        goal->RIGHT = r->entry;
        3: 9015:        r->entry = goal;
        -: 9016:        }
        -: 9017:    else
        -: 9018:        {
        5: 9019:        r = (pskRecord *)bmalloc(__LINE__,sizeof(pskRecord));
        5: 9020:        r->entry = zelfde_als_w(Arg);
        5: 9021:        r->next = temp->hash_table[i];
        5: 9022:        temp->hash_table[i] = r;
        5: 9023:        ++temp->record_count;
        -: 9024:        }
        8: 9025:    ++temp->elements;
        8: 9026:    return r->entry;
        -: 9027:    }
        -: 9028:
        7: 9029:static psk findhash(Hash * temp,psk Arg)
        -: 9030:    {
        7: 9031:    const char * key = (const char *)POBJ(Arg);
        -: 9032:    LONG i;
        -: 9033:    LONG hash_temp;
        -: 9034:    pskRecord * r;
        7: 9035:    hash_temp = (*temp->hashfunc)(key);
        -: 9036:    /*i = temp->hash_size ? ((unsigned int)hash_temp) % temp->hash_size : 0;*/
        -: 9037:    assert(temp->hash_size);
        7: 9038:    i = ((unsigned int)hash_temp) % temp->hash_size;
        7: 9039:    r = temp->hash_table[i];
        7: 9040:    if(r)
        -: 9041:        {
       14: 9042:        while(r)
        -: 9043:            {
        7: 9044:            if(kop(r->entry) == LUCHT)
        -: 9045:                {
        2: 9046:                if(!(*temp->cmpfunc)(key,(const char *)POBJ(r->entry->LEFT->LEFT)))
        1: 9047:                    break;
        -: 9048:                }
        5: 9049:            else if(!(*temp->cmpfunc)(key,(const char *)POBJ(r->entry->LEFT)))
        4: 9050:               break;
        2: 9051:            r = r->next;
        -: 9052:            }
        6: 9053:        if(r)
        5: 9054:            return r->entry;
        -: 9055:        }
        2: 9056:    return NULL;
        -: 9057:    }
        -: 9058:
        8: 9059:static void freehash(Hash * temp)
        -: 9060:    {
        8: 9061:    if(temp)
        -: 9062:        {
        8: 9063:        if(temp->hash_table)
        -: 9064:            {
        -: 9065:            unsigned LONG i;
    12945: 9066:            for(i = temp->hash_size;i > 0;)
        -: 9067:                {
    12929: 9068:                pskRecord * r = temp->hash_table[--i];
        -: 9069:                pskRecord * next;
    25862: 9070:                while(r)
        -: 9071:                    {
        4: 9072:                    wis(r->entry);
        4: 9073:                    next = r->next;
        4: 9074:                    bfree(r);
        4: 9075:                    r = next;
        -: 9076:                    }
        -: 9077:                }
        8: 9078:            bfree(temp->hash_table);
        -: 9079:            }
        8: 9080:        bfree(temp);
        -: 9081:        }
        8: 9082:    }
        -: 9083:
        8: 9084:static Hash * newhash(unsigned LONG size)
        -: 9085:    {
        -: 9086:    unsigned LONG i;
        8: 9087:    Hash * temp = (Hash *)bmalloc(__LINE__,sizeof(Hash));
        -: 9088:    assert(size > 0);
        8: 9089:    temp->hash_size = size;
        8: 9090:    temp->record_count = (unsigned int)0;
        8: 9091:    temp->hash_table = (pskRecord **)bmalloc(__LINE__,sizeof(pskRecord *) * temp->hash_size);
        8: 9092:    temp->cmpfunc = strcmp;
        8: 9093:    temp->hashfunc = casesensitivehash;
        -: 9094:    /*
        -: 9095:    temp->Dos = FALSE;
        -: 9096:    temp->casesensitive = TRUE;
        -: 9097:    */
        8: 9098:    temp->elements = 0L;     /* elements >= record_count */
        8: 9099:    temp->record_count = 0L; /* record_count >= size - unoccupied */
        8: 9100:    temp->unoccupied = size;
    12945: 9101:    for(i = temp->hash_size;i > 0;)
    12929: 9102:        temp->hash_table[--i] = NULL;
        8: 9103:    return temp;
        -: 9104:    }
        -: 9105:
        1: 9106:static unsigned LONG nextprime(unsigned LONG g)
        -: 9107:    {
        -: 9108:    /* For primality test, only try divisors that are 2, 3 or 5 or greater
        -: 9109:    numbers that are not multiples of 2, 3 or 5. Candidates below 100 are:
        -: 9110:     2  3  5  7 11 13 17 19 23 29 31 37 41 43
        -: 9111:    47 49 53 59 61 67 71 73 77 79 83 89 91 97
        -: 9112:    Of these 28 candidates, three are not prime:
        -: 9113:    49 (7*7), 77 (7*11) and 91 (7*13) */
        -: 9114:    int i;
        -: 9115:    unsigned LONG smalldivisor;
        -: 9116:    static int bijt[12]=
        -: 9117:      {1,  2,  2,  4,    2,    4,    2,    4,    6,    2,  6};
        -: 9118:    /*2-3,3-5,5-7,7-11,11-13,13-17,17-19,19-23,23-29,29-1,1-7*/
        -: 9119:    unsigned LONG bigdivisor;
        1: 9120:    if(!(g & 1))
        -: 9121:        {
        1: 9122:        if(g <= 2)
        1: 9123:            return 2;
    #####: 9124:        ++g;
        -: 9125:        }
    #####: 9126:    smalldivisor = 2;
    #####: 9127:    i = 0;
    #####: 9128:    while((bigdivisor = g / smalldivisor) >= smalldivisor)
        -: 9129:        {
    #####: 9130:        if(bigdivisor * smalldivisor == g)
        -: 9131:            {
    #####: 9132:            g += 2;
    #####: 9133:            smalldivisor = 2;
    #####: 9134:            i = 0;
        -: 9135:            }
        -: 9136:        else
        -: 9137:            {
    #####: 9138:            smalldivisor += bijt[i];
    #####: 9139:            if(++i > 10)
    #####: 9140:                i = 3;
        -: 9141:            }
        -: 9142:        }
    #####: 9143:    return g;
        -: 9144:    }
        -: 9145:
        1: 9146:static void rehash(Hash ** ptemp,int loadFactor/*1-100*/)
        -: 9147:    {
        1: 9148:    Hash * temp = *ptemp;
        1: 9149:    if(temp)
        -: 9150:        {
        -: 9151:        unsigned LONG newsize;
        -: 9152:        Hash * newtable;
        -: 9153:/*
        -: 9154:        Printf("Old: size %ld unoccupied %ld records %ld elements %ld\n",
        -: 9155:            temp->hash_size,temp->unoccupied,temp->record_count,temp->elements);
        -: 9156:        Printf("rehash\n");
        -: 9157:*/
        1: 9158:        newsize = nextprime((100 * temp->record_count)/loadFactor);
        1: 9159:        if(!newsize)
    #####: 9160:            newsize = 1;
        1: 9161:        newtable = newhash(newsize);
        1: 9162:        newtable->cmpfunc = temp->cmpfunc;
        1: 9163:        newtable->hashfunc = temp->hashfunc;
        1: 9164:        if(temp->hash_table)
        -: 9165:            {
        -: 9166:            unsigned LONG i;
       99: 9167:            for(i = temp->hash_size;i > 0;)
        -: 9168:                {
       97: 9169:                pskRecord * r = temp->hash_table[--i];
      194: 9170:                while(r)
        -: 9171:                    {
    #####: 9172:                    psk pkn = r->entry;
    #####: 9173:                    while(is_op(pkn) && kop(pkn) == LUCHT)
        -: 9174:                        {
    #####: 9175:                        inserthash(newtable,pkn->LEFT);
    #####: 9176:                        pkn = pkn->RIGHT;
        -: 9177:                        }
    #####: 9178:                    inserthash(newtable,pkn);
    #####: 9179:                    r = r->next;
        -: 9180:                    }
        -: 9181:                }
        -: 9182:            }
        -: 9183:/*
        -: 9184:        Printf("New: size %ld unoccupied %ld records %ld elements %ld\n",
        -: 9185:            newtable->hash_size,newtable->unoccupied,newtable->record_count,newtable->elements);
        -: 9186:*/
        1: 9187:        freehash(temp);
        1: 9188:        *ptemp = newtable;
        -: 9189:        }
        1: 9190:    }
        -: 9191:
        9: 9192:static int loadfactor(Hash * temp)
        -: 9193:    {
        -: 9194:    /*if(!temp->hash_size)
        -: 9195:        return 100;
        -: 9196:    else */
        -: 9197:    assert(temp->hash_size);
        9: 9198:    if(temp->record_count < 10000000L)
        9: 9199:        return (int)((100 * temp->record_count) / temp->hash_size);
        -: 9200:    else
    #####: 9201:        return (int)(temp->record_count / (temp->hash_size/100));
        -: 9202:    }
        -: 9203:
        8: 9204:static Boolean hashinsert(struct typedObjectknoop * This,ppsk arg)
        -: 9205:    {
        8: 9206:    psk Arg = (*arg)->RIGHT;
        8: 9207:    if(is_op(Arg) && !is_op(Arg->LEFT))
        -: 9208:        {
        -: 9209:        psk ret;
        8: 9210:        int lf = loadfactor(HASH(This));
        8: 9211:        if(lf > 100)
        -: 9212:            /*rehash(PHASH(This),60);*/
    #####: 9213:            rehash((Hash **)(&(This->voiddata)),60);
        8: 9214:        ret = inserthash(HASH(This),Arg);
        8: 9215:        wis(*arg);
        8: 9216:        *arg = zelfde_als_w(ret);
        8: 9217:        return TRUE;
        -: 9218:        }
    #####: 9219:    return FALSE;
        -: 9220:    }
        -: 9221:
        7: 9222:static Boolean hashfind(struct typedObjectknoop * This,ppsk arg)
        -: 9223:    {
        7: 9224:    psk Arg = (*arg)->RIGHT;
        7: 9225:    if(!is_op(Arg))
        -: 9226:        {
        7: 9227:        psk ret = findhash(HASH(This),Arg);
        7: 9228:        if(ret)
        -: 9229:            {
        5: 9230:            wis(*arg);
        5: 9231:            *arg = zelfde_als_w(ret);
        5: 9232:            return TRUE;
        -: 9233:            }
        -: 9234:        }
        2: 9235:    return FALSE;
        -: 9236:    }
        -: 9237:
        1: 9238:static Boolean hashremove(struct typedObjectknoop * This,ppsk arg)
        -: 9239:    {
        1: 9240:    psk Arg = (*arg)->RIGHT;
        1: 9241:    if(!is_op(Arg))
        -: 9242:        {
        1: 9243:        Hash * temp = HASH(This);
        1: 9244:        psk ret = removeFromHash(temp,Arg);
        1: 9245:        if(ret)
        -: 9246:            {
        1: 9247:            if(loadfactor(temp) < 50 && temp->hash_size > 97)
    #####: 9248:                rehash(PHASH(This),90);
        1: 9249:            wis(*arg);
        1: 9250:            *arg = ret;
        1: 9251:            return TRUE;
        -: 9252:            }
        -: 9253:        }
    #####: 9254:    return FALSE;
        -: 9255:    }
        -: 9256:
        7: 9257:static Boolean hashnew(struct typedObjectknoop * This,ppsk arg)
        -: 9258:    {
        -: 9259:/*    UNREFERENCED_PARAMETER(arg);*/
        7: 9260:    unsigned long N = 97;
        7: 9261:    if(INTEGER_POS_COMP((*arg)->RIGHT))
        -: 9262:        {
        2: 9263:        N = strtoul((char *)POBJ((*arg)->RIGHT),NULL,10);
        2: 9264:        if(N == 0 || N == ULONG_MAX)
        1: 9265:            N = 97;
        -: 9266:        }
        7: 9267:    VOID(This) = (void *)newhash(N);
        7: 9268:    return TRUE;
        -: 9269:    }
        -: 9270:
        7: 9271:static Boolean hashdie(struct typedObjectknoop * This,ppsk arg)
        -: 9272:    {
        -: 9273:    UNREFERENCED_PARAMETER(arg);
        7: 9274:    freehash(HASH(This));
        7: 9275:    return TRUE;
        -: 9276:    }
        -: 9277:
        -: 9278:#if CODEPAGE850
        -: 9279:static Boolean hashDOS(struct typedObjectknoop * This,ppsk arg)
        -: 9280:    {
        -: 9281:    UNREFERENCED_PARAMETER(arg);
        -: 9282:    (HASH(This))->hashfunc = caseinsensitivehashDOS;
        -: 9283:    (HASH(This))->cmpfunc = strcasecmpDOS;
        -: 9284:    rehash(PHASH(This),100);
        -: 9285:    return TRUE;
        -: 9286:    }
        -: 9287:#endif
        -: 9288:
        1: 9289:static Boolean hashISO(struct typedObjectknoop * This,ppsk arg)
        -: 9290:    {
        -: 9291:    UNREFERENCED_PARAMETER(arg);
        1: 9292:    (HASH(This))->hashfunc = caseinsensitivehash;
        1: 9293:    (HASH(This))->cmpfunc = strcasecomp;
        1: 9294:    rehash(PHASH(This),100);
        1: 9295:    return TRUE;
        -: 9296:    }
        -: 9297:
    #####: 9298:static Boolean hashcasesensitive(struct typedObjectknoop * This,ppsk arg)
        -: 9299:    {
        -: 9300:    UNREFERENCED_PARAMETER(arg);
    #####: 9301:    (HASH(This))->hashfunc = casesensitivehash;
    #####: 9302:    (HASH(This))->cmpfunc = strcmp;
    #####: 9303:    rehash(PHASH(This),100);
    #####: 9304:    return TRUE;
        -: 9305:    }
        -: 9306:
        -: 9307:
    #####: 9308:static Boolean hashforall(struct typedObjectknoop * This,ppsk arg)
        -: 9309:    {
        -: 9310:    unsigned LONG i;
    #####: 9311:    int ret = TRUE;
    #####: 9312:    This = (typedObjectknoop *)zelfde_als_w((psk)This);
    #####: 9313:    for( i = 0
    #####: 9314:        ;    ret && HASH(This)
    #####: 9315:          && i < (HASH(This))->hash_size
        -: 9316:        ;
        -: 9317:       )
        -: 9318:        {
    #####: 9319:        pskRecord * r = (HASH(This))->hash_table[i];
    #####: 9320:        int j = 0;
    #####: 9321:        while(r)
        -: 9322:            {
        -: 9323:            int m;
    #####: 9324:            psk pkn = NULL;
    #####: 9325:            adr[2] = (*arg)->RIGHT; /* each time! adr[n] may be overwritten by evalueer (below)*/
    #####: 9326:            adr[3] = r->entry;
    #####: 9327:            pkn = opb(pkn,"(\2'\3)",NULL);
    #####: 9328:            pkn = eval(pkn);
    #####: 9329:            ret = isSUCCESSorFENCE(pkn);
    #####: 9330:            wis(pkn);
    #####: 9331:            if(  !ret
    #####: 9332:              || !HASH(This)
    #####: 9333:              || i >= (HASH(This))->hash_size
    #####: 9334:              || !(HASH(This))->hash_table[i]
        -: 9335:              )
        -: 9336:                break;
    #####: 9337:            ++j;
    #####: 9338:            for(m = 0,r = (HASH(This))->hash_table[i]
    #####: 9339:               ;r && m < j
    #####: 9340:               ;++m
        -: 9341:               )
    #####: 9342:                 r = r->next;
        -: 9343:            }
    #####: 9344:        ++i;
        -: 9345:        }
    #####: 9346:    wis((psk)This);
    #####: 9347:    return TRUE;
        -: 9348:    }
        -: 9349:
        -: 9350:
        -: 9351:method hash[] = {
        -: 9352:    {"find",hashfind},
        -: 9353:    {"insert",hashinsert},
        -: 9354:    {"remove",hashremove},
        -: 9355:    {"New",hashnew},
        -: 9356:    {"Die",hashdie},
        -: 9357:#if CODEPAGE850
        -: 9358:    {"DOS",hashDOS},
        -: 9359:#endif
        -: 9360:    {"ISO",hashISO},
        -: 9361:    {"casesensitive",hashcasesensitive},
        -: 9362:    {"forall",hashforall},
        -: 9363:    {NULL,NULL}};
        -: 9364:/*
        -: 9365:Standard methods are 'New' and 'Die'.
        -: 9366:A user defined 'die' can be added after creation of the object and will be invoked just before 'Die'.
        -: 9367:
        -: 9368:Example:
        -: 9369:
        -: 9370:new$hash:?h;
        -: 9371:
        -: 9372:     (=(Insert=.out$Insert & lst$its & lst$Its & (Its..insert)$!arg)
        -: 9373:      (die = .out$"Oh dear")
        -: 9374:    ):(=?(h.));
        -: 9375:
        -: 9376:    (h..Insert)$(X.x);
        -: 9377:
        -: 9378:    :?h;
        -: 9379:
        -: 9380:
        -: 9381:
        -: 9382:    (=(Insert=.out$Insert & lst$its & lst$Its & (Its..insert)$!arg)
        -: 9383:      (die = .out$"The end.")
        -: 9384:    ):(=?(new$hash:?k));
        -: 9385:
        -: 9386:    (k..Insert)$(Y.y);
        -: 9387:
        -: 9388:    :?k;
        -: 9389:
        -: 9390:A little problem is that in the last example, the '?' ends up as a flag on the '=' node.
        -: 9391:
        -: 9392:Bart 20010222
        -: 9393:
        -: 9394:*/
        -: 9395:
        -: 9396:classdef classes[] = {{"hash",hash},{NULL,NULL}};
        -: 9397:
        -: 9398:
       28: 9399:static method_pnt findBuiltInMethod(typedObjectknoop * object,psk methodName)
        -: 9400:    {
       28: 9401:    if(!is_op(methodName))
        -: 9402:        {
       28: 9403:        method * methods = object->vtab;
       28: 9404:        if(methods)
        -: 9405:            {
       28: 9406:            for(;methods->name && strcmp(methods->name,(const char *)POBJ(methodName));++methods)
        -: 9407:                ;
       28: 9408:            return methods->func;
        -: 9409:            }
        -: 9410:        }
    #####: 9411:    return NULL;
        -: 9412:    }
        -: 9413:
        -: 9414:typedef struct 
        -: 9415:    {
        -: 9416:    psk self;
        -: 9417:    psk object;
        -: 9418:    method_pnt theMethod;
        -: 9419:    } objectStuff;
        -: 9420:
      320: 9421:static psk getmember(psk name,psk tree,objectStuff * Object)
        -: 9422:    {
        -: 9423:    DBGSRC(Printf("getmember(");result(name);Printf(",");result(tree);Printf(")\n");)
      688: 9424:    while(is_op(tree))
        -: 9425:        {
      358: 9426:        if(kop(tree) == WORDT)
        -: 9427:            {
        -: 9428:            psk nname;
      205: 9429:            if(  Object
       77: 9430:              && ISBUILTIN((objectknoop*)tree)
       21: 9431:              && kop(name) == DOT
        -: 9432:              )
        -: 9433:                {
       21: 9434:                Object->object = tree;  /* object == (=) */
       21: 9435:                Object->theMethod = findBuiltInMethod((typedObjectknoop *)tree,name->RIGHT);
        -: 9436:                /* findBuiltInMethod((=),(insert)) */
       21: 9437:                if(Object->theMethod)
        -: 9438:                    {
       18: 9439:                    return NULL;
        -: 9440:                    }
        -: 9441:                }
        -: 9442:
      187: 9443:            if(kop(name) == DOT)
       13: 9444:                nname = name->LEFT;
        -: 9445:            else
      174: 9446:                nname = name;
      187: 9447:            if(vgl(tree->LEFT,nname))
       38: 9448:                return NULL;
      149: 9449:            else if(nname == name)
        -: 9450:                {
      136: 9451:                return tree->RIGHT = Head(tree->RIGHT);
        -: 9452:                }
        -: 9453:            else
        -: 9454:                {
       13: 9455:                if(Object)
        3: 9456:                    Object->self = tree->RIGHT;
       13: 9457:                name = name->RIGHT;
        -: 9458:                }
        -: 9459:            }
        -: 9460:        else
        -: 9461:            {
        -: 9462:            psk tmp;
      153: 9463:            if((tmp = getmember(name,tree->LEFT,Object)) != NULL)
        -: 9464:                {
      118: 9465:                return tmp;
        -: 9466:                }
        -: 9467:            }
       48: 9468:        tree = tree->RIGHT;
        -: 9469:        }
       10: 9470:    return NULL;
        -: 9471:    }
        -: 9472:
   934878: 9473:static psk find(psk naamknoop,int *newval,objectStuff * Object)
        -: 9474:/*
        -: 9475:'naamknoop' is the expression that has to lead to a binding.
        -: 9476:Conceptually, expression (or its complement) and binding are separated by a '=' operator.
        -: 9477:E.g.
        -: 9478:
        -: 9479:  say            =         (.out$!arg)
        -: 9480:  ---            -         -----------
        -: 9481:  expression   '='-operator     binding
        -: 9482:
        -: 9483:    say$HELLO
        -: 9484:    and
        -: 9485:    (= (.out$!arg))$HELLO
        -: 9486:
        -: 9487:      must be equivalent. Therefore, both of 'say' and its complement '(= .out$!arg)' have the binding '(.out$!arg)'.
        -: 9488:
        -: 9489:        'find' returns returns a binding or NULL.
        -: 9490:        If the function returns NULL, 'theMethod' may still be bound.
        -: 9491:        The parameter 'newval' is set to TRUE if 'doel' has increased a reference counter. (must be ignored if find returns FALSE.)
        -: 9492:        The parameter 'self' is the rhs of the root '=' of an object. It is used for non-built-ins
        -: 9493:        The parameter 'object' is the root of an object, possibly having built-in methods.
        -: 9494:
        -: 9495:
        -: 9496:Built in methods:
        -: 9497:if
        -: 9498:    new$hash:?x
        -: 9499:then
        -: 9500:    ((=).insert)$   (=) being the hash node with invisible built in method 'insert'
        -: 9501:and
        -: 9502:    (!x.insert)$
        -: 9503:and
        -: 9504:    (x..insert)$
        -: 9505:must be equivalent
        -: 9506:*/
        -: 9507:    {
        -: 9508:    vars *navar;
        -: 9509:    /* 29 juli 1993 */
        -: 9510:    DBGSRC(Printf("find(");result(naamknoop);Printf(")\n");)
   934878: 9511:    if(is_op(naamknoop))
        -: 9512:        {
      254: 9513:        switch(kop(naamknoop))
        -: 9514:            {
        -: 9515:            case WORDT: /* Lambda function: (=.out$!arg)$HELLO -> naamknoop == (=.out$!arg) */
        -: 9516:                {
       40: 9517:                *newval = TRUE;
       40: 9518:                naamknoop->RIGHT = Head(naamknoop->RIGHT);
       40: 9519:                return zelfde_als_w(naamknoop->RIGHT);
        -: 9520:                /*evalobject(doel);*/ /* This makes that (==.out$!arg)$HELLO also works, but not (===.out$!arg)$HELLO
        -: 9521:                                     so what is the meaning of this?
        -: 9522:                                    */
        -: 9523:                }
        -: 9524:            case DOT: /*
        -: 9525:                      e.g.
        -: 9526:
        -: 9527:                      (1)
        -: 9528:                            x  =  (a=2) (b=3)
        -: 9529:
        -: 9530:                            !(x.a)
        -: 9531:                      and
        -: 9532:                            !((=  (a=2) (b=3)).a)
        -: 9533:
        -: 9534:                      must give same result.
        -: 9535:
        -: 9536:                      (2)
        -: 9537:
        -: 9538:                      new$hash:?y
        -: 9539:
        -: 9540:                      ((=).insert)$
        -: 9541:                      (y..insert)$
        -: 9542:                      (!y.insert)$
        -: 9543:                      */
        -: 9544:                {
        -: 9545:                psk tmp;
        -: 9546:                psk tmp2;
        -: 9547:                psk doel;
      181: 9548:                int nieuw = FALSE;
      181: 9549:                if(is_op(naamknoop->LEFT))
        -: 9550:                    {
       29: 9551:                    if(kop(naamknoop->LEFT) == WORDT) /* naamknoop->LEFT == (=  (a=2) (b=3))   */
        -: 9552:                        {
       29: 9553:                        if(  Object
       29: 9554:                          && ISBUILTIN((objectknoop*)(naamknoop->LEFT))
        -: 9555:                          /*&& !is_op(naamknoop->RIGHT)*/
        -: 9556:                          )
        -: 9557:                            {
        7: 9558:                            Object->theMethod = findBuiltInMethod((typedObjectknoop *)(naamknoop->LEFT),naamknoop->RIGHT);
        -: 9559:                                                /* findBuiltInMethod((=),(insert)) */
        7: 9560:                            Object->object = naamknoop->LEFT;  /* object == (=) */
        7: 9561:                            if(Object->theMethod)
        -: 9562:                                {
        7: 9563:                                return NULL;
        -: 9564:                                }
        -: 9565:                            }
       22: 9566:                        tmp = naamknoop->LEFT->RIGHT; /* tmp == ((a=2) (b=3))   */
        -: 9567:                        }
        -: 9568:                    else
    #####: 9569:                        return NULL;
        -: 9570:                    }
        -: 9571:                else                                   /* x */
        -: 9572:                    {
      152: 9573:                    if((tmp = find(naamknoop->LEFT,&nieuw,NULL)) == NULL)
        7: 9574:                        return NULL;
        -: 9575:                    /*
        -: 9576:                    tmp == ((a=2) (b=3))
        -: 9577:                    tmp == (=)
        -: 9578:                    */
        -: 9579:                    }
      167: 9580:                if(Object)
       53: 9581:                    Object->self = tmp; /* self == ((a=2) (b=3))   */
        -: 9582:                /* The number of '=' to reach the method name in 'tmp' must be one greater
        -: 9583:                   than the number of '.' that precedes the method name in 'naamknoop->RIGHT'
        -: 9584:
        -: 9585:                   e.g (= (say=.out$!arg)) and (.say) match
        -: 9586:
        -: 9587:                   For built-in methods (definitions of which are not visible) an invisible '=' has to be assumed.
        -: 9588:
        -: 9589:                   The function getmember resolves this.
        -: 9590:                */
      167: 9591:                tmp2 = getmember(naamknoop->RIGHT,tmp,Object);
        -: 9592:
      167: 9593:                if(tmp2)
        -: 9594:                    {
      136: 9595:                    *newval = TRUE;
      136: 9596:                    doel = zelfde_als_w(tmp2);
        -: 9597:                    }
        -: 9598:                else
       31: 9599:                    doel = NULL;
      167: 9600:                if(nieuw)
    #####: 9601:                    wis(tmp);
      167: 9602:                return doel;
        -: 9603:                }
        -: 9604:            default:
        -: 9605:                {
       33: 9606:                *newval = FALSE;
       33: 9607:                return NULL;
        -: 9608:                }
        -: 9609:            }
        -: 9610:        }
        -: 9611:    else
        -: 9612:        {
 10147846: 9613:        for(navar = variabelen[naamknoop->u.obj];
  9213215: 9614:            navar && (STRCMP(VARNAME(navar),POBJ(naamknoop)) < 0);
  8278598: 9615:            navar = navar->next)
        -: 9616:            ;
   934624: 9617:        if(navar && !STRCMP(VARNAME(navar),POBJ(naamknoop))
   934582: 9618:           && navar->selector <= navar->n
        -: 9619:          )
        -: 9620:            {
        -: 9621:            ppsk self;
        -: 9622:            assert(navar->pvaria);
   934582: 9623:            *newval = FALSE;
   934582: 9624:            self = Entry(navar->n,navar->selector,&navar->pvaria);
   934582: 9625:            *self = Head(*self);
   934582: 9626:            return *self;
        -: 9627:            }
        -: 9628:        else
        -: 9629:            {
       42: 9630:            return NULL;
        -: 9631:            }
        -: 9632:        }
        -: 9633:    }
        -: 9634:
    33963: 9635:static int deleteNode(psk name)
        -: 9636:    {
        -: 9637:    vars *navar,*voorvar;
        -: 9638:    varia *hv;
    33963: 9639:    if(zoeknaam(name,
        -: 9640:        &voorvar,
        -: 9641:        &navar))
        -: 9642:        {
        -: 9643:        psk tmp;
        -: 9644:        assert(navar->pvaria);
    33963: 9645:        tmp = Entry2(navar->n,navar->n,navar->pvaria);
    33963: 9646:        wis(tmp);
    33963: 9647:        if(navar->n)
        -: 9648:            {
    29537: 9649:            if((navar->n)-1 < macht2(navar->n))
        -: 9650:                {
    16471: 9651:                hv = navar->pvaria;
    16471: 9652:                navar->pvaria = hv->prev;
    16471: 9653:                bfree(hv);
        -: 9654:                }
    29537: 9655:            navar->n--;
    29537: 9656:            if(navar->n < navar->selector)
    29537: 9657:                navar->selector = navar->n;
        -: 9658:            }
        -: 9659:        else
        -: 9660:            {
     4426: 9661:            if(voorvar)
      338: 9662:                voorvar->next = navar->next;
        -: 9663:            else
     4088: 9664:                variabelen[*POBJ(name)] = navar->next;
        -: 9665:#if PVNAME
        -: 9666:            if(navar->vname != OBJ(nilk))
        -: 9667:                bfree(navar->vname);
        -: 9668:#endif
     4426: 9669:            bfree(navar); /* nieuw */
        -: 9670:            }
    33963: 9671:        return TRUE;
        -: 9672:        }
        -: 9673:    else
    #####: 9674:        return FALSE;
        -: 9675:    }
        -: 9676:
        -: 9677:static psk Naamwoord_w(psk variabele,int twolevelsofindirection);
        -: 9678:
        -: 9679:/*20111101 changed signature. Before, naamwoord and naamwoord_w returned TRUE
        -: 9680:  or FALSE, while the binding was returned in a pointer-to-a-pointer.*/
   928630: 9681:static psk Naamwoord(psk variabele,int *newval,int twolevelsofindirection)
        -: 9682:/* *pbinding kan een andere waarde krijgen, ook als de boel faalt */
        -: 9683:    {
        -: 9684:    psk pbinding;
   928630: 9685:    if((pbinding = find(variabele,newval,NULL)) != NULL)
        -: 9686:        {
        -: 9687:        /*
        -: 9688:        a=b=(c=d)
        -: 9689:        e:?!(a.b)
        -: 9690:        dan krijg ik c en ken daar e aan toe, maar dat is niet de
        -: 9691:        bedoeling! Ik moet testen of ik in een object zit (self).
        -: 9692:        Als dat zo is, moet ik e toekennen aan its.c (e:?(its.c)),
        -: 9693:        zodat ik krijg a=b=c=e
        -: 9694:        */
   928588: 9695:        if(twolevelsofindirection)
        -: 9696:            {
        -: 9697:            psk peval;
        -: 9698:            
        9: 9699:            if(pbinding->v.fl & INDIRECT)
        -: 9700:                {
        2: 9701:                peval = subboomcopie(pbinding);
        2: 9702:                peval = eval(peval);
        2: 9703:                if(  !isSUCCESS(peval)
        2: 9704:                  || (  is_op(peval)
    #####: 9705:                     && kop(peval) != WORDT
    #####: 9706:                     && kop(peval) != DOT
        -: 9707:                     )
        -: 9708:                  )
        -: 9709:                    {
    #####: 9710:                    wis(peval);
    #####: 9711:                    return 0;
        -: 9712:                    }
        2: 9713:                if(*newval)
    #####: 9714:                    wis(pbinding);
        2: 9715:                *newval = TRUE;
        2: 9716:                pbinding = peval;
        -: 9717:                }
        9: 9718:            if(is_op(pbinding))
        -: 9719:                {
        2: 9720:                if(is_object(pbinding))
        -: 9721:                    {
        2: 9722:                    peval = zelfde_als_w(pbinding);
        -: 9723:                    }
        -: 9724:                else
        -: 9725:                    {
    #####: 9726:                    peval = subboomcopie(pbinding);
        -: 9727:                    /*
        -: 9728:                    a=b=(c.d)
        -: 9729:                    c=(d=e)
        -: 9730:                    f:?!!(a.b)
        -: 9731:                    dan sta ik hier met (c.d)
        -: 9732:                    bedoeling is dat ik e vind, zodat
        -: 9733:                    ik f kan toekennen aan e.
        -: 9734:                    */
    #####: 9735:                    peval = eval(peval);
    #####: 9736:                    if(  !isSUCCESS(peval)
    #####: 9737:                      || (  is_op(peval)
    #####: 9738:                         && kop(peval) != WORDT
    #####: 9739:                         && kop(peval) != DOT
        -: 9740:                         )
        -: 9741:                      )
        -: 9742:                        {
    #####: 9743:                        wis(peval);
    #####: 9744:                        pbinding = NULL;
        -: 9745:                        }
        -: 9746:                    }
        2: 9747:                if(pbinding)
        -: 9748:                    {
        2: 9749:                    if(*newval)
        -: 9750:                        {
    #####: 9751:                        *newval = FALSE;
    #####: 9752:                        wis(pbinding);
        -: 9753:                        }
        2: 9754:                    if((pbinding = Naamwoord(peval,newval,(peval->v.fl & DOUBLY_INDIRECT))) != NULL)
        -: 9755:                        {
        2: 9756:                        wis(peval);
        -: 9757:                        }
        -: 9758:                    else
        -: 9759:                        {
    #####: 9760:                        wis(peval);
    #####: 9761:                        pbinding = NULL;
        -: 9762:                        }
        -: 9763:                    }
    #####: 9764:                else if(*newval)
        -: 9765:                    {
    #####: 9766:                    *newval = FALSE;
    #####: 9767:                    wis(pbinding);
        -: 9768:                    }
        -: 9769:                }
        -: 9770:            else
        -: 9771:                {
        7: 9772:                int newv = *newval;
        -: 9773:                psk binding;
        7: 9774:                *newval = FALSE;
        7: 9775:                binding = Naamwoord(pbinding,newval,pbinding->v.fl & DOUBLY_INDIRECT);
        7: 9776:                if(newv)
        -: 9777:                    {
        4: 9778:                    wis(pbinding);
        -: 9779:                    }
        7: 9780:                pbinding = binding;
        -: 9781:                }
        -: 9782:            }
        -: 9783:        }
        -: 9784:    else
        -: 9785:        {
       42: 9786:        pbinding = NULL;
        -: 9787:        }
   928630: 9788:    return pbinding;
        -: 9789:    }
        -: 9790:
   928621: 9791:static psk Naamwoord_w(psk variabele,int twolevelsofindirection)
        -: 9792:/*20120919 twolevelsofindirection because the variable not always can have the
        -: 9793:bangs. Example: 
        -: 9794:  (A==B)  &  a b c:? [?!!A
        -: 9795:first finds (=B), which is an object that should not obtain the flags !! as in
        -: 9796:!!(=B), because that would have a side effect on A as A=!!(=B)
        -: 9797:*/
        -: 9798:    {
        -: 9799:    psk pbinding;
        -: 9800:    int newval;
   928621: 9801:    newval = FALSE;
        -: 9802:    DBGSRC(printf("Naamwoord_w(");result(variabele);printf(")\n");)
   928621: 9803:    if((pbinding = Naamwoord(variabele,&newval,twolevelsofindirection)) != NULL)
        -: 9804:        {
        -: 9805:        unsigned int nameflags,valueflags;
   928579: 9806:        nameflags = (variabele->v.fl & (ERFENIS|SUCCESS));
   928579: 9807:        if(ANYNEGATION(variabele->v.fl))
       54: 9808:            nameflags |= NOT;
        -: 9809:
   928579: 9810:        valueflags = (pbinding)->v.fl;
   928579: 9811:        valueflags |= (nameflags & (ERFENIS|NOT));
   928579: 9812:        valueflags ^= ((nameflags & SUCCESS) ^ SUCCESS);
        -: 9813:
        -: 9814:        assert(pbinding != NULL);
        -: 9815:        DBGSRC(printf("pbinding:");result(pbinding);printf("\n");)
        -: 9816:
   928579: 9817:        if(kop(pbinding) == WORDT/*20120918*/ || (pbinding)->v.fl == valueflags)
        -: 9818:            {
  1843654: 9819:            if(!newval)
        -: 9820:                {
   921805: 9821:                pbinding = zelfde_als_w(pbinding);
        -: 9822:                }
        -: 9823:            }
        -: 9824:        else
        -: 9825:            {
        -: 9826:            assert(kop(pbinding) != WORDT);
     6752: 9827:            if(newval)
        -: 9828:                {
        -: 9829:                DBGSRC(printf("prive\n");)
      103: 9830:                pbinding = prive(pbinding);
        -: 9831:                }
        -: 9832:            else
        -: 9833:                {
        -: 9834:                DBGSRC(printf("subboomcopie\n");)
     6649: 9835:                pbinding = subboomcopie(pbinding);
        -: 9836:                }
     6752: 9837:            (pbinding)->v.fl = valueflags & ~ALL_REFCOUNT_BITS_SET;
        -: 9838:            }
        -: 9839:        }
        -: 9840:    else
       42: 9841:        pbinding = NULL;
   928621: 9842:    return pbinding;
        -: 9843:    }
        -: 9844:
        -: 9845:#if !DEBUGBRACMAT
        -: 9846:#define match(IND,SUB,PAT,SNIJAF,POS,LENGTH,OP) match(SUB,PAT,SNIJAF,POS,LENGTH,OP)
        -: 9847:#if CUTOFFSUGGEST
        -: 9848:#define stringmatch(IND,WH,SUB,SNIJAF,PAT,PKN,POS,LENGTH,SUGGESTEDCUTOFF,MAYMOVESTARTOFSUBJECT) stringmatch(SUB,SNIJAF,PAT,PKN,POS,LENGTH,SUGGESTEDCUTOFF,MAYMOVESTARTOFSUBJECT)
        -: 9849:#else
        -: 9850:#define stringmatch(IND,WH,SUB,SNIJAF,PAT,PKN,POS,LENGTH) stringmatch(SUB,SNIJAF,PAT,PKN,POS,LENGTH)
        -: 9851:#endif
        -: 9852:#endif
        -: 9853:
   365568: 9854:static void cleanOncePattern(psk pat) /* 20070222 */
        -: 9855:    {
   365568: 9856:    pat->v.fl &= ~IMPLIEDFENCE;
   365568: 9857:    if(is_op(pat))
        -: 9858:        {
    42814: 9859:        cleanOncePattern(pat->LEFT);
    42814: 9860:        cleanOncePattern(pat->RIGHT);
        -: 9861:        }
   365568: 9862:    }
        -: 9863:
        -: 9864:
   257384: 9865:static int stringOncePattern(psk pat) /* 20070222 */
        -: 9866:    {
        -: 9867:    /*
        -: 9868:    This function has a side effect: it sets a flag in all pattern nodes that
        -: 9869:    can be matched by at most one non-trivial list element (a nonzero term in
        -: 9870:    a sum, a factor in a product that is not 1, or a nonempty word in a
        -: 9871:    sentence. Because the function depends on ATOMFILTERS, the algorithm
        -: 9872:    should be slightly different for normal matches and for string matches.
        -: 9873:    Ideally, two flags should be reserved.
        -: 9874:    */
   257384: 9875:    if(pat->v.fl & IMPLIEDFENCE)
        -: 9876:        {
     1421: 9877:        return TRUE;
        -: 9878:        }
   255963: 9879:    if(pat->v.fl & SATOMFILTERS)
        -: 9880:        {
        7: 9881:        pat->v.fl |= IMPLIEDFENCE;
        7: 9882:        return TRUE;
        -: 9883:        }
   255956: 9884:    else if(pat->v.fl & ATOMFILTERS)
        -: 9885:        {
     1559: 9886:        return FALSE;
        -: 9887:        }
   254397: 9888:    else if (  IS_VARIABLE(pat)
   234816: 9889:            || NIKS(pat)
   233739: 9890:            || (pat->v.fl & NONIDENT) /*20100406 @(abc:% c) */
        -: 9891:            )
    20784: 9892:        return FALSE;
   233613: 9893:    else if(!is_op(pat))
        -: 9894:        {
    94215: 9895:        if(!pat->u.obj)
        -: 9896:            {
       55: 9897:            pat->v.fl |= IMPLIEDFENCE;
       55: 9898:            return TRUE;
        -: 9899:            }
        -: 9900:        else
        -: 9901:            {
    94160: 9902:            return FALSE;
        -: 9903:            }
        -: 9904:        }
        -: 9905:    else
        -: 9906:        {
   139398: 9907:        switch(kop(pat))
        -: 9908:            {
        -: 9909:            case DOT:
        -: 9910:            case KOMMA:
        -: 9911:            case WORDT:
        -: 9912:            case EXP:
        -: 9913:            case LOG:
        -: 9914:            case DIF:
    #####: 9915:                pat->v.fl |= IMPLIEDFENCE;
    #####: 9916:                return TRUE;
        -: 9917:            case OF:
     6545: 9918:                if(stringOncePattern(pat->LEFT) && stringOncePattern(pat->RIGHT))
        -: 9919:                    {
        2: 9920:                    pat->v.fl |= IMPLIEDFENCE;
        2: 9921:                    return TRUE;
        -: 9922:                    }
     6543: 9923:                break;
        -: 9924:            case MATCH:
     2191: 9925:                if(stringOncePattern(pat->LEFT) || stringOncePattern(pat->RIGHT))
        -: 9926:                    {
    #####: 9927:                    pat->v.fl |= IMPLIEDFENCE;
    #####: 9928:                    return TRUE;
        -: 9929:                    }
     2191: 9930:                break;
        -: 9931:            case EN:
    44675: 9932:                if(stringOncePattern(pat->LEFT))
        -: 9933:                    {
    #####: 9934:                    pat->v.fl |= IMPLIEDFENCE;
    #####: 9935:                    return TRUE;
        -: 9936:                    }
    44675: 9937:                break;
        -: 9938:            default:
    85987: 9939:                break;
        -: 9940:            }
        -: 9941:        }
   139396: 9942:    return FALSE;
        -: 9943:    }
        -: 9944:
        -: 9945:
  3229880: 9946:static int oncePattern(psk pat) /* 20070222 */
        -: 9947:    {
        -: 9948:    /*
        -: 9949:    This function has a side effect: it sets a flag in all pattern nodes that
        -: 9950:    can be matched by at most one non-trivial list element (a nonzero term in
        -: 9951:    a sum, a factor in a product that is not 1, or a nonempty word in a
        -: 9952:    sentence. Because the function depends on ATOMFILTERS, the algorithm
        -: 9953:    should be slightly different for normal matches and for string matches.
        -: 9954:    Ideally, two flags should be reserved.
        -: 9955:    */
  3229880: 9956:    if(pat->v.fl & IMPLIEDFENCE)
        -: 9957:        {
   555182: 9958:        return TRUE;
        -: 9959:        }
  2674698: 9960:    if((pat->v.fl & ATOM) && ONTKENNING(pat->v.fl, ATOM)) /*20100126*/
        -: 9961:        {
       19: 9962:        return FALSE;
        -: 9963:        }
  2674679: 9964:    else if(pat->v.fl & ATOMFILTERS)
        -: 9965:        {
      696: 9966:        pat->v.fl |= IMPLIEDFENCE;
      696: 9967:        return TRUE;
        -: 9968:        }
  2673983: 9969:    else if (  IS_VARIABLE(pat)
  1721973: 9970:            || NIKS(pat)
  1721149: 9971:            || (pat->v.fl & NONIDENT) /*20100406*/ /*{?} a b c:% c => a b c */
        -: 9972:            )
  1528373: 9973:        return FALSE;
  1145610: 9974:    else if(!is_op(pat))
        -: 9975:        {
   265181: 9976:        pat->v.fl |= IMPLIEDFENCE;
   265181: 9977:        return TRUE;
        -: 9978:        }
        -: 9979:    else
   880429: 9980:        switch(kop(pat))
        -: 9981:        {
        -: 9982:            case DOT:
        -: 9983:            case KOMMA:
        -: 9984:            case WORDT:
        -: 9985:            /*case EXP: 20100806*/
        -: 9986:            case LOG:
        -: 9987:            case DIF:
    19098: 9988:                pat->v.fl |= IMPLIEDFENCE;
    19098: 9989:                return TRUE;
        -: 9990:            case OF:
    23534: 9991:                if(oncePattern(pat->LEFT) && oncePattern(pat->RIGHT))
        -: 9992:                    {
       11: 9993:                    pat->v.fl |= IMPLIEDFENCE;
       11: 9994:                    return TRUE;
        -: 9995:                    }
    23523: 9996:                break;
        -: 9997:            case MATCH:
    15574: 9998:                if(oncePattern(pat->LEFT) || oncePattern(pat->RIGHT))
        -: 9999:                    {
       72:10000:                    pat->v.fl |= IMPLIEDFENCE;
       72:10001:                    return TRUE;
        -:10002:                    }
    15502:10003:                break;
        -:10004:            case EN:
    46372:10005:                if(oncePattern(pat->LEFT))
        -:10006:                    {
       17:10007:                    pat->v.fl |= IMPLIEDFENCE;
       17:10008:                    return TRUE;
        -:10009:                    }
    46355:10010:                break;
        -:10011:            default:
   775851:10012:                break;
        -:10013:        }
   861231:10014:    return FALSE;
        -:10015:    }
        -:10016:
        -:10017:#define SHIFT_SAV 0
        -:10018:#define SHIFT_LMR 8
        -:10019:#define SHIFT_RMR 16
        -:10020:#define SHIFT_ONCE 24
        -:10021:
        -:10022:typedef union matchstate
        -:10023:    {
        -:10024:#ifndef NDEBUG
        -:10025:    struct
        -:10026:        {
        -:10027:        unsigned int bsave                      :8;
        -:10028:
        -:10029:        unsigned int blmr_true                  :1;
        -:10030:        unsigned int blmr_success               :1; /* SUCCESS */
        -:10031:        unsigned int blmr_pristine              :1;
        -:10032:        unsigned int blmr_once                  :1;
        -:10033:        unsigned int blmr_position_once         :1;
        -:10034:        unsigned int blmr_position_max_reached  :1;
        -:10035:        unsigned int blmr_fence                 :1; /* FENCE */
        -:10036:        unsigned int blmr_unused_15             :1;
        -:10037:
        -:10038:        unsigned int brmr_true                  :1;
        -:10039:        unsigned int brmr_success               :1; /* SUCCESS */
        -:10040:        unsigned int brmr_pristine              :1;
        -:10041:        unsigned int brmr_once                  :1;
        -:10042:        unsigned int brmr_position_once         :1;
        -:10043:        unsigned int brmr_position_max_reached  :1;
        -:10044:        unsigned int brmr_fence                 :1; /* FENCE */
        -:10045:        unsigned int brmr_unused_23             :1;
        -:10046:
        -:10047:        unsigned int unused_24_26               :3;
        -:10048:        unsigned int bonce                      :1;
        -:10049:        unsigned int unused_28_31               :4;
        -:10050:        } b;
        -:10051:#endif
        -:10052:    struct
        -:10053:        {
        -:10054:        char sav;
        -:10055:        char lmr;
        -:10056:        char rmr;
        -:10057:        unsigned char once;
        -:10058:        } c;
        -:10059:    unsigned int i;
        -:10060:    } matchstate;
        -:10061:
        -:10062:#if DEBUGBRACMAT
        -:10063:#ifndef NDEBUG
        -:10064:static void printMatchState(const char * msg,matchstate s,int pos,int len)
        -:10065:    {
        -:10066:/*    return;*/
        -:10067:    Printf("\n%s pos %d len %d once %d",msg,pos,len,s.b.bonce);
        -:10068:    Printf("\n     t o p m f i");
        -:10069:    Printf("\n lmr %d %d %d %d %d %d",
        -:10070:        s.b.blmr_true,s.b.blmr_once,s.b.blmr_position_once,s.b.blmr_position_max_reached,s.b.blmr_fence,s.b.blmr_pristine);
        -:10071:    Printf("\n rmr %d %d %d %d %d %d\n",
        -:10072:        s.b.brmr_true,s.b.brmr_once,s.b.brmr_position_once,s.b.brmr_position_max_reached,s.b.brmr_fence,s.b.brmr_pristine);
        -:10073:    }
        -:10074:#endif
        -:10075:#endif
        -:10076:
       44:10077:static LONG expressionLength(psk pkn,unsigned int op)
        -:10078:    {
       44:10079:    if(!is_op(pkn) && pkn->u.lobj == knil[op >> OPSH]->u.lobj)
        9:10080:        return 0;
        -:10081:    else
        -:10082:        {
       35:10083:        LONG len = 1;
      639:10084:        while(kop(pkn) == op)
        -:10085:            {
      569:10086:            ++len;
      569:10087:            pkn = pkn->RIGHT;
        -:10088:            }
       35:10089:        return len;
        -:10090:        }
        -:10091:    }
        -:10092:
      730:10093:static char doPosition(matchstate s,psk pat,LONG pposition,size_t stringLength,psk expr
        -:10094:#if CUTOFFSUGGEST
        -:10095:                      ,char ** mayMoveStartOfSubject
        -:10096:#endif
        -:10097:                      ,unsigned int op
        -:10098:                       )
        -:10099:    {
        -:10100:    unsigned int Flgs;
        -:10101:    psk name;
        -:10102:    LONG pos;
      730:10103:    Flgs = pat->v.fl;
        -:10104:#if CUTOFFSUGGEST
      730:10105:    if(  ((Flgs & (SUCCESS|VISIBLE_FLAGS_POS0|/*20120208*/IS_OPERATOR)) == (SUCCESS|QGETAL))
      107:10106:      && mayMoveStartOfSubject 
       45:10107:      && *mayMoveStartOfSubject != 0
        -:10108:      )
        -:10109:        {
       45:10110:        pos = toLong(pat); /* [20 */
       45:10111:        if(pos < 0)
        5:10112:            pos += (expr == NULL ? (LONG)stringLength : expr ? expressionLength(expr,op) : 0) + 1; /* [(20+-1*(!len+1)) -> `-7 */
        -:10113:
       45:10114:        if(  pposition < pos 
       37:10115:          && (MORE_EQUAL(pat) || EQUAL(pat) || NOTLESSORMORE(pat))
        -:10116:          )
        -:10117:            {
       32:10118:            if((long)stringLength > pos)
       28:10119:                *mayMoveStartOfSubject += pos - pposition;
       32:10120:            s.c.rmr = FALSE; /* [20 */
       32:10121:            return s.c.rmr;
        -:10122:            }
       13:10123:        else if(  pposition <= pos 
       11:10124:               && MORE(pat)
        -:10125:               )
        -:10126:            {
        6:10127:            if((long)stringLength > pos)
        6:10128:                *mayMoveStartOfSubject += pos - pposition + 1;
        6:10129:            s.c.rmr = FALSE; /* [>5 */
        6:10130:            return s.c.rmr;
        -:10131:            }
        -:10132:        }
        -:10133:#endif
      692:10134:    Flgs = pat->v.fl & (UNIFY|INDIRECT|DOUBLY_INDIRECT);
        -:10135:
        -:10136:    DBGSRC(printf("patA:");result(pat);printf("\n");)
      692:10137:    name = subboomcopie(pat);
      692:10138:    name->v.fl |= SUCCESS;
      692:10139:    if((Flgs & UNIFY) && (is_op(pat) || (FLGS & INDIRECT)))
        -:10140:        {
       58:10141:        name->v.fl &= ~VISIBLE_FLAGS;
       58:10142:        if(!is_op(name))
       57:10143:            name->v.fl |= READY;
       58:10144:        s.c.rmr = (char)evalueer(name) & TRUE;
        -:10145:
       58:10146:        if (!(s.c.rmr))
        -:10147:            {
    #####:10148:            wis(name);
    #####:10149:            return FALSE;
        -:10150:            }
        -:10151:        }
        -:10152:    else
        -:10153:        {
        -:10154:        DBGSRC(printf("patA:");result(pat);printf("\n");)
      634:10155:        s.c.rmr = (char)evalueer(name) & TRUE;
        -:10156:
      634:10157:        if (!(s.c.rmr))
        -:10158:            { 
       14:10159:            wis(name);
       14:10160:            return FALSE;
        -:10161:            }
        -:10162:
      620:10163:        Flgs = pat->v.fl & UNIFY;
      620:10164:        Flgs |= name->v.fl;
        -:10165:        }
      678:10166:    pat = name;
        -:10167:    DBGSRC(printf("patB:");result(pat);printf("\n");)
      678:10168:    if(Flgs & UNIFY)
        -:10169:        {
       59:10170:        if (  is_op(pat)
       59:10171:           || pat->u.obj
        -:10172:           )
        -:10173:            {
      118:10174:            if (Flgs & INDIRECT)        /* ?! of ?!! */
        -:10175:                {
        -:10176:                psk loc;
        3:10177:                if ((loc=Naamwoord_w(pat,Flgs & DOUBLY_INDIRECT)) != NULL)
        -:10178:                    {
        3:10179:                    if (is_object(loc))
        2:10180:                        s.c.rmr = (char)icopy_insert(loc,pposition);
        -:10181:                    else
        -:10182:                        {
        1:10183:                        s.c.rmr = (char)evalueer(loc) & (TRUE|FENCE);
        1:10184:                        if(!icopy_insert(loc,pposition))
    #####:10185:                            s.c.rmr = FALSE;
        -:10186:                        }
        3:10187:                    wis(loc);
        -:10188:                    }
        -:10189:                }
        -:10190:            else
        -:10191:                {
       56:10192:                s.c.rmr = (char)icopy_insert(pat,pposition); /* [?a */
        -:10193:                }
        -:10194:            }
        -:10195:        else
    #####:10196:            s.c.rmr = TRUE;
        -:10197:
       59:10198:        if(name)
       59:10199:            wis(name); /* [?a */
        -:10200:        /*s.c.rmr |= (char)(Flgs & FENCE); 20111216 */
        -:10201:        /*
        -:10202:          (   ( CharacterLength
        -:10203:              =   length c p q
        -:10204:                .     0:?length:?p
        -:10205:                    & @( !arg
        -:10206:                       :   ?
        -:10207:                           ( [!p %?c [?q
        -:10208:                           & utf$!c:?k
        -:10209:                           & !q:?p
        -:10210:                           & 1+!length:?length
        -:10211:                           & ~
        -:10212:                           )
        -:10213:                           ?
        -:10214:                       )
        -:10215:                  | !length
        -:10216:              )
        -:10217:            & CharacterLength$str$(a chu$1000 b chu$100000 c):5
        -:10218:          )
        -:10219:        */
       59:10220:        return (char)(ONCE | POSITION_ONCE | s.c.rmr);
        -:10221:        }
        -:10222:
      619:10223:    if( ((pat->v.fl & (SUCCESS|VISIBLE_FLAGS_POS0|IS_OPERATOR)) == (SUCCESS|QGETAL)))
        -:10224:        {
      597:10225:        pos = toLong(pat); /* [20 */
        -:10226:        DBGSRC(Printf("pat:");result(pat);Printf("\n");)
      597:10227:        if(pos < 0)
       68:10228:            pos += (expr == NULL ? (LONG)stringLength : expressionLength(expr,op)) + 1; /* [(20+-1*(!len+1)) -> `-7 */
      597:10229:        if(LESS(pat))
        -:10230:            { /* [<18 */
        1:10231:            if(pposition < pos)
        -:10232:                {
        1:10233:                s.c.rmr = TRUE;/* [<18 */
        -:10234:                }
        -:10235:            else
        -:10236:                {
    #####:10237:                s.c.rmr = FALSE|POSITION_MAX_REACHED;
        -:10238:                }
        -:10239:            }
      596:10240:        else if(LESS_EQUAL(pat))
        -:10241:            {
    #####:10242:            if(pposition < pos)
        -:10243:                {
    #####:10244:                s.c.rmr = TRUE;
        -:10245:                }
    #####:10246:            else if(pposition == pos)
        -:10247:                {
    #####:10248:                s.c.rmr = TRUE|POSITION_MAX_REACHED;
        -:10249:                }
        -:10250:            else
        -:10251:                {
    #####:10252:                s.c.rmr = FALSE|POSITION_MAX_REACHED;
        -:10253:                }
        -:10254:            }
      596:10255:        else if(MORE_EQUAL(pat))
        -:10256:            { /* [~<13 */
        2:10257:            if(pposition >= pos)
        -:10258:                {
        2:10259:                s.c.rmr = TRUE; /* [~<13 */
        -:10260:                }
        -:10261:            else
        -:10262:                {
    #####:10263:                s.c.rmr = FALSE; /* [~<13 */
        -:10264:                }
        -:10265:            }
      594:10266:        else if(MORE(pat))
        -:10267:            { /* [>5 */
        1:10268:            if(pposition > pos)
        -:10269:                {
        1:10270:                s.c.rmr = TRUE; /* [>5 */
        -:10271:                }
        -:10272:            else
        -:10273:                {
    #####:10274:                s.c.rmr = FALSE; /* [>5 */
        -:10275:                }
        -:10276:            }
      593:10277:        else if(UNEQUAL(pat) || LESSORMORE(pat))
        -:10278:            { /* [~13 */
        4:10279:            if(pposition != pos)
        -:10280:                {
        1:10281:                s.c.rmr = TRUE; /* [~13 */
        -:10282:                }
        -:10283:            else
        -:10284:                {
        1:10285:                s.c.rmr = FALSE; /* [~13 */
        -:10286:                }
        -:10287:            }
      591:10288:        else if(EQUAL(pat) || NOTLESSORMORE(pat))
        -:10289:            {
      591:10290:            if(pposition == pos)
        -:10291:                {
       78:10292:                s.c.rmr = TRUE|POSITION_MAX_REACHED; /* [20 */
        -:10293:                }
      513:10294:            else if(pposition > pos)
        -:10295:                {
    #####:10296:                s.c.rmr = FALSE|POSITION_MAX_REACHED;
        -:10297:                }
        -:10298:            else
      513:10299:                s.c.rmr = FALSE; /* [20 */
        -:10300:            }
        -:10301:        }
        -:10302:    else
        -:10303:        {
       22:10304:        s.c.rmr = FALSE;
        -:10305:        }
      619:10306:    wis(pat); /* [20 */
      619:10307:    s.c.rmr |= ONCE | POSITION_ONCE;
        -:10308:    /*Printf("POSITION pos %d len %d once %d\n",pposition,stringLength,s.b.bonce);
        -:10309:    printMatchState("POSITION",s,pposition,stringLength);*/
      619:10310:    return s.c.rmr;
        -:10311:    /*return ONCE | POSITION_ONCE | s.c.rmr;*/
        -:10312:    }
        -:10313:
     1454:10314:static int atomtest(psk kn)
        -:10315:    {
     1454:10316:    return (!is_op(kn) && !HAS_UNOPS(kn)) ? (int)kn->u.obj : -1;
        -:10317:    }
        -:10318:
       65:10319:static char sdoEval(char * sub,char * snijaf, psk pat, psk subkn)
        -:10320:    {
        -:10321:    char ret;
        -:10322:    psk loc;
       65:10323:    psh(&sjt,&nilk,NULL);
       65:10324:    string_copy_insert(&sjt,subkn,sub,snijaf);
       65:10325:    loc = subboomcopie(pat); /*20111221*/
       65:10326:    loc->v.fl &= ~(POSITION|NONIDENT|IMPLIEDFENCE|ONCE);
       65:10327:    loc = eval(loc);
       65:10328:    deleteNode(&sjt);
       65:10329:    if(isSUCCESS(loc))
        -:10330:        {
        4:10331:        ret = (loc->v.fl & FENCE) ? (TRUE|ONCE) : TRUE;
        -:10332:        }
        -:10333:    else
        -:10334:        {
       61:10335:        ret = (loc->v.fl & FENCE) ? ONCE : FALSE;
        -:10336:        }
       65:10337:    wis(loc);
       65:10338:    return ret;
        -:10339:    }
        -:10340:
        -:10341:/* 
        -:10342:    ( Dogs and Cats are friends: ? [%(out$(!sjt SJT)&~) (|))&
        -:10343:    ( Dogs and Cats are friends: ? [%(out$(!sjt)&~) (|))&
        -:10344:*/
        3:10345:static char doEval(psk sub,psk snijaf, psk pat)
        -:10346:    {
        -:10347:    char ret;
        -:10348:    psk loc;
        3:10349:    psh(&sjt,&nilk,NULL);
        3:10350:    copy_insert(&sjt, sub, snijaf);
        3:10351:    loc = subboomcopie(pat); /*20111221*/
        3:10352:    loc->v.fl &= ~(POSITION|NONIDENT|IMPLIEDFENCE|ONCE);
        3:10353:    loc = eval(loc);
        3:10354:    deleteNode(&sjt);
        3:10355:    if(isSUCCESS(loc))
        -:10356:        {
        1:10357:        ret = (loc->v.fl & FENCE) ? (TRUE|ONCE) : TRUE;
        -:10358:        }
        -:10359:    else
        -:10360:        {
        2:10361:        ret = (loc->v.fl & FENCE) ? ONCE : FALSE;
        -:10362:        }
        3:10363:    wis(loc);
        -:10364:    
        3:10365:    return ret;
        -:10366:    }
        -:10367:
        -:10368:
        -:10369:#if CUTOFFSUGGEST
   201804:10370:static char stringmatch
        -:10371:        (int ind
        -:10372:        ,char * wh
        -:10373:        ,char * sub
        -:10374:        ,char * snijaf
        -:10375:        , psk pat
        -:10376:        , psk subkn
        -:10377:        , LONG pposition
        -:10378:        ,size_t stringLength
        -:10379:        ,char ** suggestedCutOff /*20120102*/
        -:10380:        ,char ** mayMoveStartOfSubject /*20120107*/
        -:10381:        )
        -:10382:#else
        -:10383:static char stringmatch
        -:10384:        (int ind
        -:10385:        ,char * wh
        -:10386:        ,unsigned char * sub
        -:10387:        ,unsigned char * snijaf
        -:10388:        , psk pat
        -:10389:        , psk subkn
        -:10390:        , LONG pposition
        -:10391:        ,size_t stringLength
        -:10392:        )
        -:10393:#endif
        -:10394:    {
        -:10395:/*
        -:10396:s.c.lmr of s.c.rmr hebben 3 onafhankelijke vlaggen : TRUE/FALSE, ONCE en FENCE.
        -:10397:TRUE/FALSE Het slagen van de match.
        -:10398:ONCE       Onbereidheid van het patroon om andere subjecten te matchen.
        -:10399:           Van belang voor patroon met spatie, + of * operator.
        -:10400:           Wordt in patronen aangezet door de `@#/ vlaggen en de operatoren
        -:10401:           anders dan spatie + * _ & : | = $ '.
        -:10402:           Wordt uitgezet in patroon met spatie + * of | operator.
        -:10403:FENCE      Onbereidheid van het subject om door alternatieve patronen gematcht
        -:10404:           te worden. Van belang voor de | en : operatoren in een patroon.
        -:10405:           Wordt aangezet door ` vlag (al dan niet in een patroon).
        -:10406:           Wordt uitgezet in patroon met spatie + * | of : operator.
        -:10407:           (Bij | en : operatoren geldt dit alleen voor de linkeroperand,
        -:10408:           bij de andere voor alle behalve de laatste operand in een lijst.)
        -:10409:*/
        -:10410:    psk loc;
        -:10411:    char * sloc;
        -:10412:    unsigned int Flgs;
        -:10413:    matchstate s;
        -:10414:    int ci;
   201804:10415:    psk name = NULL;
        -:10416:    assert(sizeof(s) == 4);
   201804:10417:    if(!snijaf)
      321:10418:        snijaf = sub+stringLength;
        -:10419:#if CUTOFFSUGGEST
   201804:10420:    if(NIKS(pat) && (is_op(pat) || !pat->u.obj))
        -:10421:        {
      410:10422:        suggestedCutOff = NULL;
        -:10423:        }
        -:10424:#endif
        -:10425:    DBGSRC(int redMooi;int redhum;redMooi = mooi;redhum = hum;mooi = FALSE;\
        -:10426:        hum = FALSE;Printf("%d  %.*s|%s",ind,snijaf-sub,sub,snijaf);\
        -:10427:        Printf(":");result(pat);\
        -:10428:        Printf  (",pos=%ld,sLen=%ld,sugCut=%s,mayMoveStart=%s)"\
        -:10429:                ,pposition\
        -:10430:                ,(long int)stringLength\
        -:10431:                ,suggestedCutOff ? *suggestedCutOff ? *suggestedCutOff : (char*)"(0)" : (char*)"0"\
        -:10432:                ,mayMoveStartOfSubject ? *mayMoveStartOfSubject ? *mayMoveStartOfSubject : (char*)"(0)" : (char*)"0"\
        -:10433:                );\
        -:10434:        Printf("\n");mooi = redMooi;hum = redhum;)
   201804:10435:    s.i = (PRISTINE << SHIFT_LMR) + (PRISTINE << SHIFT_RMR);
        -:10436:
   201804:10437:    Flgs = pat->v.fl;
   201804:10438:    if(Flgs & POSITION)
        -:10439:        {
      776:10440:        if(Flgs & NONIDENT)
       65:10441:            return sdoEval(sub,snijaf,pat,subkn);
      711:10442:        else if(snijaf > sub)
        -:10443:            {
        -:10444:#if CUTOFFSUGGEST
       76:10445:            if(mayMoveStartOfSubject && *mayMoveStartOfSubject)
        -:10446:                {
       74:10447:                *mayMoveStartOfSubject = snijaf;
        -:10448:                }
        -:10449:#endif
       76:10450:            return FALSE | ONCE | POSITION_ONCE;
        -:10451:            }
        -:10452:        else
      635:10453:            return doPosition(s,pat,pposition,stringLength,NULL
        -:10454:#if CUTOFFSUGGEST
        -:10455:            ,mayMoveStartOfSubject
        -:10456:#endif
        -:10457:            ,12345
        -:10458:            );
        -:10459:        }
   403024:10460:    if(!(  (  (Flgs & NONIDENT)
      685:10461:           && ( ONTKENNING(Flgs, NONIDENT)
    #####:10462:              ? ( (s.c.once = ONCE) /* 20070402 */
        -:10463:                , snijaf > sub
        -:10464:                )
        -:10465:              : snijaf == sub
        -:10466:              )
        -:10467:           )
   200784:10468:        || (  (Flgs & ATOM)
     1117:10469:           && ( ONTKENNING(Flgs, ATOM)
        6:10470:              ?    (snijaf < sub + 2) /*!(sub[0] && sub[1])*/
        -:10471:              :    snijaf > sub/*sub[0]*/
      632:10472:                && ( (s.c.once = ONCE) /* 20070402 */
      316:10473:                   , snijaf > sub + 1 /*sub[1]*/
        -:10474:                   )
        -:10475:              )
        -:10476:           )
   200780:10477:        || (  (Flgs & (BREUK|NUMBER))
      565:10478:           && ( (ci = sfullnumbercheck(sub,snijaf,NULL))
      210:10479:              , (  (  (Flgs & BREUK)
       29:10480:                   && ((ci != (QBREUK | QGETAL)) ^ ONTKENNING(Flgs, BREUK))
        -:10481:                   )
      188:10482:                || (  (Flgs & NUMBER)
      186:10483:                   && (((ci & QGETAL) == 0)      ^ ONTKENNING(Flgs, NUMBER))
        -:10484:                   )
        -:10485:                )
        -:10486:              )
      145:10487:           && (  s.c.rmr = (ci == DEFINITELYNONUMBER) ? ONCE : FALSE
      145:10488:              ,  (s.c.lmr = PRISTINE)
        -:10489:              )
        -:10490:           )
        -:10491:        )
        -:10492:       )
        -:10493:        {
   200635:10494:        if(IS_VARIABLE(pat))
        -:10495:            {
    13075:10496:            int ok = TRUE;
    13075:10497:            if(is_op(pat))
        -:10498:                {
        2:10499:                unsigned int saveflgs = Flgs & VISIBLE_FLAGS;
        2:10500:                name = subboomcopie(pat);
        2:10501:                name->v.fl &= ~VISIBLE_FLAGS;
        2:10502:                name->v.fl |= SUCCESS;
        2:10503:                if ((s.c.rmr = (char)evalueer(name)) != TRUE)
    #####:10504:                    ok = FALSE;
        2:10505:                name->v.fl |= saveflgs;
        2:10506:                pat = name;
        -:10507:                }
    13075:10508:            if(ok)
        -:10509:                {
    13075:10510:                if (Flgs & UNIFY)        /* ?  */
        -:10511:                    {
    11128:10512:                    if (!NIKS(pat) || snijaf > sub)
        -:10513:                        {
    11128:10514:                        if (  is_op(pat)
    11126:10515:                           || pat->u.obj
        -:10516:                           )
        -:10517:                            {
     3074:10518:                            if (Flgs & INDIRECT)        /* ?! of ?!! */
        -:10519:                                {
    #####:10520:                                if ((loc=Naamwoord_w(pat,Flgs & DOUBLY_INDIRECT)) != NULL)
        -:10521:                                    {
    #####:10522:                                    if (is_object(loc))
        -:10523:                                        /*s.c.rmr = (char)scopy_insert(loc, sub);*/
    #####:10524:                                        s.c.rmr = (char)string_copy_insert(loc,subkn,sub,snijaf);
        -:10525:                                    else
        -:10526:                                        {
    #####:10527:                                        s.c.rmr = (char)evalueer(loc);
        -:10528:                                        /*if(!scopy_insert(loc, sub))*/
    #####:10529:                                        if(!string_copy_insert(loc,subkn,sub,snijaf))
    #####:10530:                                            s.c.rmr = FALSE;
        -:10531:                                        }
    #####:10532:                                    wis(loc);
        -:10533:                                    }
        -:10534:                                }
        -:10535:                            else
        -:10536:                                /*s.c.rmr = (char)scopy_insert(pat, sub);*/
        -:10537:                                {
     1537:10538:                                s.c.rmr = (char)string_copy_insert(pat,subkn,sub,snijaf);
        -:10539:                                }
        -:10540:                            }
        -:10541:                        else
     9591:10542:                            s.c.rmr = TRUE;
        -:10543:                        }
        -:10544:                    }
     1947:10545:                else if (Flgs & INDIRECT)        /* ! of !! */
        -:10546:                    {
     1947:10547:                    if ((loc=Naamwoord_w(pat,Flgs & DOUBLY_INDIRECT)) != NULL)
        -:10548:                        {
     1947:10549:                        cleanOncePattern(loc);
        -:10550:#if CUTOFFSUGGEST
     1947:10551:                        if(mayMoveStartOfSubject)
        -:10552:                            {
      622:10553:                            *mayMoveStartOfSubject = 0;
        -:10554:                            }
     3894:10555:                        s.c.rmr = (char)(stringmatch(ind+1,"A",sub,snijaf,loc,subkn,pposition,stringLength
        -:10556:                            ,suggestedCutOff
        -:10557:                            ,0
     1989:10558:                            ) ^ NIKS(pat));
        -:10559:#else
        -:10560:                        s.c.rmr = (char)(stringmatch(ind+1,"A",sub,snijaf,loc,subkn,pposition,stringLength
        -:10561:                            ) ^ NIKS(pat));
        -:10562:#endif
     1947:10563:                        wis(loc);
        -:10564:                        }
        -:10565:                    else
    #####:10566:                        s.c.rmr = (char)NIKS(pat);
        -:10567:                    }
        -:10568:                }
        -:10569:            }
        -:10570:        else
   187560:10571:            switch (kop(pat))
        -:10572:                {
        -:10573:                case PLUS:
        -:10574:                case MAAL:
    #####:10575:                    break;
        -:10576:                case LUCHT:
        -:10577:                    {
    45213:10578:                    LONG locpos = pposition;
        -:10579:#if CUTOFFSUGGEST
    45213:10580:                    char * suggested_Cut_Off = sub;
        -:10581:                    char * may_Move_Start_Of_Subject;
    45213:10582:                    may_Move_Start_Of_Subject = sub;
        -:10583:#endif
        -:10584:                    /* This code mirrors that of match(). (see below)*/
        -:10585:                    
    45213:10586:                    sloc = sub;                                     /* A    divisionPoint=S */
        -:10587:                                                                    
        -:10588:#if CUTOFFSUGGEST
    45213:10589:                    s.c.lmr = stringmatch(ind+1,"I",sub, sloc       /* B    leftResult=0(P):car(P) */
        -:10590:                                ,pat->LEFT,subkn,pposition
        -:10591:                                ,stringLength,&suggested_Cut_Off
        -:10592:                                ,mayMoveStartOfSubject);
    45213:10593:                    if((s.c.lmr & ONCE) && mayMoveStartOfSubject && *mayMoveStartOfSubject > sub)
        -:10594:                        {
      290:10595:                        return ONCE;
        -:10596:                        }
        -:10597:#else
        -:10598:                    s.c.lmr = stringmatch(ind+1,"I",sub, sloc, pat->LEFT, subkn,pposition,stringLength);
        -:10599:#endif
        -:10600:                    
        -:10601:#if CUTOFFSUGGEST
    44923:10602:                    if(suggested_Cut_Off > sloc)
        -:10603:                        {
      469:10604:                        if(snijaf && suggested_Cut_Off > snijaf)
        -:10605:                            {
       96:10606:                            if(suggestedCutOff)
        -:10607:                                {
       24:10608:                                locpos += suggested_Cut_Off - sloc;
       24:10609:                                snijaf = sloc = *suggestedCutOff = suggested_Cut_Off;
        -:10610:                                }
        -:10611:                            else
        -:10612:                                {
       24:10613:                                locpos += snijaf - sloc;
       24:10614:                                sloc = snijaf;
       24:10615:                                s.c.lmr &= ~TRUE;
        -:10616:                                }
        -:10617:                            }
        -:10618:                        else
        -:10619:                            {
        -:10620:                            assert(suggested_Cut_Off > sloc);
      421:10621:                            locpos += suggested_Cut_Off - sloc;
      421:10622:                            sloc = suggested_Cut_Off;
        -:10623:                            }
        -:10624:                        }
        -:10625:                    else
        -:10626:#endif
    44454:10627:                        s.c.lmr &= ~ONCE;
   176906:10628:                    while(sloc < snijaf)                            /* C    while divisionPoint */
        -:10629:                        {
   124458:10630:                        if(s.c.lmr & TRUE)                          /* D        if leftResult.succes */
        -:10631:                            {
        -:10632:#if CUTOFFSUGGEST
     9550:10633:                            if(s.c.lmr & ONCE)
      448:10634:                                may_Move_Start_Of_Subject = 0;
     9102:10635:                            else if(may_Move_Start_Of_Subject != 0)
     2521:10636:                                may_Move_Start_Of_Subject = sloc;
     9550:10637:                            s.c.rmr = stringmatch(ind+1,"J",sloc    /* E            rightResult=SR:cdr(P) */
        -:10638:                                ,snijaf, pat->RIGHT, subkn
        -:10639:                                ,locpos,stringLength,suggestedCutOff
        -:10640:                                ,&may_Move_Start_Of_Subject);
     9550:10641:                            if(may_Move_Start_Of_Subject != sloc && may_Move_Start_Of_Subject != 0)
        -:10642:                                {
        -:10643:                                assert(may_Move_Start_Of_Subject > sloc);
      535:10644:                                locpos += may_Move_Start_Of_Subject - sloc;
      535:10645:                                sloc = may_Move_Start_Of_Subject;
        -:10646:                                }
        -:10647:                            else
        -:10648:                                {
     9015:10649:                                ++sloc;
     9015:10650:                                ++locpos;
        -:10651:                                }
        -:10652:#else
        -:10653:                            s.c.rmr = stringmatch(ind+1,"J",sloc,snijaf, pat->RIGHT, subkn,locpos,stringLength);
        -:10654:                            ++sloc;
        -:10655:                            ++locpos;
        -:10656:#endif
     9550:10657:                            if(!(s.c.lmr & ONCE))
     9102:10658:                                s.c.rmr &= ~ONCE;
        -:10659:                            }
        -:10660:                        else
        -:10661:                            {
   114908:10662:                            ++sloc;
   114908:10663:                            ++locpos;
        -:10664:                            }
   124458:10665:                        if(  (s.c.rmr & TRUE)                       /* F        if(1) full success */
   123346:10666:                          || (s.c.lmr & (POSITION_ONCE                  /*     or (2) may not be shifted. In the first pass, a position flag on car(P) counts as criterion for being done. */
        -:10667:                                        | ONCE                          
        -:10668:                                        )                               
        -:10669:                             )                                          /* In all but the first pass, the left and right */
    87061:10670:                          || (s.c.rmr & (ONCE                           /* results can indicate that the loop is done.   */
        -:10671:                                        |POSITION_MAX_REACHED           /* In all passes a position_max_reached on the   */
        -:10672:                                        )                               /* rightResult indicates that the loop is done.  */
        -:10673:                             )
        -:10674:                          )
        -:10675:                            {                                       /* G            return */
    37398:10676:                            if(sloc > sub + 1)                          /* Also return whether sub has reached max position.*/
    36813:10677:                                s.c.rmr &= ~POSITION_MAX_REACHED;       /* This flag is reason to stop increasing the position of the division any further, but it must not be signalled back to the caller if the lhs is not nil ... */
    37398:10678:                            s.c.rmr |= (char)(s.c.lmr & POSITION_MAX_REACHED); /* ... unless it is the lhs that signals it. */
    37398:10679:                            if(stringOncePattern(pat))                  /* Also return whether the pattern as a whole */
        -:10680:                                {                                       /* doesn't want longer subjects, which can be */
        2:10681:                                s.c.rmr |= ONCE;                        /* found out by looking at the pattern        */
        2:10682:                                s.c.rmr |= (char)(pat->v.fl & FENCE);
        -:10683:                                }                                       /* or by looking at whether both lhs and rhs  */
    37396:10684:                            else if(!(s.c.lmr & ONCE))                  /* results indicated this, in which case both */
     1245:10685:                                s.c.rmr &= ~ONCE;                       /* sides must be non-zero size subjects.      */
    37398:10686:                            return s.c.rmr ^ (char)NIKS(pat);
        -:10687:                            }
        -:10688:                                                                    /* H        SL,SR=shift_right divisionPoint */
        -:10689:                                                                        /* SL = lhs divisionPoint S, SR = rhs divisionPoint S */
        -:10690:                                                                    /* I        leftResult=SL:car(P) */
        -:10691:#if CUTOFFSUGGEST
    87060:10692:                        suggested_Cut_Off = sub;
    87060:10693:                        s.c.lmr = stringmatch(ind+1,"I",sub,sloc, pat->LEFT, subkn,/* 0 ? */pposition,/* strlen(sub) ? */ stringLength,&suggested_Cut_Off,mayMoveStartOfSubject);
    87060:10694:                        if(suggested_Cut_Off > sloc)
        -:10695:                            {
       18:10696:                            if(!(snijaf && suggested_Cut_Off > snijaf))
        -:10697:                                {
        -:10698:                                assert(suggested_Cut_Off > sloc);
       14:10699:                                locpos += suggested_Cut_Off - sloc;
       14:10700:                                sloc = suggested_Cut_Off;
        -:10701:                                }
        -:10702:                            }
        -:10703:#else
        -:10704:                        s.c.lmr = stringmatch(ind+1,"I",sub,sloc, pat->LEFT, subkn,/* 0 ? */pposition,/* strlen(sub) ? */ stringLength);
        -:10705:#endif
        -:10706:                        }
        -:10707:                    
     7525:10708:                    if(s.c.lmr & TRUE)                              /* J    if leftResult.succes */
        -:10709:                        {
        -:10710:#if CUTOFFSUGGEST
     1013:10711:                        s.c.rmr = stringmatch(ind+1,"J",sloc,snijaf /* K        rightResult=0(P):cdr(pat) */
        -:10712:                            ,pat->RIGHT, subkn,locpos,stringLength
        -:10713:                            ,suggestedCutOff,mayMoveStartOfSubject);
        -:10714:#else
        -:10715:                        s.c.rmr = stringmatch(ind+1,"J",sloc,snijaf,pat->RIGHT, subkn,locpos,stringLength);
        -:10716:#endif
     1013:10717:                        s.c.rmr &= ~ONCE;
        -:10718:                        }
        -:10719:                    /* L    return */
     7525:10720:                    if(!(s.c.rmr & POSITION_MAX_REACHED))
     7517:10721:                        s.c.rmr &= ~POSITION_ONCE;
     7525:10722:                    if(/*(snijaf > sub) &&*/ stringOncePattern(pat))    /* The test snijaf > sub merely avoids that stringOncePattern is called when it is useless. */
        -:10723:                        {/* Test:
        -:10724:                         @(abcde:`(a ?x) (?z:d) ? )
        -:10725:                          z=b
        -:10726:                         */
        3:10727:                        s.c.rmr |= ONCE;
        3:10728:                        s.c.rmr |= (char)(pat->v.fl & FENCE);
        -:10729:                        }
     7525:10730:                    return s.c.rmr ^ (char)NIKS(pat);               /* end */
        -:10731:                    }
        -:10732:                case STREEP:
        3:10733:                    if(snijaf > sub + 1)
        -:10734:                        {
        -:10735:#if CUTOFFSUGGEST
        1:10736:                        s.c.lmr = stringmatch(ind+1,"M",sub,sub+1,pat->LEFT,subkn,pposition,stringLength,NULL,mayMoveStartOfSubject);
        -:10737:#else
        -:10738:                        s.c.lmr = stringmatch(ind+1,"M",sub,sub+1,pat->LEFT,subkn,pposition,stringLength);
        -:10739:#endif
        1:10740:                        if(  (s.c.lmr & TRUE)
        -:10741:#if CUTOFFSUGGEST
        1:10742:                          && ((s.c.rmr = stringmatch(ind+1,"N",sub+1,snijaf,pat->RIGHT, subkn,pposition,stringLength,suggestedCutOff,mayMoveStartOfSubject)) & TRUE)
        -:10743:#else
        -:10744:                          && ((s.c.rmr = stringmatch(ind+1,"N",sub+1,snijaf,pat->RIGHT, subkn,pposition,stringLength)) & TRUE)
        -:10745:#endif
        -:10746:                          )
        -:10747:                            {
        1:10748:                            dummy_op = LUCHT;
        -:10749:                            }
        1:10750:                        s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE));
        -:10751:                        }
        3:10752:                    break;
        -:10753:                case EN:
        -:10754:#if CUTOFFSUGGEST
    43131:10755:                    if ((s.c.lmr = stringmatch(ind+1,"O",sub,snijaf, pat->LEFT, subkn,pposition,stringLength,suggestedCutOff,mayMoveStartOfSubject)) & TRUE)
        -:10756:#else
        -:10757:                    if ((s.c.lmr = stringmatch(ind+1,"O",sub,snijaf, pat->LEFT, subkn,pposition,stringLength)) & TRUE)
        -:10758:#endif
        -:10759:                        {
     1545:10760:                        loc = zelfde_als_w(pat->RIGHT);
        -:10761:                        /* 13 november 1991 */
     1545:10762:                        loc = eval(loc);
     1545:10763:                        if (loc->v.fl & SUCCESS)
        -:10764:                            {
      149:10765:                            s.c.rmr = TRUE;
      149:10766:                            if (loc->v.fl & FENCE)
    #####:10767:                                s.c.rmr |= ONCE;
        -:10768:                            }
        -:10769:                        else
        -:10770:                            {
     1396:10771:                            s.c.rmr = FALSE;
     1396:10772:                            if (loc->v.fl & FENCE)
        2:10773:                                s.c.rmr |= (FENCE | ONCE);        /* 13 november 1991 */
     1396:10774:                            if (loc->v.fl & IMPLIEDFENCE) /* 20101101  (for function utf$) */
       14:10775:                                s.c.rmr |= ONCE;          /* 20101101 */
        -:10776:                            }
     1545:10777:                        wis(loc);
        -:10778:                        }
    43131:10779:                    s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE));
    43131:10780:                    break;
        -:10781:                case MATCH:
        -:10782:#if CUTOFFSUGGEST
     1101:10783:                    if ((s.c.lmr = stringmatch(ind+1,"P",sub,snijaf, pat->LEFT, subkn,pposition,stringLength,suggestedCutOff,mayMoveStartOfSubject)) & TRUE)
        -:10784:#else
        -:10785:                    if ((s.c.lmr = stringmatch(ind+1,"P",sub,snijaf, pat->LEFT, subkn,pposition,stringLength)) & TRUE)
        -:10786:#endif
        -:10787:                        {
        -:10788:#if CUTOFFSUGGEST
      285:10789:                        if(suggestedCutOff && *suggestedCutOff > snijaf)
        -:10790:                            {
       15:10791:                            snijaf = *suggestedCutOff;
        -:10792:                            }
        -:10793:
      285:10794:                        s.c.rmr = (char)(stringmatch(ind+1,"Q",sub,snijaf,pat->RIGHT,subkn,pposition,stringLength,0,0) /*& TRUE 20070402 */);
        -:10795:#else
        -:10796:                        s.c.rmr = (char)(stringmatch(ind+1,"Q",sub,snijaf,pat->RIGHT,subkn,pposition,stringLength) /*& TRUE 20070402 */);
        -:10797:#endif
        -:10798:                        }
        -:10799:                    else
      816:10800:                        s.c.rmr = FALSE;
     1101:10801:                    s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE | POSITION_MAX_REACHED));
     1101:10802:                    break;
        -:10803:                case OF:
        -:10804:#if CUTOFFSUGGEST
     6264:10805:                    if(mayMoveStartOfSubject) 
     3057:10806:                        *mayMoveStartOfSubject = 0;
    12528:10807:                    if ( (s.c.lmr = (char)( stringmatch(ind+1,"R",sub,snijaf,pat->LEFT,subkn,pposition,stringLength,NULL,0)))
        -:10808:#else
        -:10809:                    if ( (s.c.lmr = (char)( stringmatch(ind+1,"R",sub,snijaf,pat->LEFT,subkn,pposition,stringLength)))
        -:10810:#endif
     6264:10811:                       & (TRUE | FENCE)
        -:10812:                       )
        -:10813:                        {
      352:10814:                        if((s.c.lmr & ONCE) && !stringOncePattern(pat->RIGHT))
        -:10815:                            {
      319:10816:                            s.c.rmr = (char)(s.c.lmr & TRUE);
        -:10817:                            }
        -:10818:                        else
        -:10819:                            {
       33:10820:                            s.c.rmr = (char)(s.c.lmr & (TRUE|ONCE));
        -:10821:                            }
        -:10822:                        }
        -:10823:                    else
        -:10824:                        {
        -:10825:#if CUTOFFSUGGEST
     5912:10826:                        s.c.rmr = stringmatch(ind+1,"S",sub,snijaf,pat->RIGHT, subkn,pposition,stringLength,NULL,0);
        -:10827:#else
        -:10828:                        s.c.rmr = stringmatch(ind+1,"S",sub,snijaf,pat->RIGHT, subkn,pposition,stringLength);
        -:10829:#endif
     5912:10830:                        if(  (s.c.rmr & ONCE)
     2752:10831:                          && !(s.c.lmr & ONCE)
        -:10832:                          )
        -:10833:                            {
     1383:10834:                            s.c.rmr &= ~(ONCE|POSITION_ONCE);
        -:10835:                            }
     5912:10836:                        if(  (s.c.rmr & POSITION_MAX_REACHED)
    #####:10837:                          && !(s.c.lmr & POSITION_MAX_REACHED)
        -:10838:                          )
        -:10839:                            {
    #####:10840:                            s.c.rmr &= ~(POSITION_MAX_REACHED|POSITION_ONCE);
        -:10841:                            }
        -:10842:                        }
     6264:10843:                    break;
        -:10844:/*
        -:10845:20070222 This is now much quicker than previously, because the whole expression
        -:10846:(|bc|x) is ONCE if the start of the subject does not match the start of any of
        -:10847:the alternations:
        -:10848:dbg'@(hhhhhhhhhbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbhhhabcd:?X (|bc|x) d)
        -:10849:*/
        -:10850:                case FUN:
        -:10851:                case FUU:
       53:10852:                    psh(&sjt,&nilk,NULL);/*20100910*/
       53:10853:                    string_copy_insert(&sjt,subkn,sub,snijaf);/*20100910*/
       53:10854:                    loc = zelfde_als_w(pat);
       53:10855:                    loc = eval(loc);
       53:10856:                    deleteNode(&sjt);/*20100910*/
        -:10857:#if CUTOFFSUGGEST
       53:10858:                    if(mayMoveStartOfSubject)
       49:10859:                        *mayMoveStartOfSubject = 0;
        -:10860:#endif
       53:10861:                    if(isSUCCESS(loc))/*20100910*/
        -:10862:                        {
        5:10863:                        loc = setflgs(loc,pat->v.fl); /* 20100221 */
        5:10864:                        if (vgl(pat, loc))
        -:10865:                            {
        -:10866:#if CUTOFFSUGGEST
        5:10867:                            s.c.rmr = (char)(stringmatch(ind+1,"T",sub,snijaf,loc,subkn,pposition,stringLength,NULL,0) ^ NIKS(loc));
        -:10868:#else
        -:10869:                            s.c.rmr = (char)(stringmatch(ind+1,"T",sub,snijaf,loc,subkn,pposition,stringLength) ^ NIKS(loc));
        -:10870:#endif
        5:10871:                            wis(loc);
        5:10872:                            break;
        -:10873:                            }
        -:10874:                        }
        -:10875:                    else
        -:10876:                        {
       48:10877:                        if(loc->v.fl & (FENCE|IMPLIEDFENCE))
        9:10878:                            s.c.rmr = ONCE; /* '~ as return value from function stops stretching subject */
        -:10879:                        }
       48:10880:                    wis(loc);
       48:10881:                    break;
        -:10882:                default:
    91795:10883:                    if(!is_op(pat))
        -:10884:                        {
    91795:10885:                        if (  !pat->u.obj
      997:10886:                           && (Flgs & (BREUK | NUMBER | NONIDENT | ATOM | IDENT))
        -:10887:                           /*&& !(((Flgs & NOT) && 1) ^ ((Flgs & (GREATER_THAN|SMALLER_THAN)) && 1))*/
        -:10888:                           )
        -:10889:                            {         /* e.g.    a b c : % */
       56:10890:                            s.c.rmr = TRUE;
        -:10891:                            }
        -:10892:                        else
        -:10893:                            {
        -:10894:#if CUTOFFSUGGEST
    91739:10895:                            s.c.rmr = (char)(/** / ONCE | / **/ scompare("b",(char *)sub,snijaf, pat
        -:10896:                                                                        , ( (  !(Flgs & ATOM)
        -:10897:                                                                            || ONTKENNING(Flgs, ATOM)
        -:10898:                                                                            ) 
        -:10899:                                                                          ? suggestedCutOff
        -:10900:                                                                          : NULL
        -:10901:                                                                          )
        -:10902:                                                                        ,mayMoveStartOfSubject
        -:10903:                                                                        )
        -:10904:                                             );
        -:10905:#else
        -:10906:                            s.c.rmr = (char)(/** / ONCE | / **/ scompare("b",(unsigned char *)sub,snijaf, pat));
        -:10907:#endif
        -:10908:                            DBGSRC(Printf("%s %d%*sscompare(%.*s,",wh,ind,ind,"",snijaf-sub,sub);result(pat);Printf(") ");\
        -:10909:                                if(s.c.rmr & ONCE) Printf("ONCE|");\
        -:10910:                                if(s.c.rmr & TRUE) Printf("TRUE"); else Printf("FALSE");\
        -:10911:                                Printf("\n");)
        -:10912:                            }
        -:10913:                        }
        -:10914:                    /*
        -:10915:                    if (s.c.lmr != SCHAR_MAX)
        -:10916:                    s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE));
        -:10917:                    */
        -:10918:                }
        -:10919:        }
        -:10920:    DBGSRC(if(s.c.rmr & (FENCE | ONCE))\
        -:10921:        {Printf("%s %d%*s+",wh,ind,ind,"");if(s.c.rmr & FENCE)\
        -:10922:         Printf(" FENCE ");if(s.c.rmr & ONCE)Printf(" ONCE ");Printf("\n");})
   155815:10923:    s.c.rmr |= (char)(pat->v.fl & FENCE);
   155815:10924:    if(stringOncePattern(pat) || /* Bart 20070820 @("abXk":(|? b|`) X ?id) must fail*/ (s.c.rmr & (TRUE|FENCE|ONCE)) == FENCE)
        -:10925:        {
      757:10926:        s.c.rmr |= ONCE;
        -:10927:        DBGSRC(int redMooi;int redhum;redMooi = mooi;redhum = hum;\
        -:10928:            mooi = FALSE;hum = FALSE;\
        -:10929:            Printf("%d%*sstringmatch(%.*s",ind,ind,"",snijaf-sub,sub);\
        -:10930:            Printf(":");result(pat);\
        -:10931:            mooi = redMooi;hum = redhum;\
        -:10932:            Printf(") s.c.rmr %d (B)",s.c.rmr);\
        -:10933:            if(pat->v.fl & POSITION) Printf("POSITION ");\
        -:10934:            if(pat->v.fl & BREUK)Printf("BREUK ");\
        -:10935:            if(pat->v.fl & NUMBER)Printf("NUMBER ");\
        -:10936:            if(pat->v.fl & SMALLER_THAN)Printf("SMALLER_THAN ");\
        -:10937:            if(pat->v.fl & GREATER_THAN) Printf("GREATER_THAN ");\
        -:10938:            if(pat->v.fl & ATOM)  Printf("ATOM ");\
        -:10939:            if(pat->v.fl & FENCE) Printf("FENCE ");\
        -:10940:            if(pat->v.fl & IDENT) Printf("IDENT");\
        -:10941:            Printf("\n");)
        -:10942:        }
   155815:10943:    if(is_op(pat))
    50558:10944:        s.c.rmr ^= (char)NIKS(pat);
   155815:10945:    if(name)
        2:10946:        wis(name);
   155815:10947:    return (char)(s.c.once | s.c.rmr);
        -:10948:    }
        -:10949:
        -:10950:
        -:10951:
  3269512:10952:static char match(int ind,psk sub, psk pat, psk snijaf,LONG pposition,psk expr,unsigned int op)
        -:10953:    {
        -:10954:/*
        -:10955:s.c.lmr or s.c.rmr have three independent flags: TRUE/FALSE, ONCE and FENCE.
        -:10956:
        -:10957:TRUE/FALSE The success or failure of the match.
        -:10958:
        -:10959:ONCE       Unwillingness of the pattern to match longer substrings from the
        -:10960:           subject. Example:
        -:10961:
        -:10962:{?} a b c d:?x @?y d
        -:10963:{!} a b c d
        -:10964:{?} !y
        -:10965:{!} c
        -:10966:{?} !x
        -:10967:{!} a b
        -:10968:           In fact, the pattern @?y first matches the empty string and then,
        -:10969:           after backtracking from the failing match of the last subpattern d,
        -:10970:           a single element from the string. Thereafter, when again
        -:10971:           backtracking, the subpattern @?y denies to even try to match a
        -:10972:           substring that is one element longer (two elements, in this example)
        -:10973:           and the subpattern preceding @?y is offered an enlarged substring
        -:10974:           from the subject, while @?y itself starts with the empty element.
        -:10975:
        -:10976:           This flag is of importance for patterns with the space, + or
        -:10977:           * operator.
        -:10978:           The flag is turned on in patterns by the `@#/ flags and by operators
        -:10979:           other than space + * _ & : | = $ '
        -:10980:           The flag is turned off "after consumption", i.e. it does not
        -:10981:           percolate upwards through patterns with space + or * operators.
        -:10982:
        -:10983:(once=
        -:10984:  (p=?`Y)
        -:10985:&   a b c d
        -:10986:  : ?X !p (d|?&(p=`?Z&foo:?Y)&~)
        -:10987:& out$(X !X Y !Y Z !Z));
        -:10988:
        -:10989:
        -:10990:(once=a b c d:?X (?|?) d & out$(X !X))
        -:10991:(once=a b c d:?X (@|@) d & out$(X !X))
        -:10992:(once=a b c d:?X (?|@) d & out$(X !X))
        -:10993:(once=a b c d:?X (@|?) d & out$(X !X))
        -:10994:(once=a b c d:?X (@|`) d & out$(X !X))
        -:10995:(once=a b c d:?X (`|?) d & out$(X !X))
        -:10996:(once=a b c d:?X (`c|?) d & out$(X !X))
        -:10997:
        -:10998:FENCE      Onbereidheid van het subject om door alternatieve patronen gematcht
        -:10999:           te worden. Van belang voor de | en : operatoren in een patroon.
        -:11000:           Wordt aangezet door ` vlag (al dan niet in een patroon).
        -:11001:           Wordt uitgezet in patroon met spatie + * | of : operator.
        -:11002:           (Bij | en : operatoren geldt dit alleen voor de linkeroperand,
        -:11003:           bij de andere voor alle behalve de laatste operand in een lijst.)
        -:11004:*/
        -:11005:    matchstate s;
        -:11006:    psk loc;
        -:11007:    unsigned int Flgs;
  3269512:11008:    psk name = NULL;
        -:11009:    DBGSRC(Printf("%d%*smatch(",ind,ind,"");results(sub,snijaf);Printf(":");\
        -:11010:        result(pat);Printf(")");Printf("\n");)
  3269512:11011:    if (is_op(sub))
        -:11012:        {
   887237:11013:        if(kop(sub) == WORDT)
    15925:11014:            sub->RIGHT = Head(sub->RIGHT);
        -:11015:
   887237:11016:        if (sub->RIGHT == snijaf)
   141004:11017:            return match(ind+1,sub->LEFT, pat, NULL,pposition,expr,op);
        -:11018:        }
  3128508:11019:    s.i = (PRISTINE << SHIFT_LMR) + (PRISTINE << SHIFT_RMR);
  3128508:11020:    Flgs = pat->v.fl;
  3128508:11021:    if(Flgs & POSITION)
        -:11022:        {
      149:11023:        if(Flgs & NONIDENT)
        3:11024:            return doEval(sub,snijaf,pat);
      146:11025:        else if(snijaf || !(sub->v.fl & IDENT))
       51:11026:            return FALSE | ONCE | POSITION_ONCE;
        -:11027:        else
       95:11028:            return doPosition(s,pat,pposition,0,expr
        -:11029:#if CUTOFFSUGGEST
        -:11030:                   ,0
        -:11031:#endif
        -:11032:                   ,op
        -:11033:                   );
        -:11034:        }
  5710899:11035:    if ( !(  ((Flgs & NONIDENT) && (((sub->v.fl & IDENT) && 1) ^ ONTKENNING(Flgs, NONIDENT)))
  2582654:11036:          || ((Flgs & ATOM    ) && ((is_op(sub)          && 1) ^ ONTKENNING(Flgs, ATOM    )))
  2582634:11037:          || ((Flgs & BREUK   ) && ( !RAT_RAT(sub)             ^ ONTKENNING(Flgs, BREUK   )))
  2589207:11038:          || ((Flgs & NUMBER  ) && ( !RATIONAAL_COMP(sub)      ^ ONTKENNING(Flgs, NUMBER  )))
        -:11039:          )
        -:11040:       )
        -:11041:        {
  2580923:11042:        if(IS_VARIABLE(pat))
        -:11043:            {
   897061:11044:            int ok = TRUE;
   897061:11045:            if(is_op(pat))
        -:11046:                {
     2237:11047:                unsigned int saveflgs = Flgs & VISIBLE_FLAGS;
        -:11048:                DBGSRC(printf("pat:");result(pat);printf("\n");)
     2237:11049:                name = subboomcopie(pat);
     2237:11050:                name->v.fl &= ~VISIBLE_FLAGS;
     2237:11051:                name->v.fl |= SUCCESS;
     2237:11052:                if ((s.c.rmr = (char)evalueer(name)) != TRUE)
    #####:11053:                    ok = FALSE;
     2237:11054:                name->v.fl |= saveflgs;
     2237:11055:                pat = name;
        -:11056:                }
   897061:11057:            if(ok)
        -:11058:                {
   897061:11059:                if (Flgs & UNIFY)        /* ?  */
        -:11060:                    {
   619068:11061:                    if (!NIKS(pat) || is_op(sub) || (sub->u.obj))
        -:11062:                        {
   619068:11063:                        if (  is_op(pat)
   619043:11064:                           || pat->u.obj
        -:11065:                           )
   898890:11066:                            if (Flgs & INDIRECT)        /* ?! of ?!! */
        -:11067:                                {
     6000:11068:                                if ((loc=Naamwoord_w(pat,Flgs & DOUBLY_INDIRECT)) != NULL)
        -:11069:                                    {
     6000:11070:                                    if (is_object(loc))
        2:11071:                                        s.c.rmr = (char)copy_insert(loc, sub, snijaf);
        -:11072:                                    else
        -:11073:                                        {
     5998:11074:                                        s.c.rmr = (char) evalueer(loc);
     5998:11075:                                        if(!copy_insert(loc, sub, snijaf))
    #####:11076:                                            s.c.rmr = FALSE;
        -:11077:                                            /* 19971207. Previously, s.c.rmr was not influenced by failure of copy_insert */
        -:11078:
        -:11079:                                        }
     6000:11080:                                    wis(loc);
        -:11081:                                    }
        -:11082:                                }
        -:11083:                            else
        -:11084:                                {
   443445:11085:                                s.c.rmr = (char)copy_insert(pat, sub, snijaf);
        -:11086:                                /* 19971207. Previously, s.c.rmr was unconditionally set to TRUE */
        -:11087:                                }
        -:11088:
        -:11089:                        else
   169623:11090:                            s.c.rmr = TRUE;
        -:11091:                        }
        -:11092:                    /*
        -:11093:                     * else NIKS(pat) && !is_op(sub) && !sub->u.obj
        -:11094:                     * dwz   ~?[`][!][!]
        -:11095:                     */
        -:11096:                    }
   277993:11097:                else if (Flgs & INDIRECT)        /* ! of !! */
        -:11098:                    {
   277993:11099:                    if ((loc=Naamwoord_w(pat,Flgs & DOUBLY_INDIRECT)) != NULL)
        -:11100:                        {
   277993:11101:                        cleanOncePattern(loc);
   277993:11102:                        s.c.rmr = (char)(match(ind+1,sub, loc, snijaf,pposition,expr,op) ^ NIKS(pat));
   277993:11103:                        wis(loc);
        -:11104:                        }
        -:11105:                    else
    #####:11106:                        s.c.rmr = (char)NIKS(pat);
        -:11107:                    }
        -:11108:                }
        -:11109:            }
        -:11110:        else
  1683862:11111:            switch (kop(pat))
        -:11112:                {
        -:11113:                case LUCHT:
        -:11114:                case PLUS:
        -:11115:                case MAAL:
        -:11116:                    {
   523149:11117:                    LONG locpos = pposition;
        -:11118:                    /* Optimal sructure for this code:
        -:11119:                                A0 (B A)* B0
        -:11120:                    S:P ::=
        -:11121:                    A       divisionPoint=S
        -:11122:                    B       leftResult=0(P):car(P)
        -:11123:                    C       while divisionPoint
        -:11124:                    D           if leftResult.succes
        -:11125:                    E               rightResult=SR:cdr(P)
        -:11126:                    F           if(done)
        -:11127:                    G               return
        -:11128:                    H           SL,SR=shift_right divisionPoint
        -:11129:                    I           leftResult=SL:car(P)
        -:11130:                    J       if leftResult.succes
        -:11131:                    K           rightResult=0(P):cdr(pat)
        -:11132:                    L       return
        -:11133:
        -:11134:                    0(P)=nil(pat): nil(LUCHT)="", nil(+)=0,nil(*)=1
        -:11135:                    In stringmatch, there is no need for L0; the empty string ""
        -:11136:                    is part of the string.
        -:11137:                    */
        -:11138:                    /* A    divisionPoint=S */
        -:11139:                    /* B    leftResult=0(P):car(P) */
        -:11140:                    /* C    while divisionPoint */
        -:11141:                    /* D        if leftResult.succes */
        -:11142:                    /* E            rightResult=SR:cdr(P) */
        -:11143:                    /* F        if(done) */
        -:11144:                        /* done =  (1) full succes */
        -:11145:                        /*      or (2) may not be shifted.
        -:11146:                           ad (2): In the first pass, a position
        -:11147:                           flag on car(P) counts as criterion for being done. */
        -:11148:                        /* In all but the first pass, the left and right
        -:11149:                           results can indicate that the loop is done. */
        -:11150:                        /* In all passes a position_max_reached on the
        -:11151:                           rightResult indicates that the loop is done. */
        -:11152:                    /* G            return */
        -:11153:                        /* Return true if full success.
        -:11154:                           Also return whether lhs experienced max position
        -:11155:                           being reached. */
        -:11156:                        /* Also return whether the pattern as a whole doesn't
        -:11157:                           want longer subjects, which can be found out by
        -:11158:                           looking at the pattern */
        -:11159:                        /* or by looking at whether both lhs and rhs results
        -:11160:                           indicated this, in which case both sides must be
        -:11161:                           non-zero size subjects. */
        -:11162:                        /* POSITION_ONCE, on the other hand, requires zero size
        -:11163:                           subjects. */
        -:11164:                        /* Also return the fence flag, if present in rmr.
        -:11165:                           (This flag in lmr has no influence.)
        -:11166:                        */
        -:11167:                    /* H        SL,SR=shift_right divisionPoint */
        -:11168:                        /* SL = lhs divisionPoint S, SR = rhs divisionPoint S
        -:11169:                        */
        -:11170:                    /* I        leftResult=SL:car(P) */
        -:11171:                    /* J    if leftResult.succes */
        -:11172:                    /* K        rightResult=0(P):cdr(pat) */
        -:11173:                    /* L    return */
        -:11174:                        /* Return true if full success.
        -:11175:
        -:11176:                           Also return whether lhs experienced max position
        -:11177:                           being reached. */
        -:11178:                        /* Also return whether the pattern as a whole doesn't
        -:11179:                           want longer subjects, which can be found out by
        -:11180:                           looking at the pattern or by looking at whether */
        -:11181:                        /* both lhs and rhs results indicated this.
        -:11182:                           These come in two sorts: POSITION_ONCE requires */
        -:11183:                        /* zero size subjects, ONCE requires non-zero size
        -:11184:                           subjects. */
        -:11185:                        /* Also return the fence flag, which can be found on
        -:11186:                           the pattern or in the result of the lhs or the rhs.
        -:11187:                           (Not necessary that both have this flag.)
        -:11188:                        */
        -:11189:                    /* end */
   523149:11190:                    if(SUBJECTNOTNIL(sub,pat))                      /* A    divisionPoint=S */
   472897:11191:                        loc = sub;
        -:11192:                    else
    50252:11193:                        loc = NULL;
        -:11194:                                                                    /* B    leftResult=0(P):car(P) */
   523149:11195:                    s.c.lmr = (char)match(ind+1,nil(pat),pat->LEFT  /* a*b+c*d:?+[1+?*[1*%@?q*?+?            (q = c) */
        -:11196:                                         ,NULL,pposition,expr       /* a b c d:? [1 (? [1 %@?q ?) ?          (q = b) */
        -:11197:                                         ,kop(pat));                /* a b c d:? [1  ? [1 %@?q ?  ?          (q = b) */
   523149:11198:                    s.c.lmr &= ~ONCE;                               
  1715450:11199:                    while(loc)                                      /* C    while divisionPoint */  
        -:11200:                        {
   736894:11201:                        if(s.c.lmr & TRUE)                          /* D        if leftResult.succes */
        -:11202:                            {                                       /* E            rightResult=SR:cdr(P) */
   161261:11203:                            s.c.rmr = match(ind+1,loc,pat->RIGHT,snijaf,locpos,expr,op);
   161261:11204:                            if(!(s.c.lmr & ONCE))
   158470:11205:                                s.c.rmr &= ~ONCE;
        -:11206:                            }
   736894:11207:                        if(  (s.c.rmr & TRUE)                       /* F        if(1) full success */
   713830:11208:                          || (s.c.lmr & (POSITION_ONCE                  /*     or (2) may not be shifted. In the first pass, a position flag on car(P) counts as criterion for being done. */
        -:11209:                                        | ONCE                          
        -:11210:                                        )                               
        -:11211:                             )                                          /* In all but the first pass, the left and right */
   669153:11212:                          || (s.c.rmr & (ONCE                           /* results can indicate that the loop is done.   */
        -:11213:                                        |POSITION_MAX_REACHED           /* In all passes a position_max_reached on the   */
        -:11214:                                        )                               /* rightResult indicates that the loop is done.  */
        -:11215:                             )
        -:11216:                          )
        -:11217:                            {                                       /* G            return */
    67742:11218:                            if(loc != sub)
    66301:11219:                                s.c.rmr &= ~POSITION_MAX_REACHED;           /* This flag is reason to stop increasing the position of the division any further, but it must not be signalled  back to the caller if the lhs is not nil ... */
    67742:11220:                            s.c.rmr |= (char)(s.c.lmr & POSITION_MAX_REACHED);  /* ... unless it is the lhs that signals it. */
    67742:11221:                            if(oncePattern(pat))                        /* Also return whether the pattern as a whole doesn't want longer subjects, which can be found out by looking at the pattern */ 
        -:11222:                                {                                       /* For example,                            */ 
       42:11223:                                s.c.rmr |= ONCE;                        /*     a b c d:`(?x ?y) (?z:c) ?           */ 
       42:11224:                                s.c.rmr |= (char)(pat->v.fl & FENCE);   /* must fail and set x==nil, y==a and z==b */
        -:11225:                                }
    67700:11226:                            else if(!(s.c.lmr & ONCE))                  
    20894:11227:                                s.c.rmr &= ~ONCE;
        -:11228:                            DBGSRC(Printf("%d%*smatch(",ind,ind,"");\
        -:11229:                                results(sub,snijaf);Printf(":");result(pat);)
        -:11230:#ifndef NDEBUG
        -:11231:                            DBGSRC(printMatchState("EXIT-MID",s,pposition,0);)
        -:11232:#endif
        -:11233:                            DBGSRC(if(pat->v.fl & BREUK) Printf("BREUK ");\
        -:11234:                                if(pat->v.fl & NUMBER) Printf("NUMBER ");\
        -:11235:                                if(pat->v.fl & SMALLER_THAN)\
        -:11236:                                    Printf("SMALLER_THAN ");\
        -:11237:                                if(pat->v.fl & GREATER_THAN)\
        -:11238:                                    Printf("GREATER_THAN ");\
        -:11239:                                if(pat->v.fl & ATOM) Printf("ATOM ");\
        -:11240:                                if(pat->v.fl & FENCE) Printf("FENCE ");\
        -:11241:                                if(pat->v.fl & IDENT) Printf("IDENT");\
        -:11242:                                Printf("\n");)
    67742:11243:                            return s.c.rmr ^ (char)NIKS(pat);
        -:11244:                            }
        -:11245:                    /* H        SL,SR=shift_right divisionPoint */
   669152:11246:                        if(  kop(loc) == kop(pat)
   263997:11247:                          && loc->RIGHT != snijaf
        -:11248:                          )
   263997:11249:                            loc = loc->RIGHT;
        -:11250:                        else
   405155:11251:                            loc = NULL;
        -:11252:                        /* SL = lhs divisionPoint S, SR = rhs divisionPoint S
        -:11253:                        */
   669152:11254:                        ++locpos;
        -:11255:                    /* I        leftResult=SL:car(P) */
   669152:11256:                        s.c.lmr = match(ind+1,sub, pat->LEFT, loc,pposition,sub,kop(pat));
        -:11257:                        }
        -:11258:                    /* J    if leftResult.succes */
   455407:11259:                    if(s.c.lmr & TRUE)
        -:11260:                    /* K        rightResult=0(P):cdr(pat) */
        -:11261:                        {
   185924:11262:                        s.c.rmr = match(ind+1,nil(pat),pat->RIGHT, NULL,locpos,expr,kop(pat));
   185924:11263:                        s.c.rmr &= ~ONCE;
        -:11264:                        }
        -:11265:                    /* L    return */
        -:11266:                        /* Return true if full success.
        -:11267:
        -:11268:                           Also return whether lhs experienced max position
        -:11269:                           being reached. */
   455407:11270:                    if(!(s.c.rmr & POSITION_MAX_REACHED))
   455393:11271:                        s.c.rmr &= ~POSITION_ONCE;
        -:11272:         /*           if(!SUBJECTNOTNIL(sub,pat))
        -:11273:                        s.c.rmr &= ~POSITION_MAX_REACHED; */
        -:11274:                        /* Also return whether the pattern as a whole doesn't
        -:11275:                           want longer subjects, which can be found out by
        -:11276:                           looking at the pattern. */
   455407:11277:                    if(/*snijaf &&*/ oncePattern(pat))
        -:11278:                        /* The test snijaf != NULL merely avoids that
        -:11279:                        oncePattern is called when it is useless. */
        -:11280:                        { /* Test:
        -:11281:                          a b c d e:`(a ?x) (?z:d) ?
        -:11282:                          x=
        -:11283:                          z=b
        -:11284:                          */
       36:11285:                        s.c.rmr |= ONCE;
       36:11286:                        s.c.rmr |= (char)(pat->v.fl & FENCE);
        -:11287:                        }
        -:11288:                        /* POSITION_ONCE requires zero size subjects. */
        -:11289:                    /*
        -:11290:                    if(!(s.c.lmr & POSITION_ONCE))
        -:11291:                        s.c.rmr &= ~POSITION_ONCE;
        -:11292:                        */
        -:11293:
        -:11294:                        /* Also return the fence flag, which can be found on
        -:11295:                           the pattern or in the result of the lhs or the rhs.
        -:11296:                           (Not necessary that both have this flag.)
        -:11297:                        */
        -:11298:                    /* s.c.rmr |= (s.c.lmr & FENCE);*/
   455407:11299:                    s.c.rmr ^= (char)NIKS(pat);
   455407:11300:                    return s.c.rmr;
        -:11301:                    /* end */
        -:11302:                    }
        -:11303:                case EXP:
        -:11304:                    /* 20100806 */
   189159:11305:                    if(kop(sub) == EXP)
        -:11306:                        {
     8302:11307:                        if ((s.c.lmr = match(ind+1,sub->LEFT, pat->LEFT, NULL,0,sub->LEFT,12345)) & TRUE)
     3906:11308:                            s.c.rmr = match(ind+1,sub->RIGHT, pat->RIGHT, NULL,0,sub->RIGHT,12345);
     8302:11309:                        s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE)); /* a*b^2*c:?x*?y^(~1:?t)*?z */
        -:11310:                        }
   180857:11311:                    else if(  ((s.c.lmr = match(ind+1,sub, pat->LEFT, snijaf,pposition,expr,op)) & TRUE)
    50824:11312:                        && ((s.c.rmr = match(ind+1,&eenk, pat->RIGHT, NULL,0,&eenk,1234567)) & TRUE)
        -:11313:                        )
        -:11314:                        { /* a^2*b*c*d^3 : ?x^(?s:~1)*?y^?t*?z^(>2:?u) */
      553:11315:                        s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE));
        -:11316:                        }
   189159:11317:                    break;
        -:11318:                case STREEP:
     1493:11319:                    if (is_op(sub))
        -:11320:                        {
      779:11321:                        if(kop(sub) == WORDT)
        -:11322:                            {
        2:11323:                            if(ISBUILTIN((objectknoop*)sub))
        -:11324:                                {
    #####:11325:                                errorprintf("You cannot match an object '=' with '_' if the object is built-in\n");
    #####:11326:                                s.c.rmr = ONCE;
        -:11327:                                }
        -:11328:                            else
        -:11329:                                {
        2:11330:                                if((s.c.lmr = match(ind+1,sub->LEFT, pat->LEFT, NULL,0,sub->LEFT,12345)) & TRUE)
        -:11331:                                    {
        2:11332:                                    loc = zelfde_als_w(sub->RIGHT); /*20120821 Object might change as a side effect!*/
        2:11333:                                    if((s.c.rmr = match(ind+1,loc, pat->RIGHT, snijaf,0,loc,123)) & TRUE)
        -:11334:                                        {
        2:11335:                                        dummy_op = kop(sub);
        -:11336:                                        }
        2:11337:                                    wis(loc);
        -:11338:                                    }
        -:11339:                                }
        -:11340:                            }
      777:11341:                        else if(  ((s.c.lmr = match(ind+1,sub->LEFT, pat->LEFT, NULL,0,sub->LEFT,12345)) & TRUE)
      777:11342:                               && ((s.c.rmr = match(ind+1,sub->RIGHT, pat->RIGHT, snijaf,0,sub->RIGHT,123)) & TRUE)
        -:11343:                               ) /* NULL --> snijaf 20031110 */
        -:11344:                            {
      777:11345:                            dummy_op = kop(sub);
        -:11346:                            }
        -:11347:                        }
     1493:11348:                    if (s.c.lmr != PRISTINE)
      779:11349:                        s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE));
     1493:11350:                    break;
        -:11351:                case EN:
    46396:11352:                    if ((s.c.lmr = match(ind+1,sub, pat->LEFT, snijaf,pposition,expr,op)) & TRUE)
        -:11353:                        {
     1355:11354:                        loc = zelfde_als_w(pat->RIGHT);
        -:11355:                        /* 13 november 1991 */
     1355:11356:                        loc = eval(loc);
     1355:11357:                        if (loc->v.fl & SUCCESS)
        -:11358:                            {
      206:11359:                            s.c.rmr = TRUE;
      206:11360:                            if(loc->v.fl & FENCE)
        1:11361:                                s.c.rmr |= ONCE;
        -:11362:                            }
        -:11363:                        else
        -:11364:                            {
     1149:11365:                            s.c.rmr = FALSE;
     1149:11366:                            if (loc->v.fl & FENCE)
    #####:11367:                                s.c.rmr |= (FENCE | ONCE);        /* 13 november 1991 */
        -:11368:                            }
     1355:11369:                        wis(loc);
        -:11370:                        }
        -:11371:                    /*if (s.c.lmr != SCHAR_MAX)*/
    46396:11372:                        s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE));
    46396:11373:                    break;
        -:11374:                case MATCH:
   241751:11375:                    if ((s.c.lmr = match(ind+1,sub, pat->LEFT, snijaf,pposition,expr,op)) & TRUE)
        -:11376:                        {
   183563:11377:                        if((pat->v.fl & ATOM)
        -:11378:#if !STRINGMATCH_CAN_BE_NEGATED
        4:11379:                            && !ONTKENNING(pat->v.fl,ATOM)
        -:11380:#endif
        -:11381:                            )
        -:11382:#if CUTOFFSUGGEST
        1:11383:                            s.c.rmr = (char)(stringmatch(ind+1,"U",SPOBJ(sub),NULL,pat->RIGHT, sub,0,strlen((char*)SPOBJ(sub)),NULL,0) & TRUE /* TODO stringmatch code doesn't have & TRUE */);
        -:11384:#else
        -:11385:                            s.c.rmr = (char)(stringmatch(ind+1,"U",POBJ(sub),NULL,pat->RIGHT, sub,0,strlen((char*)POBJ(sub))) & TRUE /* TODO stringmatch code doesn't have & TRUE */);
        -:11386:#endif
        -:11387:                        else
   183562:11388:                            s.c.rmr = (char)(match(ind+1,sub, pat->RIGHT, snijaf,pposition,expr,op) & TRUE /* TODO stringmatch code doesn't have & TRUE */);
        -:11389:                        }
        -:11390:                    else
    58188:11391:                        s.c.rmr = FALSE;
   241751:11392:                    s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE | POSITION_MAX_REACHED));
        -:11393: /*
        -:11394:dbg'(x y z f t m a i n l:? ((m a i n|f t):?X) ?W) & out$(X !X W !W)
        -:11395:correct:X f t W m a i n l
        -:11396:
        -:11397:@(jfhljkhlhfgjkhfas:? ((lh|jk):?W) ?) & !W
        -:11398:wrong: jf
        -:11399:correct: jk
        -:11400:*/
   241751:11401:                    break;
        -:11402:                case OF:
    55624:11403:                    if ( (s.c.lmr = (char)match(ind+1,sub, pat->LEFT, snijaf,pposition,expr,op))
    27812:11404:                       & (TRUE | FENCE)
        -:11405:                       )
        -:11406:                        {
      476:11407:                        if((s.c.lmr & ONCE) && !oncePattern(pat->RIGHT))
        -:11408:                            {
      275:11409:                            s.c.rmr = (char)(s.c.lmr & TRUE);
        -:11410:                            }
        -:11411:                        else
        -:11412:                            {
      201:11413:                            s.c.rmr = (char)(s.c.lmr & (TRUE|ONCE));
        -:11414:                            }
        -:11415:                        }
        -:11416:                    else
        -:11417:                        {
    27336:11418:                        s.c.rmr = match(ind+1,sub, pat->RIGHT, snijaf,pposition,expr,op);
    27336:11419:                        if(  (s.c.rmr & ONCE)
     6441:11420:                          && !(s.c.lmr & ONCE)
        -:11421:                          )
        -:11422:                            {
        3:11423:                            s.c.rmr &= ~(ONCE|POSITION_ONCE);
        -:11424:                            }
    27336:11425:                        if(  (s.c.rmr & POSITION_MAX_REACHED)
    #####:11426:                          && !(s.c.lmr & POSITION_MAX_REACHED)
        -:11427:                          )
        -:11428:                            {
    #####:11429:                            s.c.rmr &= ~(POSITION_MAX_REACHED|POSITION_ONCE);
        -:11430:                            }
        -:11431:                        }
        -:11432:                    DBGSRC(Printf("%d%*s",ind,ind,"");\
        -:11433:                        Printf("OF s.c.lmr %d s.c.rmr %d\n",s.c.lmr,s.c.rmr);)
        -:11434:/*
        -:11435::?W:?X:?Y:?Z & dbg'(a b c d:?X (((a ?:?W) & ~`|?Y)|?Z) d) & out$(X !X W !W Y !Y Z !Z)
        -:11436:erroneous: X a W a b c d Y b c Z
        -:11437:expected: X W a b c Y Z a b c
        -:11438:*/
    27812:11439:                    break;
        -:11440:/*
        -:11441:20070222 This is now much quicker than previously, because the whole expression
        -:11442:(|bc|x) is ONCE if the start of the subject does not match the start of any of
        -:11443:the alternations:
        -:11444:dbg'(h h h h h h h h h b b b b b b b b b b b b b b b b b b b b b b b b b b b b
        -:11445:b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b
        -:11446:b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b b
        -:11447:b b h h h a b c d:?X (|b c|x) d)
        -:11448:*/
        -:11449:                case FUN:
        -:11450:                    /* 20110829 Test whether $ is escape */
      371:11451:                    if(atomtest(pat->LEFT) == 0)
        -:11452:                        {
       74:11453:                        if(  ((sub->v.fl & (UNIFY|FLGS|NOT)) & (pat->RIGHT->v.fl & (UNIFY|FLGS|NOT))) 
       37:11454:                          == (pat->RIGHT->v.fl & (UNIFY|FLGS|NOT))
        -:11455:                          )
        -:11456:                            {
       35:11457:                            if(is_op(pat->RIGHT))
        -:11458:                                {
       19:11459:                                if(kop(sub) == kop(pat->RIGHT))
        -:11460:                                    {
       18:11461:                                    if ((s.c.lmr = match(ind+1,sub->LEFT, pat->RIGHT->LEFT, NULL,0,sub->LEFT,9999)) & TRUE)
       18:11462:                                        s.c.rmr = match(ind+1,sub->RIGHT, pat->RIGHT->RIGHT, NULL,0,sub->RIGHT,8888);
       18:11463:                                    s.c.rmr |= (char)(s.c.lmr & ONCE); /*{?} (=!(a.b)):(=$!(a.b)) => =!(a.b)*/
        -:11464:                                    }
        -:11465:                                else
        1:11466:                                    s.c.rmr = (char)ONCE; /*{?} (=!(a.b)):(=$!(a,b)) => F */
        -:11467:                                }
        -:11468:                            else /* 20110831 */
        -:11469:                                { 
       16:11470:                                if(  !(pat->RIGHT->v.fl & MINUS)
        6:11471:                                  || (  !is_op(sub) 
        5:11472:                                     && (sub->v.fl & MINUS)
        -:11473:                                     )
        -:11474:                                  )
        -:11475:                                    {
       26:11476:                                    if(!pat->RIGHT->u.obj)
        -:11477:                                        {
       11:11478:                                        if(pat->RIGHT->v.fl & UNOPS)
        6:11479:                                            s.c.rmr = (char)(TRUE|ONCE); /*{?} (=!):(=$!) => =! */
        -:11480:                                                                         /*{?} (=!(a.b)):(=$!) => =!(a.b) */
        -:11481:                                                                         /*{?} (=-a):(=$-) => =-a */
        5:11482:                                        else if(  !(sub->v.fl & (UNIFY|FLGS|NOT))
        4:11483:                                               && (is_op(sub) || !(sub->v.fl & MINUS))
        -:11484:                                               )
        -:11485:                                            {
        2:11486:                                            s.c.rmr = (char)(TRUE|ONCE); /*{?} (=):(=$) => = */
        -:11487:                                                                         /*{?} (=(a.b)):(=$) => =a.b */
        -:11488:                                            }
        -:11489:                                        else
        3:11490:                                            s.c.rmr = (char)ONCE;/*{?} (=-a):(=$) => F */
        -:11491:                                                                         /*{?} (=-):(=$) => F */
        -:11492:                                                                         /*{?} (=#):(=$) => F */
        -:11493:                                        }
        2:11494:                                    else if(  !is_op(sub) 
        2:11495:                                           && pat->RIGHT->u.obj == sub->u.obj
        -:11496:                                           )
        1:11497:                                        s.c.rmr = (char)(TRUE|ONCE); /*{?} (=-!a):(=$-!a) => =!-a */
        -:11498:                                    else
        1:11499:                                        s.c.rmr = (char)ONCE;/*{?} (=-!a):(=$-!b) => F */
        -:11500:                                    }
        -:11501:                                else
        3:11502:                                    s.c.rmr = (char)ONCE; /*{?} (=):(=$-) => F */
        -:11503:                                                                  /*{?} (=(a.b)):(=$-) => F */
        -:11504:                                                                  /*{?} (=a):(=$-) => F */
        -:11505:                                }
        -:11506:                            }
        -:11507:                        else
        2:11508:                            s.c.rmr = (char)ONCE; /*{?} (=!):(=$!!) => F */
       37:11509:                        break;
        -:11510:                        }
        -:11511:                    /* fall through */
        -:11512:                case FUU:
      336:11513:                    psh(&sjt,&nilk,NULL);/*20100910*/
      336:11514:                    copy_insert(&sjt, sub, snijaf);/*20100910*/
      336:11515:                    loc = zelfde_als_w(pat);
      336:11516:                    loc = eval(loc);
      336:11517:                    deleteNode(&sjt);/*20100910*/
      336:11518:                    if(isSUCCESS(loc))/*20100910*/
        -:11519:                        {
      144:11520:                        loc = setflgs(loc,pat->v.fl); /* 20100221 */
      144:11521:                        if (vgl(pat, loc))
        -:11522:                            {
      143:11523:                            s.c.rmr = (char)(match(ind+1,sub, loc, snijaf,pposition,expr,op) ^ NIKS(loc));
      143:11524:                            wis(loc);
      143:11525:                            break;
        -:11526:                            }
        -:11527:                        }
        -:11528:                    else /*"cat" as return value is used as pattern, ~"cat" however is not, because the function failed. */
        -:11529:                        {
      192:11530:                        if(loc->v.fl & FENCE)
    #####:11531:                            s.c.rmr = ONCE; /* '~ as return value from function stops stretching subject */
        -:11532:                        }
      193:11533:                    wis(loc);
        -:11534:                    /* doorvallen */
        -:11535:                default:
   653922:11536:                    if(is_op(pat))
        -:11537:                        {
    30082:11538:                        if(kop(sub) == kop(pat))
        -:11539:                            {
     4735:11540:                            if((s.c.lmr = match(ind+1,sub->LEFT, pat->LEFT, NULL,0,sub->LEFT,4432)) & TRUE)
        -:11541:                                {
     4589:11542:                                if(kop(sub) == WORDT)
        -:11543:                                    {
     2662:11544:                                    loc = zelfde_als_w(sub->RIGHT); /*20120821 Object might change as a side effect!*/
     2662:11545:                                    s.c.rmr = match(ind+1,loc, pat->RIGHT, NULL,0,loc,2234);
     2662:11546:                                    wis(loc);
        -:11547:                                    }
        -:11548:                                else                                    
     1927:11549:                                    s.c.rmr = match(ind+1,sub->RIGHT, pat->RIGHT, NULL,0,sub->RIGHT,2234);
        -:11550:                                }
     4735:11551:                            s.c.rmr |= (char)(s.c.lmr & (FENCE | ONCE));
        -:11552:                            }
        -:11553:                        }
        -:11554:                    else
        -:11555:                        {
        -:11556:                        /* 19971207 register LONG Flgs;*/
        -:11557:                        /*Flgs = pat->v.fl;*/
   623840:11558:                        if (  pat->u.obj
   149096:11559:                           || !(Flgs & (BREUK | NUMBER | NONIDENT | ATOM | IDENT))
        -:11560:                           )
        -:11561:                            {
        -:11562:
   477586:11563:                            s.c.rmr = (char)(/**/ ONCE | /**/ compare(sub, pat));
        -:11564:                            }
        -:11565:                        else         /* e.g.    a b c : % */
        -:11566:                            {
   146254:11567:                            s.c.rmr = TRUE;
        -:11568:                            }
        -:11569:                        }
        -:11570:                }
        -:11571:        }
  2605210:11572:    if(oncePattern(pat) || /* Bart 20070820 (a b X k:(|? b|`) X ?id) must fail*/ (s.c.rmr & (TRUE|FENCE|ONCE)) == FENCE)
        -:11573:        {
   839841:11574:        s.c.rmr |= (char)(pat->v.fl & FENCE);
   839841:11575:        s.c.rmr |= ONCE;
        -:11576:        DBGSRC(Printf("%d%*smatch(",ind,ind,"");results(sub,snijaf);\
        -:11577:            Printf(":");result(pat);Printf(") (B)");)
        -:11578:#ifndef NDEBUG
        -:11579:        DBGSRC(Printf(" rmr t %d o %d p %d m %d f %d ",\
        -:11580:                    s.b.brmr_true,s.b.brmr_once,s.b.brmr_position_once,s.b.brmr_position_max_reached,s.b.brmr_fence);)
        -:11581:#endif
        -:11582:        DBGSRC(if(pat->v.fl & POSITION) Printf("POSITION ");\
        -:11583:            if(pat->v.fl & BREUK) Printf("BREUK ");\
        -:11584:            if(pat->v.fl & NUMBER) Printf("NUMBER ");\
        -:11585:            if(pat->v.fl & SMALLER_THAN) Printf("SMALLER_THAN ");\
        -:11586:            if(pat->v.fl & GREATER_THAN) Printf("GREATER_THAN ");\
        -:11587:            if(pat->v.fl & ATOM) Printf("ATOM ");\
        -:11588:            if(pat->v.fl & FENCE) Printf("FENCE ");\
        -:11589:            if(pat->v.fl & IDENT) Printf("IDENT");\
        -:11590:            Printf("\n");)
        -:11591:        }
  2605210:11592:    if(is_op(pat))
   536979:11593:        s.c.rmr ^= (char)NIKS(pat);
  2605210:11594:    if(name)
     2237:11595:        wis(name);
  2605210:11596:    return s.c.rmr;
        -:11597:    }
        -:11598:
       39:11599:static int subroot(ngetal * ag,char *conc[],int *pind)
        -:11600:    {
        -:11601:    int macht,i;
        -:11602:    unsigned LONG g,smalldivisor;
        -:11603:    unsigned LONG ores;
        -:11604:    static int bijt[12]=
        -:11605:        {1,  2,  2,  4,    2,    4,    2,    4,    6,    2,  6};
        -:11606:    /* 2-3,3-5,5-7,7-11,11-13,13-17,17-19,19-23,23-29,29-1,1-7*/
        -:11607:    unsigned LONG bigdivisor;
        -:11608:
        -:11609:#ifdef ERANGE   /* ANSI C : strtoul() out of range */
       39:11610:    errno = 0;
       39:11611:    g = STRTOUL(ag->number,NULL,10);
       39:11612:    if(errno == ERANGE)
        1:11613:        return FALSE; /*{?} 45237183544316235476^1/2 => 45237183544316235476^1/2 */
        -:11614:#else  /* TURBOC, vcc */
        -:11615:    if(ag.length > 10 || ag.length == 10  && strcmp(ag.number,"4294967295") > 0)
        -:11616:        return FALSE;
        -:11617:    g = STRTOUL(ag.number,NULL,10);
        -:11618:#endif
       38:11619:    ores = 1;
       38:11620:    macht = 1;
       38:11621:    smalldivisor = 2;
       38:11622:    i = 0;
     1016:11623:    while((bigdivisor = g / smalldivisor) >= smalldivisor)
        -:11624:        {
      940:11625:        if(bigdivisor * smalldivisor == g)
        -:11626:            {
       17:11627:            g = bigdivisor;
       17:11628:            if(smalldivisor != ores)
        -:11629:                {
       12:11630:                if(ores != 1)
        -:11631:                    {
        5:11632:                    if(ores < 1000)
        -:11633:                        {
        5:11634:                        conc[(*pind)] = (char *)bmalloc(__LINE__,12);/*{?} 327365274^1/2 => 2^1/2*3^1/2*2477^1/2*22027^1/2 */
        -:11635:                        }
        -:11636:                    else
        -:11637:                        {
    #####:11638:                        conc[*pind] = (char *)bmalloc(__LINE__,20);
        -:11639:                        }
        5:11640:                    sprintf(conc[(*pind)++],"%lu^(%d*\1)*",ores,macht);
        -:11641:                    }
       12:11642:                macht = 1;
       12:11643:                ores = smalldivisor;
        -:11644:                }
        -:11645:            else
        -:11646:                {
        5:11647:                macht++; /*{?} 80956863^1/2 => 3*13^1/2*541^1/2*1279^1/2 */
        -:11648:                }
        -:11649:            }
        -:11650:        else
        -:11651:            {
      923:11652:            smalldivisor += bijt[i];
      923:11653:            if(++i > 10)
      105:11654:                i = 3;
        -:11655:            }
        -:11656:        }
       38:11657:    if(ores == 1 && macht == 1)
       31:11658:        return FALSE;
        7:11659:    conc[*pind] = (char *)bmalloc(__LINE__,24);
        7:11660:    if((ores == g && ++macht) || ores == 1)
        3:11661:        sprintf(conc[(*pind)++],"%lu^(%d*\1)",g,macht); /*{?} 32^1/2 => 2^5/2 */
        -:11662:    else
        4:11663:        sprintf(conc[(*pind)++],"%lu^(%d*\1)*%lu^\1",ores,macht,g);
        7:11664:    return TRUE;
        -:11665:    }
        -:11666:
      339:11667:static int abseen(psk kn)
        -:11668:{
        -:11669:char *pstring;
      339:11670:pstring = SPOBJ(kn);
      339:11671:return(*pstring == '1' && *++pstring == 0);
        -:11672:}
        -:11673:
        -:11674:
        -:11675:#define UNDERSCORE 1
        -:11676:
   519029:11677:static psk _linkertak(psk pkn)
        -:11678:{
        -:11679:psk lknoop;
   519029:11680:lknoop = pkn->LEFT;
   519029:11681:if(!(pkn->v.fl & SUCCESS))
        -:11682:    {
       12:11683:    lknoop = prive(lknoop);
       12:11684:    lknoop->v.fl ^= SUCCESS;
        -:11685:    }
   519029:11686:if((pkn->v.fl & FENCE) && !(lknoop->v.fl & FENCE))
        -:11687:    {
        2:11688:    lknoop = prive(lknoop);
        2:11689:    lknoop->v.fl |= FENCE;
        -:11690:    }
   519029:11691:wis(pkn->RIGHT);
   519029:11692:return lknoop;
        -:11693:}
        -:11694:
    10092:11695:static psk linkertak(psk pkn)
        -:11696:{
    10092:11697:psk lknoop = _linkertak(pkn);
    10092:11698:pskfree(pkn);
    10092:11699:return lknoop;
        -:11700:}
        -:11701:
    15381:11702:static psk _flinkertak(psk pkn)
        -:11703:{
        -:11704:psk lknoop;
    15381:11705:lknoop = pkn->LEFT;
    15381:11706:if(pkn->v.fl & SUCCESS)
        -:11707:    {
    15374:11708:    lknoop = prive(lknoop);
    15374:11709:    lknoop->v.fl ^= SUCCESS;
        -:11710:    }
    15381:11711:if((pkn->v.fl & FENCE) && !(lknoop->v.fl & FENCE))
        -:11712:    {
    #####:11713:    lknoop = prive(lknoop);
    #####:11714:    lknoop->v.fl |= FENCE;
        -:11715:    }
    15381:11716:wis(pkn->RIGHT);
    15381:11717:return lknoop;
        -:11718:}
        -:11719:
        1:11720:static psk flinkertak(psk pkn)
        -:11721:{
        1:11722:psk lknoop = _flinkertak(pkn);
        1:11723:pskfree(pkn);
        1:11724:return lknoop;
        -:11725:}
        -:11726:
    68413:11727:static psk _fencelinkertak(psk pkn)
        -:11728:{
        -:11729:psk lknoop;
    68413:11730:lknoop = pkn->LEFT;
    68413:11731:if(!(pkn->v.fl & SUCCESS))
        -:11732:    {
    #####:11733:    lknoop = prive(lknoop);
    #####:11734:    lknoop->v.fl ^= SUCCESS;
        -:11735:    }
    68413:11736:if(pkn->v.fl & FENCE) /* 19980207 */
        -:11737:    {
    #####:11738:    if(!(lknoop->v.fl & FENCE))
        -:11739:        {
    #####:11740:        lknoop = prive(lknoop);
    #####:11741:        lknoop->v.fl |= FENCE;
        -:11742:        }
        -:11743:    }
    68413:11744:else if(lknoop->v.fl & FENCE)
        -:11745:    {
      178:11746:    lknoop = prive(lknoop);
      178:11747:    lknoop->v.fl &= ~FENCE;
        -:11748:    }
        -:11749:/*
        -:11750:if(pkn->v.fl & FENCE && !(lknoop->v.fl & FENCE))
        -:11751:    {
        -:11752:    lknoop = prive(lknoop);
        -:11753:    lknoop->v.fl |= FENCE;
        -:11754:    }
        -:11755:else
        -:11756:if(lknoop->v.fl & FENCE)
        -:11757:    {
        -:11758:    lknoop = prive(lknoop);
        -:11759:    lknoop->v.fl &= ~FENCE;
        -:11760:    }
        -:11761:*/
    68413:11762:wis(pkn->RIGHT);
    68413:11763:return lknoop;
        -:11764:}
        -:11765:
   344933:11766:static psk _rechtertak(psk pkn)
        -:11767:{
        -:11768:psk rknoop;
   344933:11769:rknoop = pkn->RIGHT;
   344933:11770:if(!(pkn->v.fl & SUCCESS))
        -:11771:    {
      346:11772:    rknoop = prive(rknoop);
      346:11773:    rknoop->v.fl ^= SUCCESS;
        -:11774:    }
   344933:11775:if((pkn->v.fl & FENCE) && !(rknoop->v.fl & FENCE))
        -:11776:    {
        2:11777:    rknoop = prive(rknoop);
        2:11778:    rknoop->v.fl |= FENCE;
        -:11779:    }
   344933:11780:wis(pkn->LEFT);
   344933:11781:return rknoop;
        -:11782:}
        -:11783:
     5299:11784:static psk rechtertak(psk pkn)
        -:11785:{
     5299:11786:psk rknoop = _rechtertak(pkn);
     5299:11787:pskfree(pkn);
     5299:11788:return rknoop;
        -:11789:}
        -:11790:
    26544:11791:static void pop(psk kn)
        -:11792:    {
    72695:11793:    while(is_op(kn))
        -:11794:        {
    19607:11795:        pop(kn->LEFT);
        -:11796:        /* pop(kn->RIGHT);
        -:11797:        18 Maart 1997 */
    19607:11798:        kn = kn->RIGHT;
        -:11799:        }
    26544:11800:    deleteNode(kn);
    26544:11801:    }
        -:11802:
     1338:11803:static psk tryq(psk pkn,psk fun,Boolean * ok)
        -:11804:    {
        -:11805:    psk anker;
     1338:11806:    psh(&argk,pkn,NULL);
     1338:11807:    pkn->v.fl |= READY;
        -:11808:
     1338:11809:    anker = subboomcopie(fun->RIGHT);
        -:11810:
     1338:11811:    psh(fun->LEFT,&nulk,NULL);
     1338:11812:    anker = eval(anker);
     1338:11813:    pop(fun->LEFT);
     1338:11814:    if(anker->v.fl & SUCCESS)
        -:11815:        {
      991:11816:        *ok = TRUE;
      991:11817:        wis(pkn);
      991:11818:        pkn = anker;
        -:11819:        }
        -:11820:    else
        -:11821:        {
      347:11822:        *ok = FALSE;
      347:11823:        wis(anker);
        -:11824:        }
     1338:11825:    deleteNode(&argk);
     1338:11826:    return pkn;
        -:11827:    }
        -:11828:
      657:11829:static psk * backbone(psk arg,psk pkn,psk * pfirst)
        -:11830:    {
      657:11831:    psk first = *pfirst = subboomcopie(arg);
      657:11832:    psk * plast = pfirst;
     1441:11833:    while(arg != pkn)
        -:11834:        {
      127:11835:        psk R = subboomcopie((*plast)->RIGHT);
      127:11836:        wis((*plast)->RIGHT);
      127:11837:        (*plast)->RIGHT = R;
      127:11838:        plast = &((*plast)->RIGHT);
      127:11839:        arg = arg->RIGHT;
        -:11840:        }
      657:11841:    *pfirst = first;
      657:11842:    return plast;
        -:11843:    }
        -:11844:
    15446:11845:static psk rechteroperand(psk pkn)
        -:11846:{
        -:11847:psk temp;
        -:11848:unsigned int teken;
    15446:11849:temp = (pkn->RIGHT);
    37407:11850:return((teken = kop(pkn)) == kop(temp) &&
     6515:11851:        (teken == PLUS || teken == MAAL || teken == LUCHT) ?
    21961:11852:       temp->LEFT : temp);
        -:11853:}
        -:11854:
        -:11855:/* 20111201 */
      717:11856:static psk evalmacro(psk pkn)
        -:11857:    {
      717:11858:    if(!is_op(pkn))
        -:11859:        {
      132:11860:        return NULL;
        -:11861:        }
        -:11862:    else
        -:11863:        {
      585:11864:        psk arg = pkn;
     1232:11865:        while(!(pkn->v.fl & READY))
        -:11866:            {
      647:11867:            if(atomtest(pkn->LEFT) != 0)
        -:11868:                {
      188:11869:                psk left = evalmacro(pkn->LEFT);
      188:11870:                if(left != NULL)
        -:11871:                    {
        -:11872:                    /* copy backbone from evalmacro's argument to current pkn
        -:11873:                    // release lhs of copy of current and replace with 'left'
        -:11874:                    // assign copy to 'pkn'
        -:11875:                    // evalmacro current, if not null, replace current
        -:11876:                    // return current
        -:11877:                    */
        -:11878:                    psk ret;
       74:11879:                    psk first = NULL;
       74:11880:                    psk * last = backbone(arg,pkn,&first);
       74:11881:                    wis((*last)->LEFT);
       74:11882:                    (*last)->LEFT = left;
       74:11883:                    if(atomtest((*last)->LEFT) == 0 && kop((*last)) == FUN)
        -:11884:                        {
    #####:11885:                        ret = evalmacro(*last);
    #####:11886:                        if(ret)
        -:11887:                            {
    #####:11888:                            wis(*last);
    #####:11889:                            *last = ret;
        -:11890:                            }
        -:11891:                        }
        -:11892:                    else
        -:11893:                        {
       74:11894:                        psk right = evalmacro((*last)->RIGHT);
       74:11895:                        if(right)
        -:11896:                            {
       26:11897:                            wis((*last)->RIGHT);
       26:11898:                            (*last)->RIGHT = right;
        -:11899:                            }
        -:11900:                        }
       74:11901:                    return first;
        -:11902:                    }
        -:11903:                }
      459:11904:            else if(kop(pkn) == FUN)
        -:11905:                {
      446:11906:                if(kop(pkn->RIGHT) == STREEP)
        -:11907:                    {
        -:11908:                    int Flgs;
        -:11909:                    psk h;
        -:11910:                    psk hh;
       18:11911:                    psk first = NULL;
        -:11912:                    psk * last;
       18:11913:                    Flgs = pkn->v.fl & (UNOPS|SUCCESS);
       18:11914:                    h = subboomcopie(pkn->RIGHT);
       18:11915:                    if(dummy_op == WORDT)
        -:11916:                        {
        1:11917:                        psk becomes = (psk)bmalloc(__LINE__,sizeof(objectknoop));
        -:11918:#ifdef BUILTIN
        1:11919:                        ((typedObjectknoop*)becomes)->u.Int = 0;
        -:11920:#else
        -:11921:                        ((typedObjectknoop*)*R)->refcount = 0;
        -:11922:                        UNSETCREATEDWITHNEW((typedObjectknoop*)*R);
        -:11923:                        UNSETBUILTIN((typedObjectknoop*)*R);
        -:11924:#endif
        1:11925:                        becomes->LEFT = zelfde_als_w(h->LEFT);
        1:11926:                        becomes->RIGHT = zelfde_als_w(h->RIGHT);
        1:11927:                        wis(h);
        1:11928:                        h = becomes;
        -:11929:                        }
       18:11930:                    h->v.fl = dummy_op | Flgs;
       18:11931:                    hh = evalmacro(h->LEFT);
       18:11932:                    if(hh)
        -:11933:                        {
        3:11934:                        wis(h->LEFT);
        3:11935:                        h->LEFT = hh;
        -:11936:                        }
       18:11937:                    hh = evalmacro(h->RIGHT);
       18:11938:                    if(hh)
        -:11939:                        {
        3:11940:                        wis(h->RIGHT);
        3:11941:                        h->RIGHT = hh;
        -:11942:                        }
       18:11943:                    last = backbone(arg,pkn,&first);
       18:11944:                    wis(*last);
       18:11945:                    *last = h;
       18:11946:                    return first;
        -:11947:                    }
      428:11948:                else if(  kop(pkn->RIGHT) == FUN
        2:11949:                       && atomtest(pkn->RIGHT->LEFT) == 0
        -:11950:                       )
        -:11951:                    {
        -:11952:                    int Flgs;
        -:11953:                    psk h;
        -:11954:                    psk hh;
        2:11955:                    psk first = NULL;
        -:11956:                    psk * last;
        2:11957:                    Flgs = pkn->v.fl & UNOPS;
        2:11958:                    h = subboomcopie(pkn->RIGHT);
        2:11959:                    h->v.fl |= Flgs;
        2:11960:                    hh = evalmacro(h->LEFT);
        2:11961:                    if(hh)
        -:11962:                        {
    #####:11963:                        wis(h->LEFT);
    #####:11964:                        h->LEFT = hh;
        -:11965:                        }
        2:11966:                    hh = evalmacro(h->RIGHT);
        2:11967:                    if(hh)
        -:11968:                        {
    #####:11969:                        wis(h->RIGHT);
    #####:11970:                        h->RIGHT = hh;
        -:11971:                        }
        2:11972:                    last = backbone(arg,pkn,&first);
        2:11973:                    wis(*last);
        2:11974:                    *last = h;
        2:11975:                    return first;
        -:11976:                    }
        -:11977:                else
        -:11978:                    {
        -:11979:                    int newval;
      426:11980:                    psk tmp = zelfde_als_w(pkn->RIGHT);
        -:11981:                    psk h;
      426:11982:                    tmp = eval(tmp);
        -:11983:
      426:11984:                    if((h = find(tmp,&newval,NULL)) != NULL)
        -:11985:                        {
        -:11986:                        int Flgs;
      426:11987:                        psk first = NULL;
        -:11988:                        psk * last;
      426:11989:                        if((kop(h) == WORDT) && ISBUILTIN((objectknoop *)h))
        -:11990:                            {
        6:11991:                            if(!newval)
        3:11992:                                h = zelfde_als_w(h);
        -:11993:                            }
        -:11994:                        else
        -:11995:                            {
      423:11996:                            Flgs = pkn->v.fl & (UNOPS);
      423:11997:                            if(!newval)
        -:11998:                                {
      419:11999:                                h = subboomcopie(h);
        -:12000:                                }
      423:12001:                            if(Flgs)
        -:12002:                                {
       13:12003:                                h->v.fl |= Flgs;
       13:12004:                                if(h->v.fl & INDIRECT)
    #####:12005:                                    h->v.fl &= ~READY;
        -:12006:                                }
      410:12007:                            else if(h->v.fl & INDIRECT)
        -:12008:                                { /* 20080128 */
        6:12009:                                h->v.fl &= ~READY;
        -:12010:                                }
      404:12011:                            else if(kop(h) == WORDT) /* 20111107 */
        -:12012:                                { 
       20:12013:                                h->v.fl &= ~READY;
        -:12014:                                }
        -:12015:                            }
        -:12016:
      426:12017:                        wis(tmp);
      426:12018:                        last = backbone(arg,pkn,&first);
      426:12019:                        wis(*last);
      426:12020:                        *last = h;
      426:12021:                        return first;
        -:12022:                        }
        -:12023:                    else
        -:12024:                        {
    #####:12025:                        errorprintf("\nmacro evaluation fails because rhs of $ operator is not bound to a value");writeError(pkn->RIGHT);errorprintf("\n");
    #####:12026:                        wis(tmp);
    #####:12027:                        return NULL;
        -:12028:                        }
        -:12029:                    }
        -:12030:                }
      127:12031:            pkn = pkn->RIGHT;
      127:12032:            if(!is_op(pkn))
        -:12033:                {
       65:12034:                break;
        -:12035:                }
        -:12036:            }
        -:12037:        }
       65:12038:    return NULL;
        -:12039:    }
        -:12040:
      277:12041:static psk lambda(psk pkn,psk name,psk Arg)
        -:12042:    {
      277:12043:    if(!is_op(pkn))
        -:12044:        {
       44:12045:        return NULL;
        -:12046:        }
        -:12047:    else
        -:12048:        {
      233:12049:        psk arg = pkn;
      544:12050:        while(!(pkn->v.fl & READY))
        -:12051:            {
      285:12052:            if(atomtest(pkn->LEFT) != 0)
        -:12053:                {
      170:12054:                psk left = lambda(pkn->LEFT,name,Arg);
      170:12055:                if(left != NULL)
        -:12056:                    {
        -:12057:                    /* copy backbone from lambda's argument to current pkn
        -:12058:                    // release lhs of copy of current and replace with 'left'
        -:12059:                    // assign copy to 'pkn'
        -:12060:                    // lambda current, if not null, replace current
        -:12061:                    // return current
        -:12062:                    */
        -:12063:                    psk ret;
       75:12064:                    psk first = NULL;
       75:12065:                    psk * last = backbone(arg,pkn,&first);
       75:12066:                    wis((*last)->LEFT);
       75:12067:                    (*last)->LEFT = left;
       75:12068:                    if(atomtest((*last)->LEFT) == 0 && kop((*last)) == FUN)
        -:12069:                        {
    #####:12070:                        ret = lambda(*last,name,Arg);
    #####:12071:                        if(ret)
        -:12072:                            {
    #####:12073:                            wis(*last);
    #####:12074:                            *last = ret;
        -:12075:                            }
        -:12076:                        }
        -:12077:                    else
        -:12078:                        {
       75:12079:                        psk right = lambda((*last)->RIGHT,name,Arg);
       75:12080:                        if(right)
        -:12081:                            {
       31:12082:                            wis((*last)->RIGHT);
       31:12083:                            (*last)->RIGHT = right;
        -:12084:                            }
        -:12085:                        }
       75:12086:                    return first;
        -:12087:                    }
        -:12088:                }
      115:12089:            else if(kop(pkn) == FUN)
        -:12090:                {
      100:12091:                if(kop(pkn->RIGHT) == STREEP)
        -:12092:                    {
        -:12093:                    int Flgs;
        -:12094:                    psk h;
        -:12095:                    psk hh;
    #####:12096:                    psk first = NULL;
        -:12097:                    psk * last;
    #####:12098:                    Flgs = pkn->v.fl & (UNOPS|SUCCESS);
    #####:12099:                    h = subboomcopie(pkn->RIGHT);
    #####:12100:                    if(dummy_op == WORDT)
        -:12101:                        {
    #####:12102:                        psk becomes = (psk)bmalloc(__LINE__,sizeof(objectknoop));
        -:12103:#ifdef BUILTIN
    #####:12104:                        ((typedObjectknoop*)becomes)->u.Int = 0;
        -:12105:#else
        -:12106:                        ((typedObjectknoop*)*R)->refcount = 0;
        -:12107:                        UNSETCREATEDWITHNEW((typedObjectknoop*)*R);
        -:12108:                        UNSETBUILTIN((typedObjectknoop*)*R);
        -:12109:#endif
    #####:12110:                        becomes->LEFT = zelfde_als_w(h->LEFT);
    #####:12111:                        becomes->RIGHT = zelfde_als_w(h->RIGHT);
    #####:12112:                        wis(h);
    #####:12113:                        h = becomes;
        -:12114:                        }
    #####:12115:                    h->v.fl = dummy_op | Flgs;
    #####:12116:                    hh = lambda(h->LEFT,name,Arg);
    #####:12117:                    if(hh)
        -:12118:                        {
    #####:12119:                        wis(h->LEFT);
    #####:12120:                        h->LEFT = hh;
        -:12121:                        }
    #####:12122:                    hh = lambda(h->RIGHT,name,Arg);
    #####:12123:                    if(hh)
        -:12124:                        {
    #####:12125:                        wis(h->RIGHT);
    #####:12126:                        h->RIGHT = hh;
        -:12127:                        }
    #####:12128:                    last = backbone(arg,pkn,&first);
    #####:12129:                    wis(*last);
    #####:12130:                    *last = h;
    #####:12131:                    return first;
        -:12132:                    }
      100:12133:                else if(  kop(pkn->RIGHT) == FUN
    #####:12134:                       && atomtest(pkn->RIGHT->LEFT) == 0
        -:12135:                       )
        -:12136:                    {
        -:12137:                    int Flgs;
        -:12138:                    psk h;
        -:12139:                    psk hh;
    #####:12140:                    psk first = NULL;
        -:12141:                    psk * last;
    #####:12142:                    Flgs = pkn->v.fl & UNOPS;
    #####:12143:                    h = subboomcopie(pkn->RIGHT);
    #####:12144:                    h->v.fl |= Flgs;
    #####:12145:                    hh = lambda(h->LEFT,name,Arg);
    #####:12146:                    if(hh)
        -:12147:                        {
    #####:12148:                        wis(h->LEFT);
    #####:12149:                        h->LEFT = hh;
        -:12150:                        }
    #####:12151:                    hh = lambda(h->RIGHT,name,Arg);
    #####:12152:                    if(hh)
        -:12153:                        {
    #####:12154:                        wis(h->RIGHT);
    #####:12155:                        h->RIGHT = hh;
        -:12156:                        }
    #####:12157:                    last = backbone(arg,pkn,&first);
    #####:12158:                    wis(*last);
    #####:12159:                    *last = h;
    #####:12160:                    return first;
        -:12161:                    }
      100:12162:                else if(!vgl(name,pkn->RIGHT))
        -:12163:                    {
        -:12164:                    psk h;
        -:12165:                    psk first;
        -:12166:                    psk * last;
       62:12167:                    h = subboomcopie(Arg);
       62:12168:                    if(h->v.fl & INDIRECT)
        -:12169:                        { /* 20080128 */
    #####:12170:                        h->v.fl &= ~READY;
        -:12171:                        }
       62:12172:                    else if(is_op(h) && kop(h) == WORDT) /* 20111107 */
        -:12173:                        { 
    #####:12174:                        h->v.fl &= ~READY;
        -:12175:                        }
        -:12176:
       62:12177:                    last = backbone(arg,pkn,&first);
       62:12178:                    wis(*last);
       62:12179:                    *last = h;
       62:12180:                    return first;
        -:12181:                    }
        -:12182:                }
       15:12183:            else if (  kop(pkn) == FUU 
       15:12184:                    && (pkn->v.fl & BREUK)
       15:12185:                    && kop(pkn->RIGHT) == DOT
       15:12186:                    && !vgl(name,pkn->RIGHT->LEFT)
        -:12187:                    )
        -:12188:                {
        1:12189:                return NULL;
        -:12190:                }
      147:12191:            pkn = pkn->RIGHT;
      147:12192:            if(!is_op(pkn))
        -:12193:                {
       69:12194:                break;
        -:12195:                }
        -:12196:            }
        -:12197:        }
       95:12198:    return NULL;
        -:12199:    }
        -:12200:
        -:12201:
        1:12202:static void combiflags(psk kn)
        -:12203:{
        -:12204:int lflgs;
        1:12205:if((lflgs = kn->LEFT->v.fl & UNOPS) != 0)
        -:12206:    {
        1:12207:    kn->RIGHT = prive(kn->RIGHT);
        1:12208:    if(NIKSF(lflgs))
        -:12209:        {
    #####:12210:        kn->RIGHT->v.fl |= lflgs & ~NOT;
    #####:12211:        kn->RIGHT->v.fl ^= NOT|SUCCESS;
        -:12212:        }
        -:12213:    else
        1:12214:        kn->RIGHT->v.fl |= lflgs;
        -:12215:    }
        1:12216:}
        -:12217:
        -:12218:
       25:12219:static int is_afhankelyk_van(psk el,psk lijst)
        -:12220:    {
        -:12221:    int ret;
       50:12222:    while(lijst)
        -:12223:        {
        -:12224:        psk hlp;
       25:12225:        if(!vgl(el,(hlp = (kop(lijst) == KOMMA) ? lijst->LEFT : lijst)))
    #####:12226:            return TRUE;
        -:12227:
       25:12228:        if(is_op(hlp))
        -:12229:            {
    #####:12230:            if(is_afhankelyk_van(el,hlp->LEFT)
    #####:12231:            || is_afhankelyk_van(el,hlp->RIGHT))
    #####:12232:                return TRUE;
        -:12233:            }
        -:12234:        else
        -:12235:            {
       25:12236:            psk kn = NULL;
       25:12237:             adr[1] = hlp;
       25:12238:             adr[2] = el;
       25:12239:             kn = opb(kn,"(!dep:(? (\1.? \2 ?) ?)",NULL);
       25:12240:             kn = eval(kn);
       25:12241:             ret = isSUCCESS(kn);
       25:12242:             wis(kn);
       25:12243:             return ret;
        -:12244:            }
        -:12245:        /* return is_afhankelyk_van(el,(kop(lijst) == KOMMA) ? lijst->RIGHT : NULL);
        -:12246:        18 Maart 1997 */
    #####:12247:        lijst = (kop(lijst) == KOMMA) ? lijst->RIGHT : NULL;
        -:12248:        }
    #####:12249:    return FALSE;
        -:12250:    }
        -:12251:
      198:12252:static int zoekopt(psk kn,LONG opt)
        -:12253:    {
      448:12254:    while(is_op(kn))
        -:12255:        {
        -:12256:        /*return zoekopt(kn->LEFT,opt) || zoekopt(kn->RIGHT,opt);
        -:12257:        18 Maart 1997 */
       59:12258:        if(zoekopt(kn->LEFT,opt))
        7:12259:            return TRUE;
       52:12260:        kn = kn->RIGHT;
        -:12261:        /*19970825 continue;*/
        -:12262:        }
      191:12263:    return PLOBJ(kn) == opt;
        -:12264:    }
        -:12265:
        4:12266:static void mmf(ppsk pk)
        -:12267:{
        -:12268:psk goal;
        -:12269:ppsk pgoal;
        -:12270:vars *navar;
        -:12271:int alfabet,ext;
        -:12272:char dim[22];
        4:12273:ext = zoekopt(*pk,EXT);
        4:12274:wis(*pk);
        4:12275:pgoal = pk;
     1028:12276:for(alfabet = 0;alfabet < 256/*0x80*/;alfabet++)
        -:12277:    {
     4227:12278:    for(navar = variabelen[alfabet];
        -:12279:        navar;
     2179:12280:        navar = navar->next)
        -:12281:        {
     2179:12282:        goal = *pgoal = (psk)bmalloc(__LINE__,sizeof(kknoop));
     2179:12283:        goal->v.fl = LUCHT | SUCCESS;
     2179:12284:        if(ext && navar->n > 0) /* was 1 (16 March 1993) */
        -:12285:            {
    #####:12286:            goal = goal->LEFT = (psk)bmalloc(__LINE__,sizeof(kknoop));
    #####:12287:            goal->v.fl = DOT | SUCCESS;
    #####:12288:            sprintf(dim,"%d.%d",navar->n,navar->selector);
    #####:12289:            goal->RIGHT = NULL;
    #####:12290:            goal->RIGHT = opb(goal->RIGHT,dim,NULL);
        -:12291:            }
     2179:12292:        goal = goal->LEFT =
     2179:12293:            (psk)bmalloc(__LINE__,sizeof(unsigned LONG) + 1 + strlen((char *)VARNAME(navar)));
     2179:12294:        goal->v.fl = (READY|SUCCESS);
     2179:12295:        strcpy((char *)(goal)+sizeof(unsigned LONG),(char *)VARNAME(navar));
     2179:12296:        pgoal = &(*pgoal)->RIGHT;
        -:12297:        }
        -:12298:    }
        4:12299:*pgoal = zelfde_als_w(&nilk);
        4:12300:}
        -:12301:
       18:12302:static void lstsub(psk kn)
        -:12303:{
        -:12304:vars *navar;
        -:12305:unsigned char *naam;
        -:12306:int alfabet,n;
       18:12307:mooi = FALSE;
       18:12308:naam = POBJ(kn);
     4626:12309:for(alfabet = 0;alfabet<256;alfabet++)
        -:12310:    {
    41520:12311:    for(navar = variabelen[alfabet];
        -:12312:        navar;
    32304:12313:        navar = navar->next)
        -:12314:        {
    32304:12315:        if((kn->u.obj == 0 && alfabet < 0x80) || !STRCMP(VARNAME(navar),naam))
        -:12316:            {
       36:12317:            for(n = navar->n;n >= 0;n--)
        -:12318:                {
        -:12319:                ppsk tmp;
       18:12320:                if(fpo == stdout)
        -:12321:                    {
    #####:12322:                    if(navar->n > 0)
    #####:12323:                        Printf("%c%d (",n == navar->selector ? '>' : ' ',n);
        -:12324:                    else
    #####:12325:                        Printf("(");
        -:12326:                    }
       18:12327:                if(haalaan(VARNAME(navar)))
    #####:12328:                    myprintf("\"",(char *)VARNAME(navar),"\"=",NULL);
        -:12329:                else
       18:12330:                    myprintf((char *)VARNAME(navar),"=",NULL);
       18:12331:                if(hum)
        8:12332:                    myprintf("\n",NULL);
        -:12333:                assert(navar->pvaria);
       18:12334:                tmp = Entry(navar->n,n,&navar->pvaria);
       18:12335:                result(*tmp = Head(*tmp));
       18:12336:                if(fpo == stdout)
    #####:12337:                    Printf(")");
       18:12338:                myprintf(";\n",NULL);
        -:12339:                }
        -:12340:            }
        -:12341:        }
        -:12342:    }
       18:12343:mooi = TRUE;
       18:12344:}
        -:12345:
       18:12346:static void lst(psk kn)
        -:12347:    {
       36:12348:    while(is_op(kn))
        -:12349:        {
    #####:12350:        lst(kn->LEFT);
        -:12351:        /* lst(kn->RIGHT);
        -:12352:        18 Maart 1997 */
    #####:12353:        kn = kn->RIGHT;
        -:12354:        }
       18:12355:    lstsub(kn);
       18:12356:    }
        -:12357:
       38:12358:static filehendel * findFilehendelByName(const char * name)
        -:12359:    {
        -:12360:    filehendel * fh;
       76:12361:    for(fh = fh0
        -:12362:       ; fh
    #####:12363:       ; fh = fh->next
        -:12364:       )
    #####:12365:        if(!strcmp(fh->naam,name))
    #####:12366:            return fh;
       38:12367:    return NULL;
        -:12368:    }
        -:12369:
       36:12370:static filehendel * allocateFilehendel(const char * name,FILE * fp)
        -:12371:    {
       36:12372:    filehendel * fh = (filehendel*)bmalloc(__LINE__,sizeof(filehendel));
       36:12373:    fh->naam = (char *)bmalloc(__LINE__,strlen(name) + 1);
       36:12374:    strcpy(fh->naam,name);
       36:12375:    fh->fp = fp;
       36:12376:    fh->next = fh0;
       36:12377:    fh0 = fh;
       36:12378:    return fh0;
        -:12379:    }
        -:12380:
       36:12381:static void deallocateFilehendel(filehendel * fh)
        -:12382:    {
        -:12383:    filehendel * fhvorig, * fhh;
       72:12384:    for(fhvorig = NULL,fhh = fh0
        -:12385:	;fhh != fh
    #####:12386:	;fhvorig = fhh,fhh = fhh->next
        -:12387:	)
        -:12388:	;
       36:12389:    if(fhvorig)
    #####:12390:	fhvorig->next = fh->next;
        -:12391:    else
       36:12392:	fh0 = fh->next;
       36:12393:    if(fh->fp)
       36:12394:        fclose(fh->fp);
       36:12395:    bfree(fh->naam);
        -:12396:#if !defined NO_LOW_LEVEL_FILE_HANDLING
       36:12397:    if(fh->stop)
        -:12398:#ifdef BMALLLOC
        -:12399:	bfree(fh->stop);
        -:12400:#else
        1:12401:	free(fh->stop);
        -:12402:#endif
        -:12403:#endif
       36:12404:    bfree(fh);
       36:12405:    }
        -:12406:
       40:12407:filehendel * mygetfilehendel(const char * filename,const char * mode)
        -:12408:    {
       40:12409:    FILE * fp = fopen(filename,mode);
       40:12410:    if(fp)
        -:12411:        {
       36:12412:        filehendel * fh = allocateFilehendel(filename,fp);
       36:12413:        return fh;
        -:12414:        }
        4:12415:    return NULL;
        -:12416:    }
        -:12417:
       38:12418:filehendel * myfopen(const char * filename,const char * mode)
        -:12419:    {
        -:12420:#if !defined NO_FOPEN
       38:12421:    if(findFilehendelByName(filename))
    #####:12422:        return NULL;
        -:12423:    else
        -:12424:        {
       38:12425:        filehendel * fh = mygetfilehendel(filename,mode);
       38:12426:        if(!fh && targetPath && strchr(mode,'r'))
        -:12427:            {
        2:12428:            const char * p = filename;
        -:12429:            char * q;
        -:12430:            size_t len;
       22:12431:            while(*p)
        -:12432:                {
       18:12433:                if(*p == '\\' || *p == '/')
        -:12434:                    {
    #####:12435:                    if(p == filename)
    #####:12436:                        return NULL;
    #####:12437:                    break;
        -:12438:                    }
       18:12439:                else if((*p == ':') && (p == filename + 1))
    #####:12440:                    return NULL;
       18:12441:                ++p;
        -:12442:                }
        2:12443:            q = (char *)malloc((len = strlen(targetPath)) + strlen(filename) + 1);
        2:12444:            if(q)
        -:12445:                {
        2:12446:                strcpy(q,targetPath);
        2:12447:                strcpy(q+len,filename);
        2:12448:                fh = mygetfilehendel(q,mode);
        2:12449:                free(q);
        -:12450:                }
        -:12451:            }
       38:12452:        return fh;
        -:12453:        }
        -:12454:#endif
        -:12455:    return NULL;
        -:12456:    }
        -:12457:
        -:12458:#if !defined NO_LOW_LEVEL_FILE_HANDLING
       17:12459:static LONG someopt(psk kn,LONG opt[])
        -:12460:    {
        -:12461:    int i;
       34:12462:    while(is_op(kn))
        -:12463:        {
        -:12464:        /* return someopt(kn->LEFT,opt) || someopt(kn->RIGHT,opt);
        -:12465:        18 Maart 1997 */
    #####:12466:        if(someopt(kn->LEFT,opt))
    #####:12467:            return TRUE;
    #####:12468:        kn = kn->RIGHT;
        -:12469:        }
      129:12470:    for(i=0;opt[i];i++)
      122:12471:        if(PLOBJ(kn) == opt[i])
       10:12472:            return opt[i];
        7:12473:    return 0L;
        -:12474:    }
        -:12475:
        -:12476:static LONG tijdnr = 0L;
        -:12477:/*
        -:12478:static int openCount = 0;
        -:12479:static int maxOpenCount = 0;
        -:12480:static int allOpenCount = 0;
        -:12481:*/
        -:12482:
    #####:12483:static void sluitfile(filehendel *fh)
        -:12484:{
    #####:12485:fh->filepos = FTELL(fh->fp);
        -:12486:/* fh->filepos != -1 means that the file is closed */
    #####:12487:fclose(fh->fp);
    #####:12488:fh->fp = NULL;
        -:12489:/*--openCount;
        -:12490:Printf("--OPEN %d (%d %d)\n",openCount,maxOpenCount,allOpenCount);
        -:12491:*/
    #####:12492:}
        -:12493:
    #####:12494:static int closeAFile()
        -:12495:    {
        -:12496:    filehendel *fh,*fhmin;
    #####:12497:    if(fh0 == NULL)
    #####:12498:        return FALSE;
    #####:12499:    for(fh = fh0,fhmin = fh0;
        -:12500:        fh != NULL;
    #####:12501:        fh = fh->next)
        -:12502:        {
    #####:12503:        if(fh->filepos == -1L /* fh->fp != NULL */ /* test added 12 Aug 1996 */ && fh->tijd < fhmin->tijd)
    #####:12504:            fhmin = fh;
        -:12505:        }
    #####:12506:    if(fhmin == NULL)/* test added 12 Aug 1996 */
    #####:12507:        return FALSE;
    #####:12508:    sluitfile(fhmin);
    #####:12509:    return TRUE;
        -:12510:    }
        -:12511:
        1:12512:static filehendel * bfopen(char *naam,char *mode)
        -:12513:{
        -:12514:/*FILE *fp;*/
        -:12515:filehendel *fh;
        1:12516:if((fh=myfopen(naam,mode)) == NULL)
        -:12517:    {
    #####:12518:    if(closeAFile())
    #####:12519:        fh=myfopen(naam,mode);
        -:12520:    }
        -:12521:/*
        -:12522:++openCount;
        -:12523:++allOpenCount;
        -:12524:if(openCount > maxOpenCount)
        -:12525:    maxOpenCount = openCount;
        -:12526:Printf("++OPEN %d (%d %d)\n",openCount,maxOpenCount,allOpenCount);
        -:12527:*/
        1:12528:return fh;
        -:12529:}
        -:12530:
    #####:12531:static FILE * brefopen(filehendel * fh)
        -:12532:{
    #####:12533:if((fh->fp = fopen(fh->naam,(char *)&(fh->mode))) == NULL)
        -:12534:    {
    #####:12535:    if(closeAFile())
    #####:12536:        fh->fp = fopen(fh->naam,(char *)&(fh->mode));
        -:12537:    }
    #####:12538:return fh->fp;
        -:12539:}
        -:12540:
        9:12541:static filehendel * preparefp(filehendel * fh,char * naam,LONG mode)
        -:12542:    {
        -:12543:    assert(fh != NULL);
        -:12544:    assert(!strcmp(fh->naam,naam));
        9:12545:    if( mode != 0L /* added 16 July 1996 */
        3:12546:    &&  mode != fh->mode)
        -:12547:        {
        3:12548:        fh->mode = mode;
        3:12549:        if((fh->fp = freopen(fh->naam,(char *)&(fh->mode),fh->fp)) == NULL)
    #####:12550:            return NULL;
        3:12551:        fh->written = FALSE;
        -:12552:        }
        6:12553:    else if(fh->filepos > 0L)
        -:12554:        {
    #####:12555:        if(brefopen(fh) == NULL)
    #####:12556:            return NULL;
    #####:12557:        fh->written = FALSE;
    #####:12558:        FSEEK(fh->fp,fh->filepos,SEEK_SET);
        -:12559:        }
        9:12560:    fh->filepos = -1L;
        9:12561:    fh->tijd = tijdnr++;
        9:12562:    return fh;
        -:12563:    }
        -:12564:/*
        -:12565:Find an existing or create a fresh file handle for a known file name
        -:12566:If the file mode differs from the current file mode,
        -:12567:    reopen the file with the new file mode.
        -:12568:If the file is known but has been closed (e.g. to save file handles),
        -:12569:    open the file with the memorized file mode and go to the memorized position
        -:12570:*/
        1:12571:static filehendel *zoekfp(char *naam,LONG mode)
        -:12572:    {
        -:12573:    filehendel *fh;
        1:12574:    for(fh = fh0;fh;fh = fh->next)
    #####:12575:        if(!strcmp(naam,fh->naam))
    #####:12576:            return preparefp(fh,naam,mode);
        1:12577:    return NULL;
        -:12578:    }
        -:12579:
        5:12580:static void setStop(filehendel *fh,char * stopstring)
        -:12581:    {
        5:12582:    if(fh->stop)
        -:12583:#ifdef BMALLLOC
        -:12584:        bfree(fh->stop);
        -:12585:    fh->stop = (char *)bmalloc(__LINE__,strlen(stopstring + 1);
        -:12586:#else
        1:12587:        free(fh->stop);
        5:12588:    fh->stop = (char *)malloc(strlen(stopstring) + 1);
        -:12589:#endif
        5:12590:    strcpy(fh->stop,stopstring);
        5:12591:    }
        -:12592:
       16:12593:static int fil(ppsk pkn)
        -:12594:{
        -:12595:FILE *fp;
        -:12596:psk kns[4];
        -:12597:LONG ind;
        -:12598:int sh;
        -:12599:psk kn;
        -:12600:static filehendel *fh = NULL;
        -:12601:char *naam;
        -:12602:
        -:12603:static LONG types[]={CHR,DEC,STRt,0L};
        -:12604:static LONG whences[]={SET,CUR,END,0L};
        -:12605:static LONG modes[]={
        -:12606:O('r', 0 , 0 ),/*open text file for reading                                  */
        -:12607:O('w', 0 , 0 ),/*create text file for writing, or trucate to zero length     */
        -:12608:O('a', 0 , 0 ),/*append; open text file or create for writing at eof         */
        -:12609:O('r','b', 0 ),/*open binary file for reading                                */
        -:12610:O('w','b', 0 ),/*create binary file for writing, or trucate to zero length   */
        -:12611:O('a','b', 0 ),/*append; open binary file or create for writing at eof       */
        -:12612:O('r','+', 0 ),/*open text file for update (reading and writing)             */
        -:12613:O('w','+', 0 ),/*create text file for update, or trucate to zero length      */
        -:12614:O('a','+', 0 ),/*append; open text file or create for update, writing at eof */
        -:12615:O('r','+','b'),
        -:12616:O('r','b','+'),/*open binary file for update (reading and writing)           */
        -:12617:O('w','+','b'),
        -:12618:O('w','b','+'),/*create binary file for update, or trucate to zero length    */
        -:12619:O('a','+','b'),
        -:12620:O('a','b','+'),/*append;open binary file or create for update, writing at eof*/
        -:12621:0L};
        -:12622:
        -:12623:static LONG type,numwaarde,whence;
        -:12624:union
        -:12625:    {
        -:12626:    LONG l;
        -:12627:    char c[4];
        -:12628:    } mode;
        -:12629:
        -:12630:union
        -:12631:    {
        -:12632:    short s;
        -:12633:    char c[2];
        -:12634:    } snum;
        -:12635:
        -:12636:/*
        -:12637:Fail if there are more than four arguments or if an argument is non-atomic
        -:12638:*/
       55:12639:for(ind = 0,kn = (*pkn)->RIGHT;
       39:12640:    is_op(kn);
       23:12641:    kn = kn->RIGHT)
        -:12642:    {
       23:12643:    if(is_op(kn->LEFT) || ind > 2)
        -:12644:        {
    #####:12645:        return FALSE;
        -:12646:        }
       23:12647:    kns[ind++] = kn->LEFT;
        -:12648:    }
       16:12649:kns[ind++] = kn;
       57:12650:for(;ind < 4;)
       25:12651:    kns[ind++] = NULL;
        -:12652:
        -:12653:/*
        -:12654:  FIRST ARGUMENT: File name
        -:12655:  if the current file name is different from the argument,
        -:12656:        reset the current file name
        -:12657:  if the first argument is empty, the current file name must not be NULL
        -:12658:  fil$(name)
        -:12659:  fil$(name,...)
        -:12660:  name field is optional in all fil$ operations
        -:12661:*/
       16:12662:if(kns[0]->u.obj)
        -:12663:    {
        4:12664:    naam = (char *)POBJ(kns[0]);
        4:12665:    if(fh && strcmp(naam,fh->naam))
        -:12666:        {
    #####:12667:        fh = NULL;
        -:12668:        }
        -:12669:    }
        -:12670:else
        -:12671:    {
       12:12672:    if(fh)
       12:12673:        naam = fh->naam;
        -:12674:    else
        -:12675:        {
    #####:12676:        return FALSE;
        -:12677:        }
        -:12678:    }
        -:12679:
        -:12680:/*
        -:12681:  SECOND ARGUMENT: mode, type, whence or TEL
        -:12682:        if the second argument is a mode string,
        -:12683:                the file handel is found and adapted to the  mode
        -:12684:                or a new file handel is made
        -:12685:        else
        -:12686:                file handel is set to current naam
        -:12687:
        -:12688:        If the second argument is set, fil$ does never read or write!
        -:12689:*/
       16:12690:if(kns[1] && kns[1]->u.obj)
        -:12691:    {
        -:12692:    /*
        -:12693:    SECOND ARGUMENT:FILE MODE
        -:12694:    fil$(,"r")
        -:12695:    fil$(,"b")
        -:12696:    fil$(,"a")
        -:12697:    etc.
        -:12698:    */
       10:12699:    if((mode.l = someopt(kns[1],modes)) != 0L)
        -:12700:        {
        4:12701:        if(fh)
        3:12702:            fh = preparefp(fh,naam,mode.l);
        -:12703:        else
        1:12704:            fh = zoekfp(naam,mode.l);
        4:12705:        if(fh == NULL)
        -:12706:            {
        1:12707:            if((fh=bfopen(naam,(char *)&mode)) == NULL)
        -:12708:                {
    #####:12709:                return FALSE;
        -:12710:                }
        1:12711:	    fh->filepos = -1L;
        1:12712:            fh->mode = mode.l;
        1:12713:            fh->type = CHR;
        1:12714:            fh->size = 1;
        1:12715:            fh->getal = 1;
        1:12716:            fh->tijd = tijdnr++;
        1:12717:            fh->written = FALSE;
        1:12718:            fh->stop = NULL;
        -:12719:            }
        4:12720:        return TRUE;
        -:12721:        }
        -:12722:    else
        -:12723:        {
        -:12724:    /*
        -:12725:    We do not open a file now, so we should have a file handle in memory.
        -:12726:    */
        6:12727:        if(fh)
        6:12728:            fh = preparefp(fh,naam,0L);
        -:12729:        else
    #####:12730:            fh = zoekfp(naam,0L);
        -:12731:
        6:12732:        if(!fh)
        -:12733:            {
    #####:12734:            return FALSE;
        -:12735:            }
        -:12736:
        -:12737:    /*
        -:12738:    SECOND ARGUMENT:TYPE
        -:12739:    fil$(,CHR)
        -:12740:    fil$(,DEC)
        -:12741:    fil$(,CHR,size)
        -:12742:    fil$(,DEC,size)
        -:12743:    fil$(,CHR,size,number)
        -:12744:    fil$(,DEC,size,number)
        -:12745:    fil$(,STR)        (stop == NULL)
        -:12746:    fil$(,STR,stop)
        -:12747:    */
        6:12748:        if((type = someopt(kns[1],types)) != 0L)
        -:12749:            {
        5:12750:            fh->type = type;
        5:12751:            if(type == STRt)
        -:12752:                {
        -:12753:                /*
        -:12754:                  THIRD ARGUMENT: primary stopping character (e.g. "\n")
        -:12755:                  20081113:
        -:12756:                  An empty string "" sets stopping string to NULL,
        -:12757:                  (Changed behaviour! Previously default stop was newline!)
        -:12758:                */
        5:12759:                if(kns[2] && kns[2]->u.obj)
        -:12760:                    {
        2:12761:                    setStop(fh,(char *)&kns[2]->u.obj);
        -:12762:                    }
        -:12763:                else
        -:12764:                    {
        3:12765:                    if(fh->stop)
        -:12766:#ifdef BMALLLOC
        -:12767:                       bfree(fh->stop);
        -:12768:                    fh->stop = NULL;
        -:12769:                    /*fh->stop = (char *)bmalloc(__LINE__,2);*/
        -:12770:#else
        3:12771:                        free(fh->stop);
        3:12772:                    fh->stop = NULL;
        -:12773:                    /*fh->stop = (char *)malloc(2);*/
        -:12774:#endif
        -:12775:                    /*strcpy(fh->stop,"\n");*/
        -:12776:                    }
        -:12777:                }
        -:12778:            else
        -:12779:                {
        -:12780:                /*
        -:12781:                  THIRD ARGUMENT: a size of elements to read or write
        -:12782:                */
    #####:12783:                if(kns[2] && kns[2]->u.obj)
        -:12784:                    {
    #####:12785:                    if(!INTEGER(kns[2]))
        -:12786:                        {
    #####:12787:                        return FALSE;
        -:12788:                        }
    #####:12789:                    fh->size = toLong(kns[2]);
        -:12790:                    }
        -:12791:                else
        -:12792:                    {
    #####:12793:                    fh->size = 1;
    #####:12794:                    fh->getal = 1;
        -:12795:                    }
        -:12796:                /*
        -:12797:                  FOURTH ARGUMENT: the number of elements to read or write
        -:12798:                */
    #####:12799:                if(kns[3] && kns[3]->u.obj)
        -:12800:                    {
    #####:12801:                    if(!INTEGER(kns[3]))
        -:12802:                        {
    #####:12803:                        return FALSE;
        -:12804:                        }
    #####:12805:                    fh->getal = toLong(kns[3]);
        -:12806:                    }
        -:12807:                else
    #####:12808:                    fh->getal = 1;
        -:12809:                }
        5:12810:            return TRUE;
        -:12811:            }
        -:12812:    /*
        -:12813:    SECOND ARGUMENT:POSITIONING
        -:12814:    fil$(,SET)
        -:12815:    fil$(,END)
        -:12816:    fil$(,CUR)
        -:12817:    fil$(,SET,offset)
        -:12818:    fil$(,END,offset)
        -:12819:    fil$(,CUR,offset)
        -:12820:    */
        1:12821:        else if((whence = someopt(kns[1],whences)) != 0L)
        -:12822:            {
        -:12823:            LONG offset;
        1:12824:            fh->tijd = tijdnr++;
        -:12825:            /*
        -:12826:              THIRD ARGUMENT: an offset
        -:12827:            */
        1:12828:            if(kns[2] && kns[2]->u.obj)
        -:12829:                {
        1:12830:                if(!INTEGER(kns[2]))
        -:12831:                    {
    #####:12832:                    return FALSE;
        -:12833:                    }
        1:12834:                offset = toLong(kns[2]);
        -:12835:                }
        -:12836:            else
    #####:12837:                offset = 0L;
        -:12838:
        1:12839:            if((offset < 0L && whence == SEEK_SET)
        1:12840:            || (offset > 0L && whence == SEEK_END)
        1:12841:            || FSEEK(fh->fp,offset,whence == SET ? SEEK_SET
        1:12842:                            : whence == END ? SEEK_END
    #####:12843:                                            : SEEK_CUR))
        -:12844:                {
        -:12845:                /*sluitfile(fh);*/
        1:12846:		deallocateFilehendel(fh);
        1:12847:                fh = NULL;
        1:12848:                return FALSE;
        -:12849:                }
    #####:12850:            fh->written = FALSE;
    #####:12851:            return TRUE;
        -:12852:            }
        -:12853:    /*
        -:12854:    SECOND ARGUMENT:TELL POSITION
        -:12855:    fil$(,TEL)
        -:12856:    */
    #####:12857:        else if(PLOBJ(kns[1]) == TEL)
        -:12858:            {
        -:12859:            char pos[11];
    #####:12860:            sprintf(pos,"%ld",FTELL(fh->fp));
    #####:12861:            wis(*pkn);
    #####:12862:            *pkn = scopy((char *)pos);
    #####:12863:            return TRUE;
        -:12864:            }
        -:12865:        else
        -:12866:            {
    #####:12867:            return FALSE;
        -:12868:            }
        -:12869:        }
        -:12870:    /*
        -:12871:    return FALSE if the second argument is not empty but could not be recognised
        -:12872:    */
        -:12873:    }
        -:12874:
        6:12875:if(!fh)
        -:12876:    {
    #####:12877:    return FALSE;
        -:12878:    }
        -:12879:/*
        -:12880:READ OR WRITE
        -:12881:Now we are either going to read or to write
        -:12882:*/
        -:12883:
        6:12884:type = fh->type;
        6:12885:mode.l = fh->mode;
        6:12886:fp = fh->fp;
        -:12887:
        -:12888:/*
        -:12889:THIRD ARGUMENT: the number of elements to read or write
        -:12890:OR stop characters, depending on type (20081113)
        -:12891:*/
        -:12892:
        6:12893:if(kns[2] && kns[2]->u.obj)
        -:12894:    {
        3:12895:    if(type == STRt)
        -:12896:        {
        3:12897:        setStop(fh,(char *)&kns[2]->u.obj);
        -:12898:        }
        -:12899:    else
        -:12900:        {
    #####:12901:        if(!INTEGER(kns[2]))
        -:12902:            {
    #####:12903:            return FALSE;
        -:12904:            }
    #####:12905:        fh->getal = toLong(kns[2]);
        -:12906:        }
        -:12907:    }
        -:12908:
        -:12909:/*
        -:12910:We allow 1, 2 or 4 bytes to be read/written in one fil$ operation
        -:12911:These can be distributed over decimal numbers.
        -:12912:*/
        -:12913:
        6:12914:if(type == DEC)
        -:12915:    {
    #####:12916:    switch((int)fh->size)
        -:12917:        {
        -:12918:        case 1 :
    #####:12919:            if(fh->getal > 4)
    #####:12920:                fh->getal = 4;
    #####:12921:            break;
        -:12922:        case 2 :
    #####:12923:            if(fh->getal > 2)
    #####:12924:                fh->getal = 2;
    #####:12925:            break;
        -:12926:        default :
    #####:12927:            fh->size = 4; /*Invalid size declaration adjusted*/
    #####:12928:            fh->getal = 1;
        -:12929:        }
        -:12930:    }
        6:12931:fh->tijd = tijdnr++;
        -:12932:/*
        -:12933:FOURTH ARGUMENT:VALUE TO WRITE
        -:12934:*/
        6:12935:if(kns[3])
        -:12936:    {
        2:12937:    if(mode.c[0] != 'r' || mode.c[1] == '+' || mode.c[2] == '+')
        -:12938:/*
        -:12939:WRITE
        -:12940:*/
        -:12941:        {
        2:12942:        fh->written = TRUE;
        4:12943:        if(type == DEC)
        -:12944:            {
    #####:12945:            numwaarde = toLong(kns[3]);
    #####:12946:            for(ind=0;ind < fh->getal;ind++)
    #####:12947:                switch((int)fh->size)
        -:12948:                    {
        -:12949:                    case 1 :
    #####:12950:                        fputc((int)numwaarde & 0xFF,fh->fp);
    #####:12951:                        numwaarde >>= 8;
    #####:12952:                        break;
        -:12953:                    case 2 :
    #####:12954:                        snum.s = (short)(numwaarde & 0xFFFF);
    #####:12955:                        fwrite(snum.c,1,2,fh->fp);
    #####:12956:                        numwaarde >>= 16;
    #####:12957:                        break;
        -:12958:                    default :
    #####:12959:                        fwrite((char *)&numwaarde,1,4,fh->fp);
    #####:12960:                        break;
        -:12961:                    }
        -:12962:            }
        2:12963:        else if(type == CHR)
        -:12964:            {
        -:12965:            size_t len,len1,minl;
    #####:12966:            len1 = (size_t)(fh->size*fh->getal);
    #####:12967:            len = strlen((char *)POBJ(kns[3]));
    #####:12968:            minl = len1 < len ? (len1 > 0 ? len1 : len) : len;
    #####:12969:            if(fwrite(POBJ(kns[3]),1,minl,fh->fp) == minl)
    #####:12970:                for(;len < len1 && putc(' ',fh->fp) != EOF;len++);
        -:12971:            }
        -:12972:        else /*if(type == STRt)*/
        -:12973:            {
        2:12974:            if(  fh->stop
        2:12975:              && fh->stop[0]
        -:12976:              )/* 20081113 stop string also works when writing. */
        2:12977:                {
        2:12978:                char * s = (char *)POBJ(kns[3]);
       60:12979:                while(!strchr(fh->stop,*s))
       56:12980:                    fputc(*s++,fh->fp);
        -:12981:                }
        -:12982:            else
        -:12983:                {
    #####:12984:                fputs((char *)POBJ(kns[3]),fh->fp);
        -:12985:                }
        -:12986:            }
        -:12987:        }
        -:12988:    else
        -:12989:        {
        -:12990:        /*
        -:12991:        Fail if not in write mode
        -:12992:        */
    #####:12993:        return FALSE;
        -:12994:        }
        -:12995:    }
        -:12996:else
        -:12997:    {
        4:12998:    if(mode.c[0] == 'r' || mode.c[1] == '+' || mode.c[2] == '+')
        -:12999:        {
        -:13000:/*
        -:13001:READ
        -:13002:*/
        -:13003:#define INPUTBUFFERSIZE 256
        -:13004:        unsigned char buffer[INPUTBUFFERSIZE];
        -:13005:        unsigned char * bbuffer;/* = buffer;*/
        4:13006:        if(fh->written)
        -:13007:            {
    #####:13008:            fflush(fh->fp);
    #####:13009:            fh->written = FALSE;
        -:13010:            }
        4:13011:        if(feof(fp))
        -:13012:            {
    #####:13013:            return FALSE;
        -:13014:            }
        4:13015:        if(type == STRt)
        -:13016:            {
        4:13017:            psk lpkn = NULL;
        4:13018:            psk rpkn = NULL;
        -:13019:            char * conc[2];
        4:13020:            int count = 0;
        4:13021:            LONG pos = FTELL(fp);
        4:13022:            int kar = 0;
       69:13023:            while(  count < (INPUTBUFFERSIZE - 1)
       65:13024:                 && (kar = fgetc(fp)) != EOF
       63:13025:                 && (  !fh->stop
       63:13026:                    || !strchr(fh->stop,kar)
        -:13027:                    )
        -:13028:                 )
        -:13029:                {
       61:13030:                buffer[count++] = (char)kar;
        -:13031:                }
        4:13032:            if(count < (INPUTBUFFERSIZE - 1))
        -:13033:                {
        4:13034:                buffer[count] = '\0';
        4:13035:                bbuffer = buffer;
        -:13036:                }
        -:13037:            else
        -:13038:                {
    #####:13039:                buffer[(INPUTBUFFERSIZE - 1)] = '\0';
    #####:13040:                while(  (kar = fgetc(fp)) != EOF
    #####:13041:                     && (  !fh->stop
    #####:13042:                        || !strchr(fh->stop,kar)
        -:13043:                        )
        -:13044:                     )
    #####:13045:                    count++;
    #####:13046:                if(count >= INPUTBUFFERSIZE)
        -:13047:                    {
    #####:13048:                    bbuffer = (unsigned char *)bmalloc(__LINE__,(size_t)count+1);
    #####:13049:                    strcpy((char *)bbuffer,(char *)buffer);
    #####:13050:                    FSEEK(fp,pos+(INPUTBUFFERSIZE - 1),SEEK_SET);
    #####:13051:                    if(fread((char *)bbuffer+(INPUTBUFFERSIZE - 1),1,count - (INPUTBUFFERSIZE - 1),fh->fp) == 0)
        -:13052:                        {
    #####:13053:                        bfree(bbuffer); /* 20040226 */
    #####:13054:                        return FALSE;
        -:13055:                        }
    #####:13056:                    if(ferror(fh->fp))
        -:13057:                        {
    #####:13058:                        bfree(bbuffer); /* 20040226 */
    #####:13059:                        perror("fread");
    #####:13060:                        return FALSE;
        -:13061:                        }
    #####:13062:                    if(kar != EOF)
    #####:13063:                        fgetc(fp); /* skip stopping character (which is in 'kar') */
        -:13064:                    }
        -:13065:                else
    #####:13066:                    bbuffer = buffer;
        -:13067:                }
        4:13068:            bron = bbuffer;
        4:13069:            lpkn = input(NULL,lpkn,1,NULL/*int * err*/,NULL);
        4:13070:            if(kar == EOF)
        2:13071:                bbuffer[0] = '\0';
        -:13072:            else
        -:13073:                {
        2:13074:                bbuffer[0] = (char)kar;
        2:13075:                bbuffer[1] = '\0';
        -:13076:                }
        4:13077:            bron = bbuffer;
        4:13078:            rpkn = input(NULL,rpkn,1,NULL/*int * err*/,NULL);
        4:13079:            conc[0] = "(\1.\2)";
        4:13080:            adr[1] = lpkn;
        4:13081:            adr[2] = rpkn;
        4:13082:            conc[1] = NULL;
        4:13083:            *pkn = vopb(*pkn,(const char **)conc);
        4:13084:            wis(adr[1]);
        4:13085:            wis(adr[2]);
        -:13086:            }
        -:13087:        else
        -:13088:            {
    #####:13089:            if(fh->size * fh->getal > 255)
    #####:13090:                bbuffer = (unsigned char *)bmalloc(__LINE__,(size_t)(fh->size * fh->getal)+1);
        -:13091:                          /* +1 added 18 Maart 1997 */
        -:13092:            else
    #####:13093:                bbuffer = buffer;
    #####:13094:            if(fread((char *)bbuffer,(size_t)fh->size,(size_t)fh->getal,fh->fp) == 0
    #####:13095:            && (size_t)fh->size*(size_t)fh->getal != 0)
        -:13096:                {
    #####:13097:                return FALSE;
        -:13098:                }
    #####:13099:            if(ferror(fh->fp))
        -:13100:                {
    #####:13101:                perror("fread");
    #####:13102:                return FALSE;
        -:13103:                }
    #####:13104:            *(bbuffer+(int)(fh->size*fh->getal)) = 0;
    #####:13105:            if(type == DEC)
        -:13106:                {
    #####:13107:                numwaarde = 0L;
    #####:13108:                sh = 0;
    #####:13109:                for(ind = 0;ind < fh->getal;)
        -:13110:                    {
    #####:13111:                    switch((int)fh->size)
        -:13112:                        {
        -:13113:                        case 1 :
    #####:13114:                            numwaarde += (LONG)bbuffer[ind++] << sh;
    #####:13115:                            sh += 8;
    #####:13116:                            continue;
        -:13117:                        case 2 :
    #####:13118:                            numwaarde += (LONG)(*(short*)(bbuffer+ind)) << sh;
    #####:13119:                            ind += 2;
    #####:13120:                            sh += 16;
    #####:13121:                            continue;
        -:13122:                        default :
    #####:13123:                            numwaarde += *(LONG*)bbuffer;
    #####:13124:                            break;
        -:13125:                        }
    #####:13126:                    break;
        -:13127:                    }
    #####:13128:                sprintf((char *)bbuffer,"%ld",numwaarde);
        -:13129:                }
    #####:13130:            bron = bbuffer;
    #####:13131:            *pkn = input(NULL,*pkn,1,NULL/*int * err*/,NULL);
        -:13132:            }
        4:13133:        if(bbuffer != (unsigned char *)&buffer[0])
        -:13134:        /* buffer ---> (unsigned char *)&buffer[0]
        -:13135:           20 Dec 1995, to make Borland at ease. */
    #####:13136:            bfree(bbuffer);
        4:13137:        return TRUE;
        -:13138:        }
        -:13139:    else
        -:13140:        {
    #####:13141:        return FALSE;
        -:13142:        }
        -:13143:    }
        2:13144:return TRUE;
        -:13145:}
        -:13146:#endif
        -:13147:
      110:13148:static int allopts(psk kn,LONG opt[])
        -:13149:    {
        -:13150:    int i;
      225:13151:    while(is_op(kn))
        -:13152:        {
        -:13153:        /* return allopts(kn->LEFT,opt) && allopts(kn->RIGHT,opt);
        -:13154:        18 Maart 1997 */
       36:13155:        if(!allopts(kn->LEFT,opt))
       31:13156:            return FALSE;
        5:13157:        kn = kn->RIGHT;
        -:13158:        }
      427:13159:    for(i=0;opt[i];i++)
      396:13160:        if(PLOBJ(kn) == opt[i])
       48:13161:            return TRUE;
       31:13162:    return FALSE;
        -:13163:    }
        -:13164:
      350:13165:static int flush(void)
        -:13166:    {
        -:13167:#ifdef __GNUC__
      350:13168:    return fflush(fpo);
        -:13169:#else
        -:13170:#if _BRACMATEMBEDDED
        -:13171:    WinFlush();
        -:13172:    return 1;
        -:13173:#else
        -:13174:    return 1;
        -:13175:#endif
        -:13176:#endif
        -:13177:    }
        -:13178:
        -:13179:
      393:13180:static int output(ppsk pkn,void (*hoe)(psk k))
        -:13181:{
        -:13182:FILE *redfpo;
        -:13183:psk rknoop,rlknoop,rrknoop,rrrknoop;
        -:13184:static LONG opts[] =
        -:13185:    {APP,NEW,
        -:13186:     TXT,VAP,
        -:13187:     EXT,MEM,
        -:13188:     CON,LIN,
        -:13189:     0L};
      393:13190:if(kop(rknoop = (*pkn)->RIGHT) == KOMMA)
        -:13191:   {
       43:13192:   redfpo = fpo;
       43:13193:   rlknoop = rknoop->LEFT;
       43:13194:   rrknoop = rknoop->RIGHT;
       43:13195:   hum = !zoekopt(rrknoop,LIN);
       43:13196:   if(allopts(rrknoop,opts))
        -:13197:        {
       12:13198:        if(zoekopt(rrknoop,MEM))
        -:13199:            {
        -:13200:            psk ret;
       12:13201:            telling = 1;
       12:13202:            verwerk = tel;
       12:13203:            fpo = NULL;
       12:13204:            (*hoe)(rlknoop);
       12:13205:            ret = (psk)bmalloc(__LINE__,sizeof(unsigned LONG)+telling);
       12:13206:            ret->v.fl = READY | SUCCESS;
       12:13207:            verwerk = plak;
       12:13208:            bron = POBJ(ret);
       12:13209:            (*hoe)(rlknoop);
       12:13210:            hum = 1;
       12:13211:            verwerk = myputc;
       12:13212:            wis(*pkn);
       12:13213:            *pkn = ret;
       12:13214:            fpo = redfpo;
       12:13215:            return TRUE;
        -:13216:            }
        -:13217:        else
        -:13218:            {
    #####:13219:            (*hoe)(rlknoop);
    #####:13220:            flush();
    #####:13221:            adr[2] = rlknoop;
        -:13222:            }
        -:13223:        }
       31:13224:    else if(kop(rrknoop) == KOMMA
       31:13225:         && !is_op(rrknoop->LEFT)
       31:13226:         && allopts((rrrknoop = rrknoop->RIGHT),opts))
       31:13227:        {
       31:13228:        filehendel * fh = 
       31:13229:            myfopen((char *)POBJ(rrknoop->LEFT),
       31:13230:                    zoekopt(rrrknoop,NEW) ? "w" : "a");
       31:13231:        if(fh == NULL)
        -:13232:            {
    #####:13233:            errorprintf("cannot open %s\n",POBJ(rrknoop->LEFT));
    #####:13234:            fpo = redfpo;
    #####:13235:            hum = 1;
    #####:13236:            return FALSE;
        -:13237:            }
        -:13238:        else
        -:13239:            {
       31:13240:            fpo = fh->fp;
       31:13241:            (*hoe)(rlknoop);
       31:13242:            deallocateFilehendel(fh);
       31:13243:            fpo = redfpo;
       31:13244:            adr[2] = rlknoop;
        -:13245:            }
        -:13246:        }
        -:13247:    else
        -:13248:        {
    #####:13249:        (*hoe)(rknoop);
    #####:13250:        flush();
    #####:13251:        adr[2] = rknoop;
        -:13252:        }
       31:13253:    *pkn = dopb(*pkn,adr[2]);
        -:13254:    }
        -:13255:else
        -:13256:    {
      350:13257:    (*hoe)(rknoop);
      350:13258:    flush();
      350:13259:    *pkn = rechtertak(*pkn);
        -:13260:    }
      381:13261:hum = 1;
      381:13262:return TRUE;
        -:13263:}
        -:13264:
      439:13265:static LONG simil
        -:13266:    (const char * s1
        -:13267:    ,const char * s1end
        -:13268:    ,const char * s2
        -:13269:    ,const char * s2end
        -:13270:    ,int * putf1
        -:13271:    ,int * putf2
        -:13272:    ,LONG * plen1
        -:13273:    ,LONG * plen2
        -:13274:    )
        -:13275:    {
        -:13276:    const char * ls1;
      439:13277:    const char * s1l = NULL;
      439:13278:    const char * s1r = NULL;
      439:13279:    const char * s2l = NULL;
      439:13280:    const char * s2r = NULL;
        -:13281:    LONG max;
        -:13282:    LONG len1;
      439:13283:    LONG len2 = 0;
        -:13284:    /* beschouw elk teken van s1 als mogelijk startpunt voor match */
     1757:13285:    for(max = 0,ls1 = s1,len1 = 0
     1318:13286:       ;ls1 < s1end
      879:13287:       ;getCodePoint2(&ls1,putf1),++len1)
        -:13288:        {
        -:13289:        const char * ls2;
        -:13290:        /* vergelijk met s2 */
     1937:13291:        for(ls2 = s2,len2 = 0;ls2 < s2end;getCodePoint2(&ls2,putf2),++len2)
        -:13292:            {
     1058:13293:            const char * lls1 = ls1;
     1058:13294:            const char * lls2 = ls2;
        -:13295:            /* bepaal lengte gelijke stukken */
     1058:13296:            LONG len12 = 0;
        -:13297:            for(;;)
        -:13298:                   {
     1182:13299:                   if(lls1 < s1end)
        -:13300:                       {
     1154:13301:                       const char * ns1 = lls1,* ns2 = lls2;
     1154:13302:                       int K1 = getCodePoint2(&ns1,putf1);
     1154:13303:                       int K2 = getCodePoint2(&ns2,putf2);
     1154:13304:                       if(convertLetter(K1,u2l) == convertLetter(K2,u2l))
        -:13305:                           {
      124:13306:                           ++len12;
      124:13307:                           lls1 = ns1;
      124:13308:                           lls2 = ns2;
        -:13309:                           }
        -:13310:                       else
     1030:13311:                           break;
        -:13312:                       }
        -:13313:                   else
       28:13314:                       break;
      124:13315:                   }
        -:13316:            /* pas evt score aan */
     1058:13317:            if(len12 > max)
        -:13318:                {
       47:13319:                max = len12;
        -:13320:                /* onthou eindpunten van linkerstrings en
        -:13321:                beginpunten rechterstrings */
       47:13322:                s1l = ls1;
       47:13323:                s1r = lls1;
       47:13324:                s2l = ls2;
       47:13325:                s2r = lls2;
        -:13326:                }
        -:13327:            }
        -:13328:        }
      439:13329:    if(max)
        -:13330:        {
       46:13331:        max += simil(s1,s1l,s2,s2l,putf1,putf2,NULL,NULL) + simil(s1r,s1end,s2r,s2end,putf1,putf2,NULL,NULL);
        -:13332:        }
      439:13333:    if(plen1)
        -:13334:        {
      347:13335:        *plen1 = len1;
        -:13336:        }
      439:13337:    if(plen2)
        -:13338:        {
      347:13339:        if(len1 == 0)
        -:13340:            {
       66:13341:            for(len2 = 0;*s2;getCodePoint2(&s2,putf2),++len2)
        -:13342:                ;
        -:13343:            }
      347:13344:        *plen2 = len2;
        -:13345:        }
      439:13346:    return max;
        -:13347:    }
        -:13348:
      347:13349:static void Sim(char * klad,char * str1,char * str2)
        -:13350:    {
      347:13351:    int utf1 = 1;
      347:13352:    int utf2 = 1;
      347:13353:    LONG len1 = 0;
      347:13354:    LONG len2 = 0;
      347:13355:    LONG sim = simil(str1,str1+strlen((char *)str1),str2,str2+strlen((char *)str2),&utf1,&utf2,&len1,&len2);
      347:13356:    sprintf(klad,"%ld/%ld",(2L*(LONG)sim),len1+len2);
      347:13357:    }
        -:13358:
     5670:13359:static function_return_type find_func(psk pkn)
        -:13360:    {
     5670:13361:    psk lknoop = pkn->LEFT;
     5670:13362:    objectStuff Object = {0,0,0};
     5670:13363:    int nieuw = FALSE;
     5670:13364:    adr[1] = NULL;
        -:13365:    DBGSRC(Printf("find_func(");result(pkn);Printf(")\n");)
     5670:13366:    adr[1] = find(lknoop,&nieuw,&Object);
     5670:13367:    if(adr[1])
        -:13368:        {
     5599:13369:        if(  is_op(adr[1])
     5599:13370:          && kop(adr[1]) == DOT /*Bart 20010820*/
        -:13371:          )
        -:13372:            {
     5599:13373:            psh(&argk,pkn->RIGHT,NULL);
     5599:13374:            if(Object.self)
        -:13375:                { /* 20110505 see below */
       22:13376:                psh(&selfkn,Object.self,NULL);
        -:13377:                }
     5599:13378:            pkn = dopb(pkn,adr[1]);
     5599:13379:            if(nieuw)
       45:13380:                wis(adr[1]);
     5599:13381:            if(Object.self)
        -:13382:                {
        -:13383:                /*
        -:13384:                psh(&selfkn,self,NULL); 20110505. Must precede dopb(...).
        -:13385:                Example where this is relevant:
        -:13386:
        -:13387:                {?} ((==.lst$its).)'
        -:13388:                (its=
        -:13389:                =.lst$its);
        -:13390:                {!} its
        -:13391:
        -:13392:                */
       22:13393:                if(Object.object)
        -:13394:                    {
        3:13395:                    psh(&Selfkn,Object.object,NULL);
        3:13396:                    if(kop(pkn) == DOT)
        -:13397:                        {
        3:13398:                        psh(pkn->LEFT,&nulk,NULL);
        3:13399:                        pkn = eval(pkn);
        3:13400:                        pop(pkn->LEFT);
        3:13401:                        pkn = dopb(pkn,pkn->RIGHT);
        -:13402:                        }
        3:13403:                    deleteNode(&argk);
        3:13404:                    deleteNode(&selfkn);
        3:13405:                    deleteNode(&Selfkn);
        3:13406:                    return functionOk(pkn);
        -:13407:                    }
        -:13408:                else
        -:13409:                    {
       19:13410:                    if(kop(pkn) == DOT)
        -:13411:                        {
       19:13412:                        psh(pkn->LEFT,&nulk,NULL);
       19:13413:                        pkn = eval(pkn);
       19:13414:                        pop(pkn->LEFT);
       19:13415:                        pkn = dopb(pkn,pkn->RIGHT);
        -:13416:                        }
       19:13417:                    deleteNode(&argk);
       19:13418:                    deleteNode(&selfkn);
       19:13419:                    return functionOk(pkn);
        -:13420:                    }
        -:13421:                }
        -:13422:            else
        -:13423:                {
     5577:13424:                if(kop(pkn) == DOT)
        -:13425:                    {
     5577:13426:                    psh(pkn->LEFT,&nulk,NULL);
     5577:13427:                    pkn = eval(pkn);
     5577:13428:                    pop(pkn->LEFT);
     5577:13429:                    pkn = dopb(pkn,pkn->RIGHT);
        -:13430:                    }
     5577:13431:                deleteNode(&argk);
     5577:13432:                return functionOk(pkn);
        -:13433:                }
        -:13434:            }
        -:13435:        else
        -:13436:            {
        -:13437:#if defined NO_EXIT_ON_NON_SEVERE_ERRORS
        -:13438:            return functionFail(pkn);
        -:13439:#else
    #####:13440:            errorprintf("(Syntax error) The following is not a function:\n\n  ");
    #####:13441:            writeError(lknoop);
    #####:13442:            exit(116);
        -:13443:#endif
        -:13444:            }
        -:13445:        }
       71:13446:    else if(Object.theMethod)
        -:13447:        {
        -:13448:        DBGSRC(printf("Object.theMethod\n");)
       24:13449:        if(Object.theMethod((struct typedObjectknoop *)Object.object,&pkn))
        -:13450:            {
        -:13451:            DBGSRC(printf("functionOk");result(pkn);printf("\n");)
       22:13452:            return functionOk(pkn);
        -:13453:            }
        -:13454:        }
       47:13455:    else if (  (kop(pkn->LEFT) == FUU)
       32:13456:            && (pkn->LEFT->v.fl & BREUK)
       32:13457:            && (kop(pkn->LEFT->RIGHT) == DOT)
       32:13458:            && (!is_op(pkn->LEFT->RIGHT->LEFT))
        -:13459:            )
        -:13460:        {
        -:13461:        psk rknoop;
       32:13462:        rknoop = lambda(pkn->LEFT->RIGHT->RIGHT,pkn->LEFT->RIGHT->LEFT,pkn->RIGHT);
       32:13463:        if(rknoop)
        -:13464:            {
       31:13465:            wis(pkn);
       31:13466:            pkn = rknoop;
        -:13467:            }
        -:13468:        else
        -:13469:            {
        1:13470:            psk npkn = subboomcopie(pkn->LEFT->RIGHT->RIGHT); /*20111207*/
        1:13471:            wis(pkn);
        1:13472:            pkn = npkn;
        1:13473:            if(!is_op(pkn) && !(pkn->v.fl & INDIRECT))
    #####:13474:                pkn->v.fl |= READY;
        -:13475:            }
       32:13476:        return functionOk(pkn);
        -:13477:        }
        -:13478:    else
        -:13479:        {
        -:13480:        DBGSRC(errorprintf("Function not found");writeError(pkn);\
        -:13481:            Printf("\n");)
        -:13482:        }
       17:13483:    return functionFail(pkn);
        -:13484:    }
        -:13485:
       26:13486:static int hasSubObject(psk src)
        -:13487:    {
       52:13488:    while(is_op(src))
        -:13489:        {
       26:13490:        if(kop(src) == WORDT)
       13:13491:            return TRUE;
        -:13492:        else
        -:13493:            {
        -:13494:            /*return hasSubObject(src->LEFT) || hasSubObject(src->RIGHT);
        -:13495:            18 Maart 1997*/
       13:13496:            if(hasSubObject(src->LEFT))
       13:13497:                return TRUE;
    #####:13498:            src = src->RIGHT;
        -:13499:            }
        -:13500:        }
    #####:13501:    return FALSE;
        -:13502:    }
        -:13503:
        -:13504:static psk objectcopiesub(psk src);
        -:13505:
       13:13506:static psk objectcopiesub2(psk src) /* src is NOT an object */
        -:13507:    {
        -:13508:    psk goal;
       13:13509:    if(is_op(src) && hasSubObject(src))
        -:13510:        {
       13:13511:        goal = (psk)bmalloc(__LINE__,sizeof(kknoop));
       13:13512:        goal->ops = src->ops & ~ALL_REFCOUNT_BITS_SET;
       13:13513:        goal->LEFT = objectcopiesub(src->LEFT);
       13:13514:        goal->RIGHT = objectcopiesub(src->RIGHT);
       13:13515:        return goal;
        -:13516:        }
        -:13517:    else
    #####:13518:        return zelfde_als_w(src);
        -:13519:    }
        -:13520:
       29:13521:static psk objectcopiesub(psk src)
        -:13522:    {
        -:13523:    psk goal;
       29:13524:    if(is_object(src))
        -:13525:        {
       20:13526:        if(ISBUILTIN((objectknoop*)src))
        -:13527:            {
    #####:13528:            return zelfde_als_w(src);
        -:13529:            /*
        -:13530:            goal = (psk)bmalloc(__LINE__,sizeof(typedObjectknoop));
        -:13531:#ifdef BUILTIN
        -:13532:            ((typedObjectknoop*)goal)->u.Int = BUILTIN;
        -:13533:#else
        -:13534:            ((typedObjectknoop*)goal)->refcount = 0;
        -:13535:            UNSETCREATEDWITHNEW((typedObjectknoop*)goal);/ *TODO: This line seems to be superfluous* /
        -:13536:            SETBUILTIN((typedObjectknoop*)goal);
        -:13537:#endif
        -:13538:            ((typedObjectknoop*)goal)->vtab = ((typedObjectknoop*)src)->vtab;
        -:13539:            ((typedObjectknoop*)goal)->voiddata = NULL;
        -:13540:            */
        -:13541:            }
        -:13542:        else
        -:13543:            {
       20:13544:            goal = (psk)bmalloc(__LINE__,sizeof(objectknoop));
        -:13545:#ifdef BUILTIN
       20:13546:            ((typedObjectknoop*)goal)->u.Int = 0;
        -:13547:#else
        -:13548:            ((typedObjectknoop*)goal)->refcount = 0;
        -:13549:            UNSETBUILTIN((typedObjectknoop*)goal);
        -:13550:#endif
        -:13551:            }
        -:13552:#ifndef BUILTIN
        -:13553:        UNSETCREATEDWITHNEW((typedObjectknoop*)goal);
        -:13554:#endif
       20:13555:        goal->ops = src->ops & ~ALL_REFCOUNT_BITS_SET;
       20:13556:        goal->LEFT = zelfde_als_w(src->LEFT);
       20:13557:        goal->RIGHT = zelfde_als_w(src->RIGHT);
       20:13558:        return goal;
        -:13559:        }
        -:13560:    else
        9:13561:        return objectcopiesub2(src);
        -:13562:    }
        -:13563:
        7:13564:static psk objectcopie(psk src)
        -:13565:    {
        -:13566:    psk goal;
        7:13567:    if(is_object(src))                              /* Make a copy of this '=' node ... */
        -:13568:        {
        3:13569:        if(ISBUILTIN((objectknoop*)src))
        -:13570:            {
    #####:13571:            goal = (psk)bmalloc(__LINE__,sizeof(typedObjectknoop));
        -:13572:#ifdef BUILTIN
    #####:13573:            ((typedObjectknoop*)goal)->u.Int = BUILTIN;
        -:13574:#else
        -:13575:            ((typedObjectknoop*)goal)->refcount = 0;
        -:13576:            UNSETCREATEDWITHNEW((typedObjectknoop*)goal);/*TODO: This line seems to be superfluous*/
        -:13577:            SETBUILTIN((typedObjectknoop*)goal);
        -:13578:#endif
    #####:13579:            ((typedObjectknoop*)goal)->vtab = ((typedObjectknoop*)src)->vtab;
    #####:13580:            ((typedObjectknoop*)goal)->voiddata = NULL;
        -:13581:            }
        -:13582:        else
        -:13583:            {
        3:13584:            goal = (psk)bmalloc(__LINE__,sizeof(objectknoop));
        -:13585:#ifdef BUILTIN
        3:13586:            ((typedObjectknoop*)goal)->u.Int = 0;
        -:13587:#else
        -:13588:            ((typedObjectknoop*)goal)->refcount = 0;
        -:13589:            UNSETBUILTIN((typedObjectknoop*)goal);
        -:13590:#endif
        -:13591:            }
        -:13592:#ifndef BUILTIN
        -:13593:        UNSETCREATEDWITHNEW((typedObjectknoop*)goal);
        -:13594:#endif
        3:13595:        goal->ops = src->ops & ~ALL_REFCOUNT_BITS_SET;
        3:13596:        goal->LEFT = zelfde_als_w(src->LEFT);
        -:13597:        /*?? This adds an extra level of copying, but ONLY for objects that have a '=' node as the lhs of the main '=' node*/
        -:13598:        /* What is it good for? Bart 20010220 */
        3:13599:        goal->RIGHT = objectcopiesub(src->RIGHT); /* and of all '=' child nodes (but not of grandchildren!) */
        3:13600:        return goal;
        -:13601:        }
        -:13602:    else
        4:13603:        return objectcopiesub2(src);/*zelfde_als_w(src);*/
        -:13604:    }
        -:13605:
       16:13606:static psk getObjectDef(psk source)
        -:13607:    {
        -:13608:    psk def;
        -:13609:    typedObjectknoop * dest;
       16:13610:    if(!is_op(source))
        -:13611:        {
       10:13612:        classdef * df = classes;
        -:13613:        /*Printf("built-in?\n");*/
       10:13614:        for(;df->name && strcmp(df->name,(char *)POBJ(source));++df)
        -:13615:            ;
       10:13616:        if(df->vtab)
        -:13617:            {
        7:13618:            dest = (typedObjectknoop *)bmalloc(__LINE__,sizeof(typedObjectknoop));
        7:13619:            dest->v.fl = WORDT | SUCCESS;
        7:13620:            dest->links = zelfde_als_w(&nilk);
        -:13621:            /*dest->rechts = zelfde_als_w(&nilk);*/
        7:13622:            dest->rechts = zelfde_als_w(source);
        -:13623:#ifdef BUILTIN
        7:13624:            dest->u.Int = BUILTIN;
        -:13625:#else
        -:13626:            dest->refcount = 0;
        -:13627:            SETBUILTIN(dest);
        -:13628:#endif
        7:13629:            VOID(dest) = NULL;
        7:13630:            dest->vtab = df->vtab;
        7:13631:            return (psk)dest;
        -:13632:            }
        -:13633:        }
        6:13634:    else if(kop(source) == WORDT)
        -:13635:        {
        3:13636:        source->RIGHT = Head(source->RIGHT);
        3:13637:        return objectcopie(source);
        -:13638:        }
        -:13639:
        -:13640:
        -:13641:
        6:13642:    if((def = Naamwoord_w(source,source->v.fl & DOUBLY_INDIRECT)) != NULL)
        -:13643:        {
        4:13644:        dest = (typedObjectknoop *)bmalloc(__LINE__,sizeof(typedObjectknoop));
        4:13645:        dest->v.fl = WORDT | SUCCESS;
        -:13646:        /*dest->v.fl ^= Flgs;*/
        4:13647:        dest->links = zelfde_als_w(&nilk);
        -:13648:/*Bart 20010507        dest->rechts = def;*/
        -:13649:        /*Printf("def:");
        -:13650:        result(def);
        -:13651:        Printf("\n");*/
        4:13652:        dest->rechts = objectcopie(def); /* TODO Head(&def) ? */
        4:13653:        wis(def);
        -:13654:#ifdef BUILTIN
        4:13655:        dest->u.Int = 0;
        -:13656:#else
        -:13657:        dest->refcount = 0;
        -:13658:        UNSETBUILTIN(dest);
        -:13659:#endif
        4:13660:        VOID(dest) = NULL;
        4:13661:        dest->vtab = NULL;
        4:13662:        return (psk)dest;
        -:13663:        }
        2:13664:    return NULL;
        -:13665:    }
        -:13666:
   197622:13667:static psk changeCase(psk pkn
        -:13668:#if CODEPAGE850
        -:13669:                      ,int dos
        -:13670:#endif
        -:13671:                      ,int low)
        -:13672:    {
        -:13673:    const char * s;
        -:13674:    psk kn;
        -:13675:    size_t len;
   197622:13676:    kn = zelfde_als_w(pkn);
   197622:13677:    s = SPOBJ(pkn);
   197622:13678:    len = strlen((const char *)s);
   197622:13679:    if(len > 0)
        -:13680:        {
        -:13681:        char * d;
        -:13682:        char * dwarn;
   197622:13683:        char * buf = NULL;
        -:13684:        char * obuf;
   197622:13685:        kn = prive(kn);
   197622:13686:        d = SPOBJ(kn);
   197622:13687:        obuf = d;
   197622:13688:        dwarn = obuf + strlen((const char*)obuf) - 6;
        -:13689:#if CODEPAGE850
        -:13690:        if(dos)
        -:13691:            {
        -:13692:            if(low)
        -:13693:                {
        -:13694:                for(;*s;++s)
        -:13695:                    {
        -:13696:                    *s = ISO8859toCodePage850(lowerEquivalent[(int)(const unsigned char)*s]);
        -:13697:                    }
        -:13698:                }
        -:13699:            else
        -:13700:                {
        -:13701:                for(;*s;++s)
        -:13702:                    {
        -:13703:                    *s = ISO8859toCodePage850(upperEquivalent[(int)(const unsigned char)*s]);
        -:13704:                    }
        -:13705:                }
        -:13706:            }
        -:13707:        else
        -:13708:#endif
        -:13709:            {
   197622:13710:            int isutf = 1;
   197622:13711:            struct ccaseconv * t = low ? u2l : l2u;
   600644:13712:            for(;*s;)
        -:13713:                {
   205400:13714:                int S = getCodePoint2(&s,&isutf);
   205400:13715:                int D = convertLetter(S,t);
   205400:13716:                if(isutf)
        -:13717:                    {
   205400:13718:                    if(d >= dwarn)
        -:13719:                        {
   197628:13720:                        int nb = utf8bytes(D);
   197628:13721:                        if(d + nb >= dwarn+6)
        -:13722:                            {
        -:13723:                            /* overrun */
   197572:13724:                            buf = (char *)bmalloc(__LINE__,2*((dwarn+6) - obuf));
   197572:13725:                            dwarn = buf + 2*((dwarn+6) - obuf) - 6;
   197572:13726:                            memcpy(buf,obuf,d - obuf);
   197572:13727:                            d = buf + (d - obuf);
   197572:13728:                            if(obuf != SPOBJ(kn))
    #####:13729:                                bfree(obuf);
   197572:13730:                            obuf = buf;
        -:13731:                            }
        -:13732:                        }
   205400:13733:                    d = putCodePoint(D,d);
        -:13734:                    }
        -:13735:                else
    #####:13736:                    *d++ = (unsigned char)D;
        -:13737:                }
   197622:13738:            *d = 0;
   197622:13739:            if(buf)
        -:13740:                {
   197572:13741:                wis(kn);
   197572:13742:                kn = scopy(buf);
   197572:13743:                bfree(buf);
        -:13744:                }
        -:13745:            }
        -:13746:        }
   197622:13747:    return kn;
        -:13748:    }
        -:13749:
        -:13750:#if !defined NO_C_INTERFACE
        4:13751:static void * strToPointer(const char * str)
        -:13752:    {
        4:13753:    size_t res = 0;
       44:13754:    while(*str)
       36:13755:        res = 10*res+(*str++ - '0');
        4:13756:    return (void *)res;
        -:13757:    }
        -:13758:
        2:13759:static void pointerToStr(char * pc,void * p)
        -:13760:    {
        2:13761:    size_t P = (size_t)p;
        2:13762:    char * PC = pc;
       22:13763:    while(P)
        -:13764:        {
       18:13765:        *pc++ = (char)((P % 10) + '0');
       18:13766:        P /= 10;
        -:13767:        }
        2:13768:    *pc-- = '\0';
       12:13769:    while(PC < pc)
        -:13770:        {
        8:13771:        char sav = *PC;
        8:13772:        *PC = *pc;
        8:13773:        *pc = sav;
        8:13774:        ++PC;
        8:13775:        --pc;
        -:13776:        }
        2:13777:    }
        -:13778:#endif
        -:13779:
        -:13780:#if O_S
        -:13781:static function_return_type swi(ppsk pkn,psk rlknoop,psk rrknoop)
        -:13782:    {
        -:13783:    int i;
        -:13784:    union
        -:13785:        {
        -:13786:        unsigned int i[sizeof(os_regset) + 1];
        -:13787:        struct
        -:13788:            {
        -:13789:            int swicode;
        -:13790:            os_regset regs;
        -:13791:            } s;
        -:13792:        } u;
        -:13793:    char pc[121];
        -:13794:    for(i = 0;i < sizeof(os_regset)/sizeof(int);i++)
        -:13795:        u.s.regs.r[i] = 0;
        -:13796:    rrknoop = *pkn;
        -:13797:    i=0;
        -:13798:    do
        -:13799:        {
        -:13800:        rrknoop = rrknoop->RIGHT;
        -:13801:        rlknoop = is_op(rrknoop) ? rrknoop->LEFT : rrknoop;
        -:13802:        if(is_op(rlknoop) || !INTEGER_NIET_NEG(rlknoop))
        -:13803:            return function_fail;
        -:13804:        u.i[i++] = (unsigned int)
        -:13805:            strtoul((char *)POBJ(rlknoop),(char **)NULL,10);
        -:13806:        }
        -:13807:    while(is_op(rrknoop) && i < 10);
        -:13808:#ifdef __TURBOC__
        -:13809:    intr(u.s.swicode,(struct REGPACK *)&u.s.regs);
        -:13810:    sprintf(pc,"0.%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
        -:13811:        u.i[1],u.i[2],u.i[3],u.i[4],u.i[5],
        -:13812:        u.i[6],u.i[7],u.i[8],u.i[9],u.i[10]);
        -:13813:#else
        -:13814:#if defined ARM
        -:13815:    i = (int)os_swix(u.s.swicode,&u.s.regs);
        -:13816:    sprintf(pc,"%u.%u,%u,%u,%u,%u,%u,%u,%u,%u,%u",
        -:13817:        i,
        -:13818:        u.i[1],u.i[2],u.i[3],u.i[4],u.i[5],
        -:13819:        u.i[6],u.i[7],u.i[8],u.i[9],u.i[10]);
        -:13820:#endif
        -:13821:#endif
        -:13822:    *pkn = opb(*pkn,pc,NULL);
        -:13823:    return functionOk(*pkn);
        -:13824:    }
        -:13825:#endif
        -:13826:
        1:13827:static void stringreverse(char * a,size_t len) /*Bart 20070220 int -> size_t*/
        -:13828:    {
        -:13829:    char * b;
        1:13830:    b = a + len;
        3:13831:    while(a < --b)
        -:13832:        {
        1:13833:        char c = *a;
        1:13834:        *a = *b;
        1:13835:        *b = c;
        1:13836:        ++a;
        -:13837:        }
        1:13838:    }
        -:13839:
        9:13840:static void print_clock(char * pklad,clock_t time)
        -:13841:    {
        9:13842:    if(time == -1)
    #####:13843:        sprintf(pklad,"-1");
        -:13844:    else
        -:13845:#if defined __TURBOC__ && !defined __BORLANDC__
        -:13846:        sprintf(pklad,"%0lu/%lu",(unsigned LONG)time,(unsigned LONG)(10.0*CLOCKS_PER_SEC));/* CLOCKS_PER_SEC == 18.2 */
        -:13847:#else
        9:13848:        sprintf(pklad,"%0ld/%ld",(LONG )time,(LONG)CLOCKS_PER_SEC);
        -:13849:#endif
        9:13850:    }
        -:13851:
        -:13852:#define LONGCASE
        -:13853:
        -:13854:#ifdef LONGCASE
        -:13855:#define SWITCH(v) switch(v)
        -:13856:#define FIRSTCASE(a) case a :
        -:13857:#define CASE(a) case a :
        -:13858:#define DEFAULT default :
        -:13859:#else
        -:13860:#define SWITCH(v) LONG lob;lob = v;
        -:13861:#define FIRSTCASE(a) if(lob == a)
        -:13862:#define CASE(a) else if(lob == a)
        -:13863:#define DEFAULT else
        -:13864:#endif
        -:13865:
        -:13866:
   279033:13867:static function_return_type functies(psk pkn)
        -:13868:    {
        -:13869:    static char klad[22];
        -:13870:    psk lknoop,rknoop,rrknoop,rlknoop;
        -:13871:    int intVal;
   279033:13872:    if(is_op(lknoop = pkn->LEFT))
      115:13873:        return find_func(pkn);
        -:13874:        /*return functionOk(*pkn);*/
   278918:13875:    rknoop = pkn->RIGHT;
        -:13876:    {
   278918:13877:    SWITCH(PLOBJ(lknoop))
        -:13878:        {
        -:13879:        FIRSTCASE(STR) /* str$(arg arg arg .. ..) */
        -:13880:            {
     2185:13881:            mooi = FALSE;
     2185:13882:            hum = 0;/* 15 Dec 1995 */
     2185:13883:            telling = 1;
     2185:13884:            verwerk = tstr;
     2185:13885:            result(rknoop);
     2185:13886:            rlknoop = (psk)bmalloc(__LINE__,sizeof(unsigned LONG)+telling);
     2185:13887:            verwerk = pstr;
     2185:13888:            bron = POBJ(rlknoop);
     2185:13889:            result(rknoop);
     2185:13890:            rlknoop->v.fl = (READY|SUCCESS) | (numbercheck(SPOBJ(rlknoop),NULL) & ~DEFINITELYNONUMBER);
     2185:13891:            mooi = TRUE;
     2185:13892:            hum = 1;/* 15 Dec 1995 */
     2185:13893:            verwerk = myputc;
     2185:13894:            wis(pkn);
     2185:13895:            pkn = rlknoop;
     2185:13896:            return functionOk(pkn);
        -:13897:            }
        -:13898:#if O_S
        -:13899:        CASE(SWI) /* swi$(<interrupt number>.(input regs)) */
        -:13900:            {
        -:13901:            swi(pkn,rlknoop,rrknoop);
        -:13902:            }
        -:13903:#endif
        -:13904:
        -:13905:#ifdef ERR
        -:13906:/*#if !_BRACMATEMBEDDED*/
        -:13907:        CASE(ERR) /* err $ <file name to direct errorStream to> */
        -:13908:            {
    #####:13909:            if(!is_op(rknoop))
        -:13910:                {
    #####:13911:                if(redirectError((char *)POBJ(rknoop)))
    #####:13912:                    return functionOk(pkn);
        -:13913:                }
    #####:13914:            return functionFail(pkn);
        -:13915:            }
        -:13916:/*#endif*/
        -:13917:#endif
        -:13918:#if !defined NO_C_INTERFACE
        -:13919:        CASE(ALC)  /* alc $ <number of bytes> */
        -:13920:            {
        -:13921:            void *p;
        4:13922:            if(is_op(rknoop)
        4:13923:            || !INTEGER_POS(rknoop)
        2:13924:            || (p = bmalloc(__LINE__,(int)strtoul((char *)POBJ(rknoop),(char **)NULL,10)))
        -:13925:                  == NULL)
        2:13926:                return functionFail(pkn);
        2:13927:            pointerToStr(klad,p);
        2:13928:            wis(pkn);
        2:13929:            pkn = scopy((char *)klad);
        2:13930:            return functionOk(pkn);
        -:13931:            }
        -:13932:        CASE(FRE) /* fre $ <pointer> */
        -:13933:            {
        -:13934:            void * p;
        2:13935:            if(is_op(rknoop) || !INTEGER_POS(rknoop))
    #####:13936:                return functionFail(pkn);
        2:13937:            p = strToPointer((char *)POBJ(rknoop));
        2:13938:            pskfree((psk)p);
        2:13939:            return functionOk(pkn);
        -:13940:            }
        -:13941:        CASE(PEE) /* pee $ (<pointer>[,<number of bytes>]) (1,2,4,8)*/
        -:13942:            {
        -:13943:            void *p;
        1:13944:            intVal = 1;
        1:13945:            if(is_op(rknoop))
        -:13946:                {
        1:13947:                rlknoop = rknoop->LEFT;
        1:13948:                rrknoop = rknoop->RIGHT;
        1:13949:                if(!is_op(rrknoop))
        1:13950:                    switch(rrknoop->u.obj)
        -:13951:                        {
        -:13952:                        case '2':
        1:13953:                            intVal = 2;
        1:13954:                            break;
        -:13955:                        case '4':
    #####:13956:                            intVal = 4;
    #####:13957:                            break;
        -:13958:                        }
        -:13959:                }
        -:13960:            else
    #####:13961:                rlknoop = rknoop;
        1:13962:            if(is_op(rlknoop) || !INTEGER_POS(rlknoop))
    #####:13963:                return functionFail(pkn);
        1:13964:            p = strToPointer((char *)POBJ(rlknoop));
        1:13965:            p = (void*)((char *)p - (ptrdiff_t)((size_t)p % intVal));
        1:13966:            switch(intVal)
        -:13967:                {
        -:13968:                case 2:
        1:13969:                    sprintf(klad,"%hu",*(short unsigned int*)p);
        1:13970:                    break;
        -:13971:                case 4:
    #####:13972:                    sprintf(klad,"%lu",(unsigned long)*(UINT32_T*)p);
    #####:13973:                    break;
        -:13974:                case 8:
    #####:13975:                    sprintf(klad,"%llu",*(unsigned long long*)p);
    #####:13976:                    break;
        -:13977:                case 1:
        -:13978:                default:
    #####:13979:                    sprintf(klad,"%u",(int)*(unsigned char *)p);
    #####:13980:                    break;
        -:13981:                }
        1:13982:            wis(pkn);
        1:13983:            pkn = scopy((char *)klad);
        1:13984:            return functionOk(pkn);
        -:13985:            }
        -:13986:        CASE(POK) /* pok $ (<pointer>,<number>[,<number of bytes>]) */
        -:13987:            {
        -:13988:            psk rrlknoop;
        -:13989:            void *p;
        -:13990:            LONG val;
        1:13991:            intVal = 1;
        1:13992:            if(!is_op(rknoop))
    #####:13993:                return functionFail(pkn);
        1:13994:            rlknoop = rknoop->LEFT;
        1:13995:            rrknoop = rknoop->RIGHT;
        1:13996:            if(is_op(rrknoop))
        -:13997:                {
        -:13998:                psk rrrknoop;
        1:13999:                rrrknoop = rrknoop->RIGHT;
        1:14000:                rrlknoop = rrknoop->LEFT;
        1:14001:                if(!is_op(rrrknoop))
        1:14002:                    switch(rrrknoop->u.obj)
        -:14003:                        {
        -:14004:                        case '2':
        1:14005:                            intVal = 2;
        1:14006:                            break;
        -:14007:                        case '4':
    #####:14008:                            intVal = 4;
    #####:14009:                            break;
        -:14010:                        case '8':
    #####:14011:                            intVal = 8;
    #####:14012:                            break;
        -:14013:                        default:
        -:14014:                            ;
        -:14015:                        }
        -:14016:                }
        -:14017:            else
    #####:14018:                rrlknoop = rrknoop;
        1:14019:            if(is_op(rlknoop) || !INTEGER_POS(rlknoop)
        1:14020:            || is_op(rrlknoop) || !INTEGER(rrlknoop))
    #####:14021:                return functionFail(pkn);
        1:14022:            p = strToPointer((char *)POBJ(rlknoop));
        1:14023:            p = (void*)((char *)p - (ptrdiff_t)((size_t)p % intVal));
        1:14024:            val = toLong(rrlknoop);
        1:14025:            switch(intVal)
        -:14026:                {
        -:14027:                case 2:
        1:14028:                    *(unsigned short int*)p = (unsigned short int)val;
        1:14029:                    break;
        -:14030:                case 4:
    #####:14031:                    *(UINT32_T*)p = (UINT32_T)val;
    #####:14032:                    break;
        -:14033:                case 8:
    #####:14034:                    *(unsigned LONG*)p = (unsigned LONG)val;
    #####:14035:                    break;
        -:14036:                case 1:
        -:14037:                default:
    #####:14038:                    *(unsigned char *)p = (unsigned char)val;
    #####:14039:                    break;
        -:14040:                }
        1:14041:            return functionOk(pkn);
        -:14042:            }
        -:14043:        CASE(FNC) /* fnc $ (<function pointer>.<struct pointer>) */
        -:14044:            {
        -:14045:            typedef Boolean (*fncTp)(void *);
        -:14046:            union
        -:14047:                {
        -:14048:                fncTp pfnc; /* Hoping this works. */
        -:14049:                void * vp;  /* Pointers to data and pointers to functions may
        -:14050:                               have different sizes. */
        -:14051:                } u;
        -:14052:            /*fncTp pfnc;*/
        -:14053:            void * argStruct;
    #####:14054:            if(sizeof(int (*)(void *)) != sizeof(void *) || !is_op(rknoop))
    #####:14055:                return functionFail(pkn);
    #####:14056:            u.vp = strToPointer((char *)POBJ(rknoop->LEFT));
        -:14057:            /*20031126 pfnc = (fncTp)strtoul((char *)POBJ(rknoop->LEFT),(char **)NULL,10);*/
    #####:14058:            if(!u.pfnc)
    #####:14059:                return functionFail(pkn);
    #####:14060:            argStruct = strToPointer((char *)POBJ(rknoop->RIGHT));
        -:14061:            /*20031126 argStruct = (void *)strtoul((char *)POBJ(rknoop->RIGHT),(char **)NULL,10);*/
    #####:14062:            return u.pfnc(argStruct) ? functionOk(pkn) : functionFail(pkn);
        -:14063:            }
        -:14064:#endif
        -:14065:        CASE(X2D) /* x2d $ hexnumber */
        -:14066:            {
        -:14067:            char * endptr;
        -:14068:            unsigned LONG val;
       32:14069:            if(  is_op(rknoop)
       32:14070:              || HAS_VISIBLE_FLAGS_OR_MINUS(rknoop)
        -:14071:              )
        1:14072:                return functionFail(pkn);
       31:14073:            errno = 0;
       31:14074:            val = STRTOUL((char *)POBJ(rknoop),&endptr,16);
       31:14075:            if(errno == ERANGE || (endptr && *endptr))
        3:14076:                return functionFail(pkn); /*not all characters scanned*/
       28:14077:            sprintf(klad,"%lu",val);
       28:14078:            wis(pkn);
       28:14079:            pkn = scopy((char *)klad);
       28:14080:            return functionOk(pkn);
        -:14081:            }
        -:14082:        CASE(D2X) /* d2x $ decimalnumber */
        -:14083:            {
        -:14084:            char * endptr;
        -:14085:            unsigned LONG val;
       12:14086:            if(is_op(rknoop) || !INTEGER_NIET_NEG(rknoop))
        5:14087:                return functionFail(pkn);
        -:14088:#ifdef __BORLANDC__
        -:14089:            if(  strlen((char *)POBJ(rknoop)) > 10
        -:14090:              ||    strlen((char *)POBJ(rknoop)) == 10
        -:14091:                 && strcmp((char *)POBJ(rknoop),"4294967295") > 0
        -:14092:              )
        -:14093:                return functionFail(pkn); /*not all characters scanned*/
        -:14094:#endif
        7:14095:            errno = 0;
        7:14096:            val = STRTOUL((char *)POBJ(rknoop),&endptr,10);
        7:14097:            if(  errno == ERANGE
        5:14098:              || (endptr && *endptr)
        -:14099:              )
        2:14100:                return functionFail(pkn); /*not all characters scanned*/
        5:14101:            sprintf(klad,"%lX",val);
        5:14102:            wis(pkn);
        5:14103:            pkn = scopy((char *)klad);
        5:14104:            return functionOk(pkn);
        -:14105:            }
        -:14106:        CASE(KAR) /* chr $ getal */
        -:14107:            {
       44:14108:            if(is_op(rknoop) || !INTEGER_POS(rknoop))
        2:14109:                return functionFail(pkn);
       42:14110:            intVal = strtoul((char *)POBJ(rknoop),(char **)NULL,10);
       42:14111:            if(intVal > 255)
        1:14112:                return functionFail(pkn);
       41:14113:            klad[0] = (char)intVal;
       41:14114:            klad[1] = 0;
       41:14115:            wis(pkn);
       41:14116:            pkn = scopy((char *)klad);
       41:14117:            return functionOk(pkn);
        -:14118:            }
        -:14119:        CASE(KAU) /* chu $ number */
        -:14120:            {
        -:14121:            unsigned LONG val;
    65573:14122:            if(is_op(rknoop) || !INTEGER_POS(rknoop))
        2:14123:                return functionFail(pkn);
    65571:14124:            val = STRTOUL((char *)POBJ(rknoop),(char **)NULL,10);
    65571:14125:            if(putCodePoint(val,(char *)klad) == NULL)
        2:14126:                return functionFail(pkn);
    65569:14127:            wis(pkn);
    65569:14128:            pkn = scopy((char *)klad);
    65569:14129:            return functionOk(pkn);
        -:14130:            }
        -:14131:        CASE(ASC) /* asc $ character */
        -:14132:            {
        -:14133:            /*char pc[4];*/
       29:14134:            if(is_op(rknoop))
        1:14135:                return functionFail(pkn);
       28:14136:            sprintf(klad,"%d",(int)rknoop->u.obj);
       28:14137:            wis(pkn);
       28:14138:            pkn = scopy((char *)klad);
       28:14139:            return functionOk(pkn);
        -:14140:            }
        -:14141:        CASE(UTF)
        -:14142:            {
        -:14143:/*
        -:14144:@(abc√¶def:? (%@>"~" ?:?a & utf$!a) ?)
        -:14145:@(str$(abc chu$200 def):? (%@>"~" ?:?a & utf$!a) ?)
        -:14146:*/
       97:14147:            if(is_op(rknoop))
        -:14148:                {
        1:14149:                pkn->v.fl |= FENCE;
        1:14150:                return functionFail(pkn);
        -:14151:                }
        -:14152:            else
        -:14153:                {
       96:14154:                const char * s = (const char *)POBJ(rknoop);
       96:14155:                intVal = getCodePoint(&s);
       96:14156:                if(intVal < 0 || *s)
        -:14157:                    {
       57:14158:                    if(intVal != -2)
        -:14159:                        {
       28:14160:                        pkn->v.fl |= IMPLIEDFENCE; /* 20101101 FENCE -> IMPLIEDFENCE*/
        -:14161:                        }
       57:14162:                    return functionFail(pkn);
        -:14163:                    }
       39:14164:                sprintf(klad,"%d",intVal);
       39:14165:                wis(pkn);
       39:14166:                pkn = scopy((char *)klad);
       39:14167:                return functionOk(pkn);
        -:14168:                }
        -:14169:            }
        -:14170:#if !defined NO_LOW_LEVEL_FILE_HANDLING
        -:14171:        CASE(FIL) /* fil $ (<naam>,[<offset>,[set|cur|end]]) */
        -:14172:            {
       16:14173:            return fil(&pkn) ? functionOk(pkn) : functionFail(pkn);
        -:14174:            }
        -:14175:#endif
        -:14176:        CASE(FLG) /* flg $ <expr>  or flg$(=<expr>) */
        -:14177:            {
        5:14178:            if(is_object(rknoop) && !(rknoop->LEFT->v.fl & VISIBLE_FLAGS))
        5:14179:                rknoop = rknoop->RIGHT;
        5:14180:            intVal = rknoop->v.fl;
        5:14181:            adr[3] = zelfde_als_w(rknoop);
        5:14182:            adr[3] = prive(adr[3]);
        5:14183:            adr[3]->v.fl = adr[3]->v.fl & ~VISIBLE_FLAGS;
        5:14184:            adr[2] = zelfde_als_w(&nilk);
        5:14185:            adr[2] = prive(adr[2]);
        5:14186:            adr[2]->v.fl &= ~VISIBLE_FLAGS;         /*20050405*/
        5:14187:            adr[2]->v.fl |= VISIBLE_FLAGS & intVal;   /*20050405*/
        5:14188:            if(adr[2]->v.fl & INDIRECT) /*20110726*/
        -:14189:                {
        1:14190:                adr[2]->v.fl &= ~READY; /* {?} flg$(=!a):(=?X.?)&lst$X */
        1:14191:                adr[3]->v.fl |= READY;  /* {?} flg$(=!a):(=?.?Y)&!Y */
        -:14192:                }
        5:14193:            if(NIKSF(intVal))
        -:14194:                {
        1:14195:                adr[2]->v.fl ^= SUCCESS; /*20121014*/
        1:14196:                adr[3]->v.fl ^= SUCCESS;
        -:14197:                }
        5:14198:            sprintf(klad,"=\2.\3");
        5:14199:            pkn = opb(pkn,klad,NULL);
        5:14200:            wis(adr[2]);
        5:14201:            wis(adr[3]);
        5:14202:            return functionOk(pkn);
        -:14203:            }
        -:14204:        CASE(GLF) /* glf $ (=<flags>.<exp>) : (=?a)  a=<flags><exp> */
        -:14205:            {
        5:14206:            if(  is_object(rknoop)
        5:14207:              && kop(rknoop->RIGHT) == DOT
        -:14208:              )
        -:14209:                {
        4:14210:                intVal = rknoop->RIGHT->LEFT->v.fl & VISIBLE_FLAGS;
        4:14211:                if(intVal && (rknoop->RIGHT->RIGHT->v.fl & intVal))
        1:14212:                    return functionFail(pkn);
        3:14213:                adr[3] = zelfde_als_w(rknoop->RIGHT->RIGHT);
        3:14214:                adr[3] = prive(adr[3]);
        3:14215:                adr[3]->v.fl |= intVal;
        3:14216:                if(NIKSF(intVal))
        -:14217:                    {
        1:14218:                    adr[3]->v.fl ^= SUCCESS;
        -:14219:                    }
        -:14220:                /* 20110332: */
        3:14221:                if(intVal & INDIRECT)
        -:14222:                    {
        2:14223:                    adr[3]->v.fl ^= READY;
        -:14224:                    }
        3:14225:                sprintf(klad,"=\3");
        3:14226:                pkn = opb(pkn,klad,NULL);
        3:14227:                wis(adr[3]);
        3:14228:                return functionOk(pkn);
        -:14229:                }
        1:14230:            return functionFail(pkn);
        -:14231:            }
        -:14232:#if TELMAX
        -:14233:        CASE(BEZ) /* bez $  */
        -:14234:            {
        -:14235:#if MAXSTACK
        -:14236:            sprintf(klad,"%lu.%lu.%u.%d",(unsigned LONG)globalloc,(unsigned LONG)maxgloballoc,maxbez / ONE,maxstack);
        -:14237:#else
        5:14238:            sprintf(klad,"%lu.%lu.%u",(unsigned LONG)globalloc,(unsigned LONG)maxgloballoc,maxbez / ONE);
        -:14239:#endif
        5:14240:            pkn = opb(pkn,klad,NULL);
        -:14241:#if TELLING
        -:14242:            bezetting();
        -:14243:#endif
        5:14244:            return functionOk(pkn);
        -:14245:            }
        -:14246:#endif
        -:14247:        CASE(MMF) /* mem $ [EXT] */
        -:14248:            {
        4:14249:            mmf(&pkn);
        4:14250:            return functionOk(pkn);
        -:14251:            }
        -:14252:        CASE(MOD)
        -:14253:            {
       26:14254:            if(RATIONAAL_COMP(rlknoop = rknoop->LEFT) &&   /* 20101119 RATIONAAL -> RATIONAAL_COMP */
       13:14255:               RATIONAAL_COMP_NOT_NUL(rrknoop = rknoop->RIGHT)) /* 20101119 RATIONAAL -> RATIONAAL_COMP_NOT_NUL */
        -:14256:                {
        -:14257:                psk kn;
       12:14258:                kn = _qmodulo(rlknoop,rrknoop);
       12:14259:                wis(pkn);
       12:14260:                pkn = kn;
       12:14261:                return functionOk(pkn); /* 20101119 */
        -:14262:                }
        1:14263:            return functionFail(pkn); /* 20101119 functionOk -> functionFail */
        -:14264:            }
        -:14265:        CASE(REV)
        -:14266:            {
        2:14267:            if(!is_op(rknoop))
        -:14268:                {
        1:14269:                size_t len = strlen((char *)POBJ(rknoop)); /*Bart 20070220 int -> size_t*/
        -:14270:                psk kn;
        1:14271:                kn = zelfde_als_w(rknoop);
        1:14272:                if(len > 1)
        -:14273:                    {
        1:14274:                    kn = prive(kn);
        1:14275:                    stringreverse((char *)POBJ(kn),len);
        -:14276:                    }
        1:14277:                wis(pkn);
        1:14278:                pkn = kn;
        1:14279:                return functionOk(pkn);
        -:14280:                }
        -:14281:            else
        1:14282:                return functionFail(pkn);
        -:14283:            }
        -:14284:        CASE(LOW)
        -:14285:            {
        -:14286:            psk kn;
   131071:14287:            if(!is_op(rknoop))
   131069:14288:                kn = changeCase(rknoop
        -:14289:#if CODEPAGE850
        -:14290:                ,FALSE
        -:14291:#endif
        -:14292:                ,TRUE);
        2:14293:            else if(!is_op(rlknoop = rknoop->LEFT))
        1:14294:                kn = changeCase(rlknoop
        -:14295:#if CODEPAGE850
        -:14296:                ,zoekopt(rknoop->RIGHT,DOS)
        -:14297:#endif
        -:14298:                ,TRUE);
        -:14299:            else
        1:14300:                return functionFail(pkn);
   131070:14301:            wis(pkn);
   131070:14302:            pkn = kn;
   131070:14303:            return functionOk(pkn);
        -:14304:            }
        -:14305:        CASE(UPP)
        -:14306:            {
        -:14307:            psk kn;
    66553:14308:            if(!is_op(rknoop))
    66551:14309:                kn = changeCase(rknoop
        -:14310:#if CODEPAGE850
        -:14311:                ,FALSE
        -:14312:#endif
        -:14313:                ,FALSE);
        2:14314:            else if(!is_op(rlknoop = rknoop->LEFT))
        1:14315:                kn = changeCase(rlknoop
        -:14316:#if CODEPAGE850
        -:14317:                ,zoekopt(rknoop->RIGHT,DOS)
        -:14318:#endif
        -:14319:                ,FALSE);
        -:14320:            else
        1:14321:                return functionFail(pkn);
    66552:14322:            wis(pkn);
    66552:14323:            pkn = kn;
    66552:14324:            return functionOk(pkn);
        -:14325:            }
        -:14326:        CASE(DIV)
        -:14327:            {
       16:14328:            if(  is_op(rknoop)
       16:14329:              && RATIONAAL_COMP(rlknoop = rknoop->LEFT)
       16:14330:              && RATIONAAL_COMP_NOT_NUL(rrknoop = rknoop->RIGHT)/*20101119 RATIONAAL_COMP_NOT_NUL*/
        -:14331:              )
        -:14332:                {
        -:14333:                psk kn;
       15:14334:                kn = _qheeldeel(rlknoop,rrknoop);
       15:14335:                wis(pkn);
       15:14336:                pkn = kn;
       15:14337:                return functionOk(pkn);
        -:14338:                }
        1:14339:            return functionFail(pkn);
        -:14340:            }
        -:14341:        CASE(DEN)
        -:14342:            {
      245:14343:            if(RATIONAAL_COMP(rknoop))
        -:14344:                {
        -:14345:                psk kn;
      213:14346:                kn = _qdenominator(rknoop);
      213:14347:                wis(pkn);
      213:14348:                pkn = kn;
        -:14349:                }
      245:14350:            return functionOk(pkn);
        -:14351:            }
        -:14352:        CASE(LST)
        -:14353:            {
       11:14354:            return output(&pkn,lst) ? functionOk(pkn) : functionFail(pkn);
        -:14355:            }
        -:14356:#if !defined NO_FILE_RENAME
        -:14357:        CASE(REN)
        -:14358:            {
        3:14359:            if(   is_op(rknoop)
        3:14360:              && !is_op(rlknoop = rknoop->LEFT)
        3:14361:              && !is_op(rrknoop = rknoop->RIGHT)
        -:14362:              )
        -:14363:                {
        2:14364:                intVal = rename((const char *)POBJ(rlknoop),(const char *)POBJ(rrknoop));
        2:14365:                if(intVal)
        -:14366:                    {
        -:14367:#ifndef EACCES
        -:14368:                    sprintf(klad,"%d",ret);
        -:14369:#else
        1:14370:                    switch(errno)
        -:14371:                        {
        -:14372:                        case EACCES:
        -:14373:                            /*
        -:14374:                            File or directory specified by newname already exists or
        -:14375:                            could not be created (invalid path); or oldname is a directory
        -:14376:                            and newname specifies a different path.
        -:14377:                            */
    #####:14378:                            strcpy(klad,"EACCES");
    #####:14379:                            break;
        -:14380:                        case ENOENT:
        -:14381:                            /*
        -:14382:                            File or path specified by oldname not found.
        -:14383:                            */
        1:14384:                            strcpy(klad,"ENOENT");
        1:14385:                            break;
        -:14386:                        case EINVAL:
        -:14387:                            /*
        -:14388:                            Name contains invalid characters.
        -:14389:                            */
    #####:14390:                            strcpy(klad,"EINVAL");
    #####:14391:                            break;
        -:14392:                        default:
    #####:14393:                            sprintf(klad,"%d",errno);
    #####:14394:                            break;
        -:14395:                        }
        -:14396:#endif
        -:14397:                    }
        -:14398:                else
        1:14399:                    strcpy(klad,"0");
        2:14400:                wis(pkn);
        2:14401:                pkn = scopy((char *)klad);
        2:14402:                return functionOk(pkn);
        -:14403:                }
        -:14404:            else
        1:14405:                return functionFail(pkn);
        -:14406:            }
        -:14407:#endif
        -:14408:#if !defined NO_FILE_REMOVE
        -:14409:        CASE(RMV)
        -:14410:            {
        8:14411:            if(!is_op(rknoop))
        -:14412:                {
        -:14413:#if defined __SYMBIAN32__
        -:14414:                intVal = unlink((const char *)POBJ(rknoop));
        -:14415:#else
        7:14416:                intVal = remove((const char *)POBJ(rknoop));
        -:14417:#endif
        7:14418:                if(intVal)
        -:14419:                    {
        -:14420:#ifndef EACCES
        -:14421:                    sprintf(klad,"%d",intVal);
        -:14422:#else
        2:14423:                    switch(errno)
        -:14424:                        {
        -:14425:                        case EACCES:
        -:14426:                            /*
        -:14427:                            File or directory specified by newname already exists or
        -:14428:                            could not be created (invalid path); or oldname is a directory
        -:14429:                            and newname specifies a different path.
        -:14430:                            */
    #####:14431:                            strcpy(klad,"EACCES");
    #####:14432:                            break;
        -:14433:                        case ENOENT:
        -:14434:                            /*
        -:14435:                            File or path specified by oldname not found.
        -:14436:                            */
        2:14437:                            strcpy(klad,"ENOENT");
        2:14438:                            break;
        -:14439:                        default:
    #####:14440:                            sprintf(klad,"%d",errno);
    #####:14441:                            break;
        -:14442:                        }
        -:14443:#endif
        -:14444:                    }
        -:14445:                else
        5:14446:                    strcpy(klad,"0");
        7:14447:                wis(pkn);
        7:14448:                pkn = scopy((char *)klad);
        7:14449:                return functionOk(pkn);
        -:14450:                }
        -:14451:            else
        1:14452:                return functionFail(pkn);
        -:14453:            }
        -:14454:#endif
        -:14455:        CASE(ARG) /* arg$ or arg$N  (N == 0,1,... and N < argc) */
        -:14456:            {/*20100308*/
        -:14457:            static int argno = 0;
        4:14458:            if(is_op(rknoop))
    #####:14459:                return functionFail(pkn);
        4:14460:            if(PLOBJ(rknoop) != '\0')
        -:14461:                {
        -:14462:                LONG val;
    #####:14463:                if(!INTEGER_NIET_NEG(rknoop))
    #####:14464:                    return functionFail(pkn);
    #####:14465:                val = STRTOUL((char *)POBJ(rknoop),(char **)NULL,10);
    #####:14466:                if(val >= ARGC)
    #####:14467:                    return functionFail(pkn);
    #####:14468:                wis(pkn);
    #####:14469:                pkn = scopy((char *)ARGV[val]);
    #####:14470:                return functionOk(pkn);
        -:14471:                }
        4:14472:            if(argno < ARGC)
        -:14473:                {
        2:14474:                wis(pkn);
        2:14475:                pkn = scopy((char *)ARGV[argno++]);
        2:14476:                return functionOk(pkn);
        -:14477:                }
        -:14478:            else
        -:14479:                {
        2:14480:                return functionFail(pkn);
        -:14481:                }
        -:14482:            }
        -:14483:        CASE(GET) /* get$file */
        -:14484:            {
        -:14485:            Boolean GoOn;
       14:14486:            if(is_op(rknoop))
        -:14487:                {
        9:14488:                if(is_op(rlknoop = rknoop->LEFT))
        2:14489:                    return functionFail(pkn);
        7:14490:                rrknoop = rknoop->RIGHT;
       14:14491:                intVal = (zoekopt(rrknoop,ECH) << SHIFT_ECH)
        7:14492:                       + (zoekopt(rrknoop,MEM) << SHIFT_MEM)
        7:14493:                       + (zoekopt(rrknoop,VAP) << SHIFT_VAP)
        7:14494:                       + (zoekopt(rrknoop,STG) << SHIFT_STR)
        7:14495:                       + (zoekopt(rrknoop,ML ) << SHIFT_ML)
        7:14496:                       + (zoekopt(rrknoop,TRM) << SHIFT_TRM)
        7:14497:                       + (zoekopt(rrknoop,HT)  << SHIFT_HT);
        -:14498:                }
        -:14499:            else
        -:14500:                {
        5:14501:                intVal = 0;
        5:14502:                rlknoop = rknoop;
        -:14503:                }
       12:14504:            if(intVal & OPT_MEM)
        -:14505:                {
        -:14506:                int err;
        6:14507:                adr[1] = zelfde_als_w(rlknoop);
        6:14508:                bron = POBJ(adr[1]);
        -:14509:                for(;;)
        -:14510:                    {
       10:14511:                    pkn = input(NULL,pkn,intVal,&err,&GoOn);
       10:14512:                    if(!GoOn || err)
        -:14513:                        break;
        4:14514:                    pkn = eval(pkn);
        4:14515:                    }
        6:14516:                wis(adr[1]);
        -:14517:                }
        -:14518:            else
        -:14519:                {
        6:14520:                if(rlknoop->u.obj && strcmp((char *)POBJ(rlknoop),"stdin"))
        4:14521:                    {
        -:14522:                    FILE *red;
        -:14523:                    int err;
        -:14524:                    filehendel * fh;
        6:14525:                    red = fpi;
        6:14526:                    fh = myfopen((char *)POBJ(rlknoop),"r");
        6:14527:                    if(fh == NULL)
        -:14528:                        {
        2:14529:                        fpi = red;
        2:14530:                        return functionFail(pkn);
        -:14531:                        }
        -:14532:                    else
        4:14533:                        fpi = fh->fp;
        -:14534:		    for(;;)
        -:14535:                        {
        9:14536:                        pkn = input(fpi,pkn,intVal,&err,&GoOn);
        9:14537:                        if(!GoOn || err)
        -:14538:                            break;
        5:14539:                        pkn = eval(pkn);
        5:14540:                        }
        -:14541:                    /*fclose(fpi);*/
        4:14542:                    deallocateFilehendel(fh);
        4:14543:                    fpi = red;
        -:14544:                    }
        -:14545:                else
        -:14546:                    {
        -:14547:                    int err;
    #####:14548:                    intVal |= OPT_ECH;
        -:14549:#ifdef DELAY_DUE_TO_INPUT
        -:14550:                    for(;;)
        -:14551:                        {
        -:14552:                        clock_t time0;
    #####:14553:                        time0 = clock();
    #####:14554:                        pkn = input(stdin,pkn,intVal,&err,&GoOn);
    #####:14555:                        delayDueToInput += clock() - time0;
    #####:14556:                        if(!GoOn || err)
        -:14557:                            break;
    #####:14558:                        pkn = eval(pkn);
    #####:14559:                        }
        -:14560:#else
        -:14561:                    for(;;)
        -:14562:                        {
        -:14563:                        pkn = input(stdin,pkn,intVal,&err,&GoOn);
        -:14564:                        if(!GoOn || err)
        -:14565:                            break;
        -:14566:                        pkn = eval(pkn);
        -:14567:                        }
        -:14568:#endif
        -:14569:                    }
        -:14570:                }
       10:14571:            return functionOk(pkn);
        -:14572:            }
        -:14573:        CASE(PUT) /* put$(file,mode,knoop) of put$knoop */
        -:14574:            {
      382:14575:            return output(&pkn,result) ? functionOk(pkn) : functionFail(pkn);
        -:14576:            }
        -:14577:#if !defined __SYMBIAN32__
        -:14578:#if !defined NO_SYSTEM_CALL
        -:14579:        CASE(SYS)
        -:14580:            {
        2:14581:            if(is_op(rknoop) || (PLOBJ(rknoop) == '\0'))
        1:14582:                return functionFail(pkn);
        -:14583:            else
        -:14584:                {
        1:14585:                intVal = system((const char *)POBJ(rknoop));
        1:14586:                if(intVal)
        -:14587:#ifndef E2BIG
        -:14588:                    sprintf(klad,"%d",intVal);
        -:14589:#else
    #####:14590:                    switch(errno)
        -:14591:                        {
        -:14592:                        case E2BIG:
        -:14593:                            /*
        -:14594:                            Argument list (which is system-dependent) is too big.
        -:14595:                            */
    #####:14596:                            strcpy(klad,"E2BIG");
    #####:14597:                            break;
        -:14598:                        case ENOENT:
        -:14599:                            /*
        -:14600:                            Command interpreter cannot be found.
        -:14601:                            */
    #####:14602:                            strcpy(klad,"ENOENT");
    #####:14603:                            break;
        -:14604:                        case ENOEXEC:
        -:14605:                            /*
        -:14606:                            Command-interpreter file has invalid format and is not executable.
        -:14607:                            */
    #####:14608:                            strcpy(klad,"ENOEXEC");
    #####:14609:                            break;
        -:14610:                        case ENOMEM:
        -:14611:                            /*
        -:14612:                            Not enough memory is available to execute command; or available
        -:14613:                            memory has been corrupted; or invalid block exists, indicating
        -:14614:                            that process making call was not allocated properly.
        -:14615:                            */
    #####:14616:                            strcpy(klad,"ENOMEM");
    #####:14617:                            break;
        -:14618:                        default:
    #####:14619:                            sprintf(klad,"%d",errno);
    #####:14620:                            break;
        -:14621:                        }
        -:14622:#endif
        -:14623:                else
        1:14624:                    strcpy(klad,"0");
        1:14625:                wis(pkn);
        1:14626:                pkn = scopy((char *)klad);
        1:14627:                return functionOk(pkn);
        -:14628:                }
        -:14629:            }
        -:14630:#endif
        -:14631:#endif
        -:14632:        CASE(TBL) /* tbl$(varnaam,lengte) */
        -:14633:            {
     2111:14634:            if(is_op(rknoop))
     2110:14635:                return psh(rknoop->LEFT,&nulk,rknoop->RIGHT) ? functionOk(pkn) : functionFail(pkn);
        -:14636:            else
        1:14637:                return functionFail(pkn);
        -:14638:            }
        -:14639:#if 0
        -:14640:/*
        -:14641:The same effect is obtained by <expr>:?!(=)
        -:14642:*/
        -:14643:        CASE(PRV) /* "?"$<expr> */
        -:14644:            {
        -:14645:            if((rknoop->v.fl & SUCCESS)
        -:14646:            && (is_op(rknoop) || rknoop->u.obj || HAS_UNOPS(rknoop)))
        -:14647:                insert(&nilk,rknoop);
        -:14648:            pkn = rechtertak(pkn);
        -:14649:            return functionOk(pkn);
        -:14650:            }
        -:14651:#endif
        -:14652:        CASE(CLK) /* clk' */
        -:14653:            {
        9:14654:            clock_t time = clock();
        -:14655:#ifdef DELAY_DUE_TO_INPUT
        9:14656:            time -= delayDueToInput;
        -:14657:#endif
        9:14658:            print_clock(klad,time);
        9:14659:            wis(pkn);
        9:14660:            pkn = scopy((char *)klad);
        9:14661:            return functionOk(pkn);
        -:14662:            }
        -:14663:
        -:14664:        CASE(SIM) /* sim$(<atoom>,<atoom>) , fuzzy compare (percentage) */
        -:14665:            {
      349:14666:            if(is_op(rknoop) /*20121014 dropped requirement for comma*/
      348:14667:            && !is_op(rlknoop = rknoop->LEFT)
      348:14668:            && !is_op(rrknoop = rknoop->RIGHT))
        -:14669:                {
      347:14670:                Sim(klad,(char *)POBJ(rlknoop),(char *)POBJ(rrknoop));
      347:14671:                wis(pkn);
      347:14672:                pkn = scopy((char *)klad);
      347:14673:                return functionOk(pkn);
        -:14674:                }
        -:14675:            else
        2:14676:                return functionFail(pkn);
        -:14677:            }
        -:14678:#if DEBUGBRACMAT
        -:14679:        CASE(DBG) /* dbg$<expr> */
        -:14680:            {
        -:14681:            ++debug;
        -:14682:            if(kop(pkn) != FUU)
        -:14683:                {
        -:14684:                errorprintf("Use dbg'(expression), not dbg$(expression)!\n");
        -:14685:                writeError(pkn);
        -:14686:                }
        -:14687:            pkn = rechtertak(pkn);
        -:14688:            pkn = eval(pkn);
        -:14689:            --debug;
        -:14690:            return functionOk(pkn);
        -:14691:            }
        -:14692:#endif
        -:14693:        CASE(WHL) /*20080127*/
        -:14694:            {
   180355:14695:            while(isSUCCESSorFENCE(rknoop = eval(zelfde_als_w(pkn->RIGHT))))
        -:14696:                {
   176637:14697:                wis(rknoop);
        -:14698:                }
     1859:14699:            wis(rknoop);
     1859:14700:            return functionOk(pkn); /* 20080211 functionFail(pkn) -> functionOk(pkn) */
        -:14701:            }
        -:14702:        CASE(New) /* new$<object>*/
        -:14703:            {
       16:14704:            if(kop(rknoop) == KOMMA)
        -:14705:                {
        7:14706:                adr[2] = getObjectDef(rknoop->LEFT);
        7:14707:                if(!adr[2])
        1:14708:                    return functionFail(pkn);
        6:14709:                adr[3] = rknoop->RIGHT;
        6:14710:                if(ISBUILTIN((objectknoop*)adr[2]))
        4:14711:                    pkn = opb(pkn,"(((\2.New)'\3)|)&\2",NULL);
        -:14712:    /*                pkn = opb(pkn,"(((\2.New)'\3)&(\2.new)'\3)|)&\2",NULL);*/
        -:14713:    /* We might be able to call 'new' if 'New' had attached the argument
        -:14714:        (containing the definition of a 'new' method) to the rhs of the '='.
        -:14715:       This cannot be done in a general way without introducing new syntax rules for the new$ function.
        -:14716:    */
        -:14717:                else
        2:14718:                    pkn = opb(pkn,"(((\2.new)'\3)|)&\2",NULL);
        -:14719:                }
        -:14720:            else
        -:14721:                {
        9:14722:                adr[2] = getObjectDef(rknoop);
        -:14723:                DBGSRC(printf("adr[2]:");result(adr[2]);printf("\n");)
        9:14724:                if(!adr[2])
        1:14725:                    return functionFail(pkn);
        8:14726:                if(ISBUILTIN((objectknoop*)adr[2]))
        3:14727:                    pkn = opb(pkn,"(((\2.New)')|)&\2",NULL);
        -:14728:                /* There cannot be a user-defined 'new' method on a built-in object if there is no way to supply it*/
        -:14729:                /* 'die' CAN be user-supplied. The built-in function is 'Die' */
        -:14730:                else
        5:14731:                    pkn = opb(pkn,"(((\2.new)')|)&\2",NULL);
        -:14732:                }
       14:14733:            SETCREATEDWITHNEW((objectknoop*)adr[2]);
       14:14734:            wis(adr[2]);
       14:14735:            return functionOk(pkn);
        -:14736:            }
        -:14737:        CASE(0) /* $<expr>  '<expr> */
        -:14738:            {
      438:14739:            if(kop(pkn) == FUU)
        -:14740:                {
      438:14741:                if(!HAS_UNOPS(pkn->LEFT))
        -:14742:                    {
      437:14743:                    intVal = pkn->v.fl & UNOPS;/*20101103*/
      437:14744:                    if(  intVal == BREUK  /*20120915 & --> == */
       22:14745:                      && is_op(pkn->RIGHT)/*20120915 is_op test */
       22:14746:                      && kop(pkn->RIGHT) == DOT
       22:14747:                      && !is_op(pkn->RIGHT->LEFT)
        -:14748:                      )
        -:14749:                        { /* /('(a.a+2))*/
       22:14750:                        return functionOk(pkn);
        -:14751:                        }
        -:14752:                    else
        -:14753:                        {
      415:14754:                        rknoop = evalmacro(pkn->RIGHT);
      415:14755:                        rrknoop = (psk)bmalloc(__LINE__,sizeof(objectknoop));
        -:14756:#ifdef BUILTIN
      415:14757:                        ((typedObjectknoop*)rrknoop)->u.Int = 0;
        -:14758:#else
        -:14759:                        ((typedObjectknoop*)rrknoop)->refcount = 0;
        -:14760:                        UNSETCREATEDWITHNEW((typedObjectknoop*)rrknoop);
        -:14761:                        UNSETBUILTIN((typedObjectknoop*)rrknoop);
        -:14762:#endif
      415:14763:                        rrknoop->v.fl = WORDT | SUCCESS;
      415:14764:                        rrknoop->LEFT = zelfde_als_w(&nilk);
      415:14765:                        if(rknoop)
        -:14766:                            {
      414:14767:                            rrknoop->RIGHT = rknoop;
        -:14768:                            }
        -:14769:                        else
        -:14770:                            {
        1:14771:                            rrknoop->RIGHT = zelfde_als_w(pkn->RIGHT);
        -:14772:                            }
      415:14773:                        wis(pkn);
      415:14774:                        pkn = rrknoop;
      415:14775:                        pkn->v.fl |= intVal; /*20101103     (a=b)&!('$a)*/
        -:14776:                        }
        -:14777:                    }
        -:14778:                else
        -:14779:                    {
        1:14780:                    combiflags(pkn);
        1:14781:                    pkn = rechtertak(pkn);
        -:14782:                    }
      416:14783:                return functionOk(pkn);
        -:14784:                }
        -:14785:            else
        -:14786:                {
        -:14787:/*                errorprintf("\nChanged behaviour: <flags>$<expresion> is stable.");writeError(pkn);errorprintf("\n");*/
    #####:14788:                return functionFail(pkn);
        -:14789:                }
        -:14790:            }
        -:14791:        DEFAULT
        -:14792:            {
     7797:14793:            if(INTEGER(lknoop))
        -:14794:                {
        -:14795:                vars *navar;
     2242:14796:                if(is_op(rknoop))
        1:14797:                    return functionFail(pkn);
     6728:14798:                for(navar = variabelen[rknoop->u.obj];
     4487:14799:                    navar && (STRCMP(VARNAME(navar),POBJ(rknoop)) < 0);
     2246:14800:                    navar = navar->next);
        -:14801:                /* eerste naam in een rij gelijke wordt gevonden */
     2241:14802:                if(navar && !STRCMP(VARNAME(navar),POBJ(rknoop)))
        -:14803:                    {
     2240:14804:                    navar->selector =
     2240:14805:                       (int)toLong(lknoop)
     2240:14806:                     % (navar->n + 1);
     2240:14807:                    if(navar->selector < 0)
       18:14808:                        navar->selector += (navar->n + 1);
     2240:14809:                    pkn = rechtertak(pkn);
     2240:14810:                    return functionOk(pkn);
        -:14811:                    }
        -:14812:                }
     5556:14813:            if(!(rknoop->v.fl & SUCCESS))
        1:14814:                return functionFail(pkn);
     5555:14815:            adr[1] = NULL;
     5555:14816:            return find_func(pkn);
        -:14817:            }
        -:14818:        }
        -:14819:        }
        -:14820:    /*return functionOk(pkn); 20 Dec 1995, unreachable code in Borland C */
        -:14821:    }
        -:14822:/*
        -:14823:static psk numboom(psk pkn,psk lknoop,const char *conc[])
        -:14824:    {
        -:14825:    if(lknoop == pkn->LEFT)
        -:14826:        return vopb(pkn,conc+2);
        -:14827:    else
        -:14828:        {
        -:14829:        conc[0] = hekje1;
        -:14830:        adr[1] = pkn->LEFT->LEFT;
        -:14831:        return vopb(pkn,conc);
        -:14832:        }
        -:14833:    }
        -:14834:*/
     1843:14835:static psk stapelmacht(psk pkn)
        -:14836:    {
        -:14837:    psk lknoop;
     1843:14838:    Boolean done = FALSE;
     3702:14839:    for(;((lknoop = pkn->LEFT)->v.fl & READY) && kop(lknoop) == EXP;)
        -:14840:        {
       16:14841:        done = TRUE;
       16:14842:        pkn->LEFT = lknoop = prive(lknoop);
       16:14843:        lknoop->v.fl &= ~READY & ~OPERATOR;/* READY vlag uitzetten */
       16:14844:        lknoop->ops |= MAAL;
       16:14845:        adr[1] = lknoop->LEFT;
       16:14846:        adr[2] = lknoop->RIGHT;
       16:14847:        adr[3] = pkn->RIGHT;
       16:14848:        pkn = opb(pkn,"(\1^(\2*\3))",NULL);
        -:14849:        }
     1843:14850:    if(done)
        -:14851:        {
       16:14852:        return pkn;
        -:14853:        }
        -:14854:    else
        -:14855:        {
        -:14856:        static const char * conc[] = {NULL,NULL,NULL,NULL,NULL,NULL};
        -:14857:
        -:14858:        Qgetal iexponent,
        -:14859:        hiexponent;
        -:14860:
        -:14861:        psk rknoop;
     1827:14862:        if(!is_op(rknoop = pkn->RIGHT))
        -:14863:            {
     1481:14864:            if(RAT_NUL(rknoop))
        -:14865:                {
      315:14866:                wis(pkn);
      315:14867:                return copievan(&eenk);
        -:14868:                }
     1166:14869:            if(IS_EEN(rknoop))
        -:14870:                {
      103:14871:                return linkertak(pkn);
        -:14872:                }
        -:14873:            }
     1409:14874:        lknoop = pkn->LEFT;
     1409:14875:        if(!is_op(lknoop))
        -:14876:            {
     1201:14877:            if((RAT_NUL(lknoop) && /*20080910*/!RAT_NEG_COMP(rknoop)) || IS_EEN(lknoop))
        -:14878:                {
       78:14879:                return linkertak(pkn);
        -:14880:                }
        -:14881:
     1123:14882:            if(!is_op(rknoop) && RATIONAAL_COMP(rknoop))
        -:14883:                {
      751:14884:                if(RATIONAAL_COMP(lknoop))
        -:14885:                    {
      367:14886:                    if(RAT_NEG_COMP(rknoop) && abseen(rknoop))
        -:14887:                        {
      222:14888:                        conc[1] = NULL;
      222:14889:                        conc[2] = hekje6;
      222:14890:                        conc[3] = NULL;
      222:14891:                        adr[6] = _q_qdeel(&eenk,lknoop);
        -:14892:                        /*pkn = numboom(pkn,lknoop,conc);*/
        -:14893:                        assert(lknoop == pkn->LEFT);
      222:14894:                        pkn = vopb(pkn,conc+2);
      222:14895:                        wis(adr[6]);
      222:14896:                        return pkn;
        -:14897:                        }
      145:14898:                    else if(RAT_NEG_COMP(lknoop) && RAT_RAT_COMP(rknoop))
        -:14899:                        {
        1:14900:                        return pkn; /*{?} -3^2/3 => -3^2/3 */
        -:14901:                        }
        -:14902:                    /* hier ontbreekt n^m, met m > 2.
        -:14903:                       Dit wordt in casemacht behandeld. */
        -:14904:                    }
      384:14905:                else if(PLOBJ(lknoop) == IM)
        -:14906:                    {
       16:14907:                    if(_qvergelijk(rknoop,&nulk) & MINUS)
        -:14908:                        { /* i^-n -> -i^n */ /*{?} i^-7 => i */
        -:14909:                          /* -i^-n -> i^n */ /*{?} -i^-7 => -i */
        2:14910:                        conc[0] = "(\2^\3)";
        2:14911:                        adr[2] = _qmaalmineen(lknoop);
        2:14912:                        adr[3] = _qmaalmineen(rknoop);
        2:14913:                        conc[1] = NULL;
        2:14914:                        pkn = vopb(pkn,conc);
        2:14915:                        wis(adr[2]);
        2:14916:                        wis(adr[3]);
        2:14917:                        return pkn;
        -:14918:                        }
       14:14919:                    else if(_qvergelijk(&tweek,rknoop) & (QNUL|MINUS))
        -:14920:                        {
       12:14921:                        iexponent = _qmodulo(rknoop,&vierk);
       12:14922:                        if(iexponent->ops & QNUL)
        -:14923:                            {
        1:14924:                            wis(pkn); /*{?} i^4 => 1 */
        1:14925:                            pkn = copievan(&eenk);
        -:14926:                            }
        -:14927:                        else
        -:14928:                            {
        -:14929:                            int teken;
       11:14930:                            teken = _qvergelijk(iexponent,&tweek);
       11:14931:                            if(teken & QNUL)
        -:14932:                                {
        6:14933:                                wis(pkn);
        6:14934:                                pkn = copievan(&mineenk);
        -:14935:                                }
        -:14936:                            else
        -:14937:                                {
        5:14938:                                if(!(teken & MINUS))
        -:14939:                                    {
        -:14940:                                    /*hiexponent = _qmaalmineen(iexponent);
        -:14941:                                    wis(iexponent);*/
        3:14942:                                    hiexponent = iexponent;
        3:14943:                                    iexponent = _qplus(&vierk,hiexponent,MINUS);
        3:14944:                                    wis(hiexponent);
        -:14945:                                    }
        5:14946:                                adr[2] = lknoop;
        5:14947:                                adr[6] = iexponent;
        5:14948:                                conc[0] = "(-1*\2)^";
        5:14949:                                conc[1] = "(\6)";/*hekje6;*/
        5:14950:                                conc[2] = NULL;
        5:14951:                                pkn = vopb(pkn,conc);
        -:14952:                                }
        -:14953:                            }
       12:14954:                        wis(iexponent);
       12:14955:                        return pkn;
        -:14956:                        }
        -:14957:                    }
        -:14958:                }
        -:14959:            }
        -:14960:
     1094:14961:        if(kop(lknoop) == MAAL)
        -:14962:            {
       86:14963:            adr[1] = lknoop->LEFT;
       86:14964:            adr[2] = lknoop->RIGHT;
       86:14965:            adr[3] = pkn->RIGHT;
       86:14966:            return opb(pkn,"\1^\3*\2^\3",NULL);
        -:14967:            }
        -:14968:
     1008:14969:        if(RATIONAAL_COMP(lknoop))
        -:14970:            {
        -:14971:            static const char
        -:14972:                haakmineen[] = ")^-1",
        -:14973:                haakhekje1macht[] = "(\1^",
        -:14974:                macht2maaleenmacht[] = ")^2*\1^";
        -:14975:            psk rknoop;
      146:14976:            rknoop = pkn->RIGHT;
      146:14977:            if(INTEGER_NIET_NUL_COMP(rknoop) && !abseen(rknoop))
        -:14978:                {
      110:14979:                adr[1] = lknoop;
      110:14980:                if(INTEGER_POS_COMP(rknoop))
        -:14981:                    {
      109:14982:                    if(_qvergelijk(&tweek,rknoop) & MINUS)
        -:14983:                        {
        -:14984:                        /* m^n = (m^(n\2))^2*m^(n mod 2) */ /*{?} 9^7 => 4782969 */
       46:14985:                        conc[0] = haakhekje1macht;
       46:14986:                        conc[1] = hekje5;
       46:14987:                        conc[3] = hekje6;
       46:14988:                        conc[4] = NULL;
       46:14989:                        adr[5] = _qheeldeel(rknoop,&tweek);
       46:14990:                        conc[2] = macht2maaleenmacht;
       46:14991:                        adr[6] = _qmodulo(rknoop,&tweek);
       46:14992:                        pkn = vopb(pkn,conc);
       46:14993:                        wis(adr[5]);
       46:14994:                        wis(adr[6]);
        -:14995:                        }
        -:14996:                    else
        -:14997:                        {
        -:14998:                        /*int ra;*/
        -:14999:                        /* m^2 = m*m */
       63:15000:                        pkn = opb(pkn,"(\1*\1)",NULL);
        -:15001:                        }
        -:15002:                    }
        -:15003:                else
        -:15004:                    {
        -:15005:                    /*{?} 7^-13 => 1/96889010407 */
        1:15006:                    conc[0] = haakhekje1macht;
        1:15007:                    conc[1] = hekje6;
        1:15008:                    adr[6] = _qmaalmineen(rknoop);
        1:15009:                    conc[2] = haakmineen;
        1:15010:                    conc[3] = 0;
        1:15011:                    pkn = vopb(pkn,conc);
        1:15012:                    wis(adr[6]);
        -:15013:                    }
      110:15014:                return pkn;
        -:15015:                }
       36:15016:            else if(RAT_RAT(rknoop))
        -:15017:                {
       34:15018:                char **conc,slash = 0;
        -:15019:                int wipe[20],ind;
       34:15020:                ngetal teller = {0},noemer = {0};
       34:15021:                for(ind = 0; ind < 20; wipe[ind++] = TRUE);
       34:15022:                ind = 0;
       34:15023:                conc = (char **)bmalloc(__LINE__,20 * sizeof(char **));
        -:15024:                   /* 20 is veilige waarde voor ULONGs */
       34:15025:                adr[1] = pkn->RIGHT;
       34:15026:                if(RAT_RAT_COMP(pkn->LEFT))
        -:15027:                    {
        5:15028:                    splits(pkn->LEFT,&teller,&noemer);
        5:15029:                    if(!subroot(&teller,conc,&ind))
        -:15030:                        {
        5:15031:                        wipe[ind] = FALSE;
        5:15032:                        conc[ind++] = teller.number;
        5:15033:                        slash = teller.number[teller.length];
        5:15034:                        teller.number[teller.length] = 0;
        -:15035:
        5:15036:                        wipe[ind] = FALSE;
        5:15037:                        conc[ind++] = "^\1";
        -:15038:                        }
        5:15039:                    wipe[ind] = FALSE;
        5:15040:                    conc[ind++] = "*(";
        5:15041:                    if(!subroot(&noemer,conc,&ind))
        -:15042:                        {
        1:15043:                        wipe[ind] = FALSE;
        1:15044:                        conc[ind++] = noemer.number;
        1:15045:                        wipe[ind] = FALSE;
        1:15046:                        conc[ind++] = "^\1";
        -:15047:                        }
        5:15048:                    wipe[ind] = FALSE;
        5:15049:                    conc[ind++] = ")^-1";
        -:15050:                    }
        -:15051:                else
        -:15052:                    {
       29:15053:                    teller.number = (char *)POBJ(pkn->LEFT);
       29:15054:                    teller.alloc = NULL;
       29:15055:                    teller.length = strlen(teller.number);
       29:15056:                    if(!subroot(&teller,conc,&ind))
        -:15057:                        {
       26:15058:                        bfree(conc);
       26:15059:                        return pkn;
        -:15060:                        }
        -:15061:                    }
        8:15062:                conc[ind--] = NULL;
        8:15063:                pkn = vopb(pkn,(const char **)conc);
        8:15064:                if(slash)
        5:15065:                    teller.number[teller.length] = slash;
       42:15066:                for(;ind >= 0;ind--)
       34:15067:                   if(wipe[ind])
       12:15068:                       bfree(conc[ind]);
        8:15069:                bfree(conc);
        8:15070:                return pkn;
        -:15071:                }
        -:15072:            }
        -:15073:        }
      864:15074:    if(is_op(pkn->RIGHT))
        -:15075:        {
        -:15076:        int ok;
      346:15077:        pkn = tryq(pkn,f4,&ok);
        -:15078:        }
      864:15079:    return pkn;
        -:15080:    }
        -:15081:
        -:15082:/*
        -:15083:Bart 20010316
        -:15084:Improvement that DOES evaluate b+(i*c+i*d)+-i*c
        -:15085:It also allows much deeper structures, because the right place for insertion
        -:15086:is found iteratively, not recursively. This also causes some operations to
        -:15087:be tremendously faster. e.g. (1+a+b+c)^30+1&ready evaluates in about
        -:15088:4,5 seconds now, previously in 330 seconds! (AST Bravo MS 5233M 233 MHz MMX Pentium)
        -:15089:*/
    25369:15090:static void splitProduct_number_im_rest(psk pknoop,ppsk N,ppsk I,ppsk NNNI)
        -:15091:    {
        -:15092:    psk temp;
    25369:15093:    if(kop(pknoop) == MAAL)
        -:15094:        {
    22448:15095:        if(RATIONAAL_COMP(pknoop->LEFT))
        -:15096:            {/* 17*x */
    19362:15097:            *N = pknoop->LEFT;
    19362:15098:            temp = pknoop->RIGHT;
        -:15099:            }/* N*temp */
        -:15100:        else
        -:15101:            {
     3086:15102:            *N = NULL;
     3086:15103:            temp = pknoop;
        -:15104:            }/* temp */
    22448:15105:        if(kop(temp) == MAAL)
        -:15106:            {
    17552:15107:            if(!is_op(temp->LEFT) && PLOBJ(temp->LEFT) == IM)
        -:15108:                {/* N*i*x */
      198:15109:                *I = temp->LEFT;
      198:15110:                *NNNI = temp->RIGHT;
        -:15111:                }/* N*I*NNNI */
        -:15112:            else
        -:15113:                {
    17354:15114:                *I = NULL;
    17354:15115:                *NNNI = temp;
        -:15116:                }/* N*NNNI */
        -:15117:            }
        -:15118:        else
        -:15119:            {
     4896:15120:            if(!is_op(temp) && PLOBJ(temp) == IM)
        -:15121:                {/* N*i */
        4:15122:                *I = temp;
        4:15123:                *NNNI = NULL;
        -:15124:                }/* N*I */
        -:15125:            else
        -:15126:                {
     4892:15127:                *I = NULL;
     4892:15128:                *NNNI = temp;
        -:15129:                }/* N*NNNI */
        -:15130:            }
        -:15131:        }
        -:15132:    /*else if(RATIONAAL_COMP(pknoop))
        -:15133:        {/ * 17 * /
        -:15134:        *N = pknoop;
        -:15135:        *I = NULL;
        -:15136:        *NNNI = NULL;
        -:15137:        }*//* N */
     2921:15138:    else if(!is_op(pknoop) && PLOBJ(pknoop) == IM)
        -:15139:        {/* i */
       44:15140:        *N = NULL;
       44:15141:        *I = pknoop;
       44:15142:        *NNNI = NULL;
        -:15143:        }/* I */
        -:15144:    else
        -:15145:        {/* x */
     2877:15146:        *N = NULL;
     2877:15147:        *I = NULL;
     2877:15148:        *NNNI = pknoop;
        -:15149:        }/* NNNI */
    25369:15150:    }
        -:15151:
   390893:15152:static psk rechteroperand_and_tail(psk pkn,ppsk head,ppsk tail)
        -:15153:    {
        -:15154:    psk temp;
        -:15155:    assert(is_op(pkn));
   390893:15156:    temp = pkn->RIGHT;
   390893:15157:    if(kop(pkn) == kop(temp))
        -:15158:        {
    14399:15159:        *head = temp->LEFT;
    14399:15160:        *tail = temp->RIGHT;
        -:15161:        }
        -:15162:    else
        -:15163:        {
   376494:15164:        *head = temp;
   376494:15165:        *tail = NULL;
        -:15166:        }
   390893:15167:    return temp;
        -:15168:    }
        -:15169:
   393045:15170:static psk linkeroperand_and_tail(psk pkn,ppsk head,ppsk tail)
        -:15171:    {
        -:15172:    psk temp;
        -:15173:    assert(is_op(pkn));
   393045:15174:    temp = pkn->LEFT;
   393045:15175:    if(kop(pkn) == kop(temp))
        -:15176:        {
     5151:15177:        *head = temp->LEFT;
     5151:15178:        *tail = temp->RIGHT;
        -:15179:        }
        -:15180:    else
        -:15181:        {
   387894:15182:        *head = temp;
   387894:15183:        *tail = NULL;
        -:15184:        }
   393045:15185:    return temp;
        -:15186:    }
        -:15187:
        -:15188:#define EXPAND 0
        -:15189:#if EXPAND
        -:15190:static psk expandDummy(psk pkn,int * ok)
        -:15191:    {
        -:15192:    *ok = FALSE;
        -:15193:    return pkn;
        -:15194:    }
        -:15195:#endif
        -:15196:
    14969:15197:static psk expandProduct(psk pkn,int * ok)
        -:15198:    {
    14969:15199:    switch(kop(pkn))
        -:15200:        {
        -:15201:        case MAAL :
        -:15202:        case EXP  :
        -:15203:            {
     9397:15204:            if(  (  (match(0,pkn,m0,NULL,0,pkn,3333) & TRUE)
       12:15205:                 && ((pkn = tryq(pkn,f0,ok)),*ok)
        -:15206:                 )
     9385:15207:              || (  (match(0,pkn,m1,NULL,0,pkn,4444) & TRUE)
      976:15208:                 && ((pkn = tryq(pkn,f1,ok)),*ok)
        -:15209:                 )
        -:15210:              )
        -:15211:                {
      988:15212:                if(is_op(pkn)) /* 20101018 */ /*{?} (1+i)*(1+-i)+Z => 2+Z */
      987:15213:                    pkn->v.fl &= ~READY;
      988:15214:                return pkn;
        -:15215:                }
     8409:15216:            break;
        -:15217:            }
        -:15218:        }
    13981:15219:    *ok = FALSE;
    13981:15220:    return pkn;
        -:15221:    }
        -:15222:
        -:15223:/*static int level = 0;*/
        -:15224:
   191028:15225:static psk plus_samenvoegen_of_sorteren(psk pkn)
        -:15226:    {
        -:15227:    /*
        -:15228:    Split pkn in left L and right R argument
        -:15229:
        -:15230:    If L is zero,
        -:15231:        return R
        -:15232:
        -:15233:    If R is zero,
        -:15234:        return L
        -:15235:
        -:15236:    If L is a product containing a sum,
        -:15237:        expand it
        -:15238:
        -:15239:    If R is a product containing a sum,
        -:15240:        expand it
        -:15241:
        -:15242:    Find the proper place split of R into Rhead , RtermS,  RtermGE and Rtail for L to insert into:
        -:15243:        L + R -> Rhead + RtermS + L + RtermGE + Rtail:
        -:15244:    Start with Rhead = NIL, RtermS = NIL  RtermGE is first term of R and Rtail is remainder of R
        -:15245:    Split L into Lterm and Ltail
        -:15246:    If Lterm is a number
        -:15247:        if RtermGE is a number
        -:15248:            return sum(Lterm,RtermGE) + Ltail + Rtail
        -:15249:        else
        -:15250:            return Lterm + Ltail + R
        -:15251:    Else if Rterm is a number
        -:15252:        return Rterm + L + Rtail
        -:15253:    Else
        -:15254:        get the non-numerical factor LtermNN of Lterm
        -:15255:        if LtermNN is imaginary
        -:15256:            get the nonimaginary factors of LtermNN (these may also include 'e' and 'pi') LtermNNNI
        -:15257:            find Rhead,  RtermS, RtermGE and Rtail
        -:15258:                such that Rhead does contain all non-imaginary terms
        -:15259:                and such that RtermGE and Rtail
        -:15260:                    either are NIL
        -:15261:                    or RtermGE is imaginary
        -:15262:                        and (RtermS is NIL or RtermSNNNI <  LtermNNNI) and LtermNNNI <= RtermGENNNI
        -:15263:            if RtermGE is NIL
        -:15264:                return R + L
        -:15265:            else
        -:15266:                if LtermNNNI < RtermGENNNI
        -:15267:                    return Rhead + RtermS + L + RtermGE + Rtail
        -:15268:                else
        -:15269:                    return Rhead + RtermS + sum(L,RtermGE) + Rtail
        -:15270:        else
        -:15271:            find Rhead,  RtermS, RtermGE and Rtail
        -:15272:                such that RtermGE and Rtail
        -:15273:                    either are NIL
        -:15274:                    or (RtermS is NIL or RtermSNN <  LtermNN) and LtermNN <= RtermGENN
        -:15275:            if RtermGE is NIL
        -:15276:                return R + L
        -:15277:            else
        -:15278:                if LtermNN < RtermGENN
        -:15279:                    return Rhead + RtermS + L + RtermGE + Rtail
        -:15280:                else
        -:15281:                    return Rhead + RtermS + sum(L,RtermGE) + Rtail
        -:15282:
        -:15283:
        -:15284:    */
        -:15285:    static const char *conc[] = {NULL,NULL,NULL,NULL};
   191028:15286:    int res = FALSE; /* 20100723 */
   191028:15287:    psk top = pkn;
        -:15288:
   191028:15289:    psk L = top->LEFT;
        -:15290:    psk Lterm,Ltail;
        -:15291:    psk LtermN,LtermI,LtermNNNI;
        -:15292:
        -:15293:    psk R;
        -:15294:    psk Rterm,Rtail;
        -:15295:    psk RtermN,RtermI,RtermNNNI;
        -:15296:
        -:15297:    int ok;
        -:15298:
        -:15299:/*    printf("%d     :%*s",level,level,"");result(pkn);printf("\n");*/
   191028:15300:    if(!is_op(L) && RAT_NUL_COMP(L))
        -:15301:        {
        -:15302:        /* 0+x -> x */
     1009:15303:        return rechtertak(top);
        -:15304:        }
        -:15305:
   190019:15306:    R = top->RIGHT;
   190019:15307:    if(!is_op(R) && RAT_NUL_COMP(R))
        -:15308:        {
        -:15309:        /*{?} x+0 => x */
      304:15310:        return linkertak(top);
        -:15311:        }
        -:15312:
   189715:15313:    if(  is_op(L)
     6075:15314:      && ((top->LEFT = expandProduct(top->LEFT,&ok)),ok)
        -:15315:      )
        -:15316:        {
      171:15317:        res = TRUE;
        -:15318:        }
   189715:15319:    if(  is_op(R)
     8894:15320:      && ((top->RIGHT = expandProduct(top->RIGHT,&ok)),ok)
        -:15321:      )
        -:15322:        { /* 20100723
        -:15323:          {?} a*b+u*(x+y) => a*b+u*x+u*y
        -:15324:          */
      817:15325:        res = TRUE;
        -:15326:        }
   189715:15327:    if(res)
        -:15328:        {
      875:15329:        (pkn)->v.fl &= ~READY;
      875:15330:        return pkn;
        -:15331:        }
   188840:15332:    rechteroperand_and_tail(top,&Rterm,&Rtail);
   188840:15333:    linkeroperand_and_tail(top,&Lterm,&Ltail);
        -:15334:    assert(Ltail == NULL);
   188840:15335:    if(RATIONAAL_COMP(Lterm))
        -:15336:        {
   182905:15337:        if(RATIONAAL_COMP(Rterm))
        -:15338:            {
   180976:15339:            conc[0] = hekje6;
   180976:15340:            if(Lterm == Rterm)
        -:15341:                {
        -:15342:                /* 7+7 -> 2*7 */ /*{?} 7+7 => 14 */
       21:15343:                adr[6] = _qmaal(&tweek,Rterm);
        -:15344:                }
        -:15345:            else
        -:15346:                {
        -:15347:                /* 4+7 -> 11 */ /*{?} 4+7 => 11 */
   180955:15348:                adr[6] = _qplus(Lterm,Rterm,0);
        -:15349:                }
        -:15350:            /*if(Ltail != NULL)
        -:15351:                {
        -:15352:                adr[5] = Ltail;
        -:15353:                conc[1] = "+\5";
        -:15354:                }
        -:15355:            else*/
   180976:15356:                conc[1] = NULL;
   180976:15357:            conc[2] = NULL;
   180976:15358:            if(Rtail != NULL)
        -:15359:                {
      525:15360:                adr[4] = Rtail;
      525:15361:                conc[/*Ltail == NULL ?*/ 1 /*: 2*/] = "+\4";
        -:15362:                }
   180976:15363:            pkn = vopb     (top,conc);
   180976:15364:            wis(adr[6]);
        -:15365:            }
        -:15366:        /*else if(Ltail != NULL)
        -:15367:            {
        -:15368:            adr[1] = Lterm;
        -:15369:            adr[2] = Ltail;
        -:15370:            adr[3] = R;
        -:15371:            pkn = opb     (top,"\1+\2+\3",NULL); / * {?} (1+a)+b => 1+a+b * /
        -:15372:            }*/
   182905:15373:        return pkn;
        -:15374:        }
     5935:15375:    else if(RATIONAAL_COMP(Rterm))
        -:15376:        {
      125:15377:        adr[1] = Rterm;
      125:15378:        adr[2] = L;
        -:15379:        assert(Rtail);
        -:15380:/*        if(Rtail)
        -:15381:            {*/
        -:15382:         /* How to get here?
        -:15383:                (1+a)*(1+b)+c+(1+d)*(1+f)
        -:15384:         The lhs (1+a)*(1+b) is not expanded before the merge starts
        -:15385:         Comparing (1+a)*(1+b) with 1, c, d, f and d*f, this product lands
        -:15386:         after d*f. Thereafter (1+a)*(1+b) is expanded, giving a 
        -:15387:         numeral 1 in the middle of the expression:
        -:15388:                1+c+d+f+d*f+(1+a)*(1+b) 
        -:15389:                1+c+d+f+d*f+1+a+b+a*b
        -:15390:         Rterm is 1+a+b+a*b
        -:15391:         Rtail is a+b+a*b
        -:15392:         */
      125:15393:            adr[3] = Rtail;
      125:15394:            return opb     (top,"\1+\2+\3",NULL);
        -:15395:          /*  }
        -:15396:        else
        -:15397:            {
        -:15398:            return opb     (top,"\1+\2",NULL);
        -:15399:            }*/
        -:15400:        }
        -:15401:
     5810:15402:    if(  kop(Lterm) == LOG
        6:15403:      && kop(Rterm) == LOG
        5:15404:      && !vgl(Lterm->LEFT,Rterm->LEFT)
        -:15405:      )
        -:15406:        {
        2:15407:        adr[1] = Lterm->LEFT;
        2:15408:        adr[2] = Lterm->RIGHT;
        2:15409:        adr[3] = Rterm->RIGHT;
        2:15410:        if(Rtail == NULL)
        1:15411:            return opb     (top,"\1\016(\2*\3)",NULL); /*{?} 2\L3+2\L9 => 4+2\L27/16 */
        -:15412:        else
        -:15413:            {
        1:15414:            adr[4] = Rtail;
        1:15415:            return opb     (top,"\1\016(\2*\3)+\4",NULL); /*{?} 2\L3+2\L9+3\L123 => 8+2\L27/16+3\L41/27 */
        -:15416:            }
        -:15417:        }
        -:15418:
     5808:15419:    splitProduct_number_im_rest(Lterm,&LtermN,&LtermI,&LtermNNNI);
        -:15420:
     5808:15421:    if(LtermI)
        -:15422:        {
       60:15423:        ppsk loper = &pkn;
       60:15424:        splitProduct_number_im_rest(Rterm,&RtermN,&RtermI,&RtermNNNI);
      121:15425:        while(  RtermI == NULL
        2:15426:             && kop((*loper)->RIGHT) == PLUS
        -:15427:             )
        -:15428:            {
        1:15429:            loper = &(*loper)->RIGHT;
        1:15430:            *loper = prive(*loper);
        1:15431:            rechteroperand_and_tail((*loper),&Rterm,&Rtail);
        1:15432:            splitProduct_number_im_rest(Rterm,&RtermN,&RtermI,&RtermNNNI);/*{?} i*x+-i*x+a => a */
        -:15433:            }
       60:15434:        if(RtermI != NULL)
        -:15435:            {                        /*{?} i*x+-i*x => 0 */
        -:15436:            int indx;
        -:15437:            int dif;
       59:15438:            if(LtermNNNI == NULL)
        -:15439:                {
       14:15440:                dif = RtermNNNI == NULL ? 0 : -1;/*{?} i+-i*x => i+-i*x */
        -:15441:                                                 /*{?} i+-i => 0 */
        -:15442:                }
        -:15443:            /*else if(RtermNNNI == NULL)
        -:15444:                {
        -:15445:                dif = 1; / *{?} i*x+-i => -i+i*x * /
        -:15446:                }*/
        -:15447:            else
        -:15448:                {
        -:15449:                assert(RtermNNNI != NULL);
       45:15450:                dif = vgl(LtermNNNI,RtermNNNI);
        -:15451:                assert(dif <= 0 || kop((*loper)->RIGHT) != PLUS);
        -:15452:                /*while(  (dif = vgl(LtermNNNI,RtermNNNI)) > 0
        -:15453:                     && kop((*loper)->RIGHT) == PLUS
        -:15454:                     )
        -:15455:                    {
        -:15456:                    loper = &(*loper)->RIGHT; / *{?} i*x+i*y+i*z => i*x+i*y+i*z * /
        -:15457:                    *loper = prive(*loper);
        -:15458:                    rechteroperand_and_tail((*loper),&Rterm,&Rtail);
        -:15459:                    splitProduct_number_im_rest(Rterm,&RtermN,&RtermI,&RtermNNNI);
        -:15460:                    }*/
        -:15461:                }
       59:15462:            if(dif == 0)
        -:15463:                {                        /*{?} i*x+-i*x => 0 */
       26:15464:                if(RtermN)
        -:15465:                    {
        8:15466:                    adr[2] = RtermN; /*{?} i*x+3*i*x => 4*i*x */
        8:15467:                    if(LtermN == NULL)
        -:15468:                        {
        -:15469:                        /* a+n*a */ /*{?} i*x+3*i*x => 4*i*x */
        4:15470:                        if(HAS_MINUS_SIGN(LtermI))
        -:15471:                            {  /*{?} -i*x+3*i*x => 2*i*x */
        2:15472:                            if(HAS_MINUS_SIGN(RtermI))
        -:15473:                                {
        1:15474:                                conc[0] = "(1+\2)*-i";/*{?} -i*x+3*-i*x => 4*-i*x */
        -:15475:                                }
        -:15476:                            else
        -:15477:                                {
        1:15478:                                conc[0] = "(-1+\2)*i";/*{?} -i*x+3*i*x => 2*i*x */
        -:15479:                                }
        -:15480:                            }
        2:15481:                        else if(HAS_MINUS_SIGN(RtermI))
        -:15482:                            {
        1:15483:                            conc[0] = "(-1+\2)*-i"; /*{?} i*x+3*-i*x => 2*-i*x */
        -:15484:                            }
        -:15485:                        else
        -:15486:                            {
        1:15487:                            conc[0] = "(1+\2)*i";/*{?} i*x+3*i*x => 4*i*x */
        -:15488:                            }
        -:15489:                        }
        -:15490:                    /* (1+n)*a */
        -:15491:                    else
        -:15492:                        {
        -:15493:                        /* n*a+m*a */ /*{?} 3*-i*x+-3*i*x => 6*-i*x */
        4:15494:                        adr[3] = LtermN;
        4:15495:                        if(HAS_MINUS_SIGN(LtermI))
        -:15496:                            {
        2:15497:                            if(HAS_MINUS_SIGN(RtermI))
        -:15498:                                {
        1:15499:                                conc[0] = "(\3+\2)*-i";/*{?} 3*-i*x+-3*i*x => 6*-i*x */
        -:15500:                                }
        -:15501:                            else
        -:15502:                                {
        1:15503:                                conc[0] = "(-1*\3+\2)*i";/*{?} 3*-i*x+-3*-i*x => 0 */
        -:15504:                                }
        -:15505:                            }
        2:15506:                        else if(HAS_MINUS_SIGN(RtermI))
        -:15507:                            {
        1:15508:                            conc[0] = "(\3+-1*\2)*i"; /*{?} 3*i*x+-3*i*x => 0 */
        -:15509:                            }
        -:15510:                        else
        -:15511:                            {
        1:15512:                            conc[0] = "(\3+\2)*i"; /*{?} 3*i*x+4*i*x => 7*i*x */
        -:15513:                            }
        -:15514:                        /* (n+m)*a */
        -:15515:                        }
        -:15516:                    }
        -:15517:                else
        -:15518:                    {                        /*{?} i*x+-i*x => 0 */
       18:15519:                    adr[1] = LtermNNNI;
       18:15520:                    if(LtermN != NULL)
        -:15521:                        {
        -:15522:                        /* m*a+a */
        5:15523:                        adr[2] = LtermN; /*{?} 3*i*x+i*x => 4*i*x */
        5:15524:                        if(HAS_MINUS_SIGN(LtermI))
        -:15525:
        3:15526:                            if(HAS_MINUS_SIGN(RtermI))
        -:15527:                                {
        1:15528:                                conc[0] = "(1+\2)*-i";/*{?} 3*-i*x+-i*x => 4*-i*x */
        -:15529:                                }
        -:15530:                            else
        -:15531:                                {
        2:15532:                                conc[0] = "(-1+\2)*-i";/*{?} 3*-i*x+i*x => 2*-i*x */
        -:15533:                                }
        -:15534:
        2:15535:                        else if(HAS_MINUS_SIGN(RtermI))
        -:15536:                            {
        1:15537:                            conc[0] = "(-1+\2)*i"; /*{?} 3*i*x+-i*x => 2*i*x */
        -:15538:                            }
        -:15539:                        else
        -:15540:                            {
        1:15541:                            conc[0] = "(1+\2)*i"; /*{?} 3*i*x+i*x => 4*i*x */
        -:15542:                            }
        -:15543:                        /* (1+m)*a */
        -:15544:                        }
        -:15545:                    else
        -:15546:                        {
        -:15547:                        /* a+a */                        /*{?} i*x+-i*x => 0 */
       13:15548:                        if(HAS_MINUS_SIGN(LtermI))
        -:15549:
        5:15550:                            if(HAS_MINUS_SIGN(RtermI))
        -:15551:                                {
        3:15552:                                conc[0] = "2*-i"; /*{?} -i+-i => 2*-i */
        -:15553:                                }
        -:15554:                            else
        -:15555:                                {
        2:15556:                                conc[0] = "0"; /*{?} -i+i => 0 */
        -:15557:                                }
        -:15558:
        8:15559:                        else if(HAS_MINUS_SIGN(RtermI))
        -:15560:                            {
        7:15561:                            conc[0] = "0";                        /*{?} i*x+-i*x => 0 */
        -:15562:                            }
        -:15563:                        else
        -:15564:                            {
        1:15565:                            conc[0] = "2*i"; /*{?} i+i => 2*i */
        -:15566:                            }
        -:15567:                        }
        -:15568:                    /* 2*a */
        -:15569:                    }
       26:15570:                if(LtermNNNI != NULL)
        -:15571:                    {                        /*{?} i*x+-i*x => 0 */
       18:15572:                    adr[1] = RtermNNNI;
       18:15573:                    conc[1] = "*\1";
       18:15574:                    indx = 2;
        -:15575:                    }
        -:15576:                else
        8:15577:                    indx = 1; /*{?} i+-i => 0 */
        -:15578:                /*if(Ltail != NULL)
        -:15579:                    {
        -:15580:                    adr[5] = Ltail; / * {?} (i+i*x)+-i => i*x * /
        -:15581:                    conc[indx++] = "+\5";
        -:15582:                    }*/
       26:15583:                if(Rtail != NULL)
        -:15584:                    {
        2:15585:                    adr[4] = Rtail; /*{?} -i+-i+i*y => 2*-i+i*y */
        2:15586:                    conc[indx++] = "+\4";
        -:15587:                    }
       26:15588:                conc[indx] = NULL;                        /*{?} i*x+-i*x => 0 */
       26:15589:                (*loper)->RIGHT = vopb((*loper)->RIGHT,conc);
        -:15590:                /*evalueer(loper->RIGHT);*/
       26:15591:                if(loper != &pkn)
        -:15592:                    {
        1:15593:                    (*loper)->v.fl &= ~READY;/*{?} i*x+-i*x+a => a */
        1:15594:                    *loper = eval(*loper);
        -:15595:                    }
       26:15596:                return rechtertak(top);                        /*{?} i*x+-i*x => 0 */
        -:15597:                }
        -:15598:            assert(dif <= 0);
        -:15599:            assert((*loper) == top);
        -:15600:            assert(Ltail == NULL);
        -:15601:/*          else if(dif > 0) / *{?} b+a => a+b * /
        -:15602:                {
        -:15603:                adr[1] = Rterm; / *{?} i*x+-i => -i+i*x * /
        -:15604:                adr[2] = L;
        -:15605:                (*loper)->RIGHT = opb((*loper)->RIGHT,"\1+\2",NULL);
        -:15606:                (*loper)->RIGHT->v.fl |= READY;
        -:15607:                / *
        -:15608:                (*loper)->RIGHT = eval((*loper)->RIGHT);
        -:15609:                * / 
        -:15610:                return rechtertak(top);
        -:15611:                }
        -:15612:            else if((*loper) != top) / *{?} b+a+c => a+b+c * /
        -:15613:                {
        -:15614:                adr[1] = L;
        -:15615:                adr[2] = (*loper)->RIGHT;
        -:15616:                (*loper)->RIGHT = opb((*loper)->RIGHT,"\1+\2",NULL);
        -:15617:                (*loper)->RIGHT = eval((*loper)->RIGHT);
        -:15618:                return rechtertak(top);          / *{?} i*x+i*y+i*z => i*x+i*y+i*z * /
        -:15619:                }*/
        -:15620:            /*else if(Ltail != NULL) / *{?} (a+c+f)+b+d+g => a+b+c+d+f+g * /
        -:15621:                {
        -:15622:                adr[1] = Lterm;
        -:15623:                adr[2] = Ltail;
        -:15624:                adr[3] = top->RIGHT;
        -:15625:                return opb(top,"\1+\2+\3",NULL);      / *{?} (i*x+i*z)+i*y => i*x+i*y+i*z * /
        -:15626:                }*/
        -:15627:            }
        -:15628:        else  /* LtermI != NULL && RtermI == NULL */
        -:15629:            {
        1:15630:            adr[1] = Rterm; /*{?} i*x+-i*x+a => a */
        1:15631:            adr[2] = L;
        1:15632:            (*loper)->RIGHT = opb((*loper)->RIGHT,"\1+\2",NULL);
        1:15633:            (*loper)->RIGHT->v.fl |= READY;
        -:15634:            /*
        -:15635:            (*loper)->RIGHT = eval((*loper)->RIGHT);
        -:15636:            */
        1:15637:            return rechtertak(top);
        -:15638:            }
        -:15639:        }
        -:15640:    else /* LtermI == NULL */
        -:15641:        {
     5748:15642:        ppsk loper = &pkn;
     5748:15643:        int dif = 1;
        -:15644:        assert(LtermNNNI != NULL);
     5748:15645:        splitProduct_number_im_rest(Rterm,&RtermN,&RtermI,&RtermNNNI);
    11836:15646:        while(  RtermNNNI != NULL
     6087:15647:             && RtermI == NULL
     6085:15648:             && (dif = vgl(LtermNNNI,RtermNNNI)) > 0
      349:15649:             && kop((*loper)->RIGHT) == PLUS
        -:15650:             )
        -:15651:            {
      340:15652:            loper = &(*loper)->RIGHT; /*{?} (b^3+c^3)+b^3+c+b^3 => c+3*b^3+c^3 */
      340:15653:            *loper = prive(*loper);
      340:15654:            rechteroperand_and_tail((*loper),&Rterm,&Rtail);
      340:15655:            splitProduct_number_im_rest(Rterm,&RtermN,&RtermI,&RtermNNNI);
        -:15656:            }
     5748:15657:        if(RtermI != NULL)
        3:15658:            dif = -1; /*{?} (-i+a)+-i => a+2*-i */
     5748:15659:        if(dif == 0)
        -:15660:            {
      351:15661:            if(RtermN)
        -:15662:                {
      303:15663:                adr[1] = RtermNNNI;
      303:15664:                adr[2] = RtermN;
      303:15665:                if(LtermN == NULL)
        -:15666:                    /*{?} a+n*a => a+a*n */
       64:15667:                    conc[0] = "(1+\2)*\1";
        -:15668:                /* (1+n)*a */
        -:15669:                else
        -:15670:                    {
        -:15671:                    /*{?} n*a+m*a => a*m+a*n */ /*{?} 7*a+9*a => 16*a */
      239:15672:                    adr[3] = LtermN;
      239:15673:                    conc[0] = "(\3+\2)*\1";
        -:15674:                    /* (n+m)*a */
        -:15675:                    }
        -:15676:                }
        -:15677:            else
        -:15678:                {
       48:15679:                adr[1] = LtermNNNI;
       48:15680:                if(LtermN != NULL)
        -:15681:                    {
        -:15682:                    /* m*a+a */
       32:15683:                    adr[2] = LtermN;
       32:15684:                    conc[0] = "(1+\2)*\1"; /*{?} 3*a+a => 4*a */
        -:15685:                    /* (1+m)*a */
        -:15686:                    }
        -:15687:                else
        -:15688:                    {
        -:15689:                    /*{?} a+a => 2*a */
       16:15690:                    conc[0] = "2*\1";
        -:15691:                    }
        -:15692:                /* 2*a */
        -:15693:                }
        -:15694:            assert(Ltail == NULL);
        -:15695:            /*if(Ltail != NULL)
        -:15696:                {
        -:15697:                adr[5] = Ltail;
        -:15698:                conc[1] = "+\5";
        -:15699:                }
        -:15700:            else*/
        -:15701:                {
      351:15702:                conc[1] = NULL;
        -:15703:                }
      351:15704:            conc[2] = NULL;
      351:15705:            if(Rtail != NULL)
        -:15706:                {
      114:15707:                adr[4] = Rtail;
      114:15708:                conc[/*Ltail == NULL ?*/ 1 /*: 2*/] = "+\4";
        -:15709:                }
      351:15710:            (*loper)->RIGHT = vopb((*loper)->RIGHT,conc);
        -:15711:            /*(*loper)->RIGHT = eval(loper->RIGHT);*/
      351:15712:            if(loper != &pkn)
        -:15713:                {
       36:15714:                (*loper)->v.fl &= ~READY;
        -:15715:                /*{?} (b^3+c^3)+b^3+c+b^3 => c+3*b^3+c^3 */
        -:15716:                /* This would evaluate to c+(1+2)*b^3+c^3 if READY flag wasn't turned off */
        -:15717:                /* Correct evaluation: c+3*b^3+c^3 */
       36:15718:                *loper = eval(*loper);
        -:15719:                }
      351:15720:            return rechtertak(top);
        -:15721:            }
     5397:15722:        else if(dif > 0)  /*{?} b+a => a+b */
        -:15723:            {
        9:15724:            adr[1] = Rterm;
        9:15725:            adr[2] = L;
        9:15726:            (*loper)->RIGHT = opb((*loper)->RIGHT,"\1+\2",NULL);
        9:15727:            (*loper)->RIGHT->v.fl |= READY;
        -:15728:            /*(*loper)->RIGHT = eval((*loper)->RIGHT);*/
        9:15729:            return rechtertak(top);
        -:15730:            }
     5388:15731:        else if((*loper) != top) /* b + a + c */
        -:15732:            {
      208:15733:            adr[1] = L;
      208:15734:            adr[2] = (*loper)->RIGHT;
      208:15735:            (*loper)->RIGHT = opb((*loper)->RIGHT,"\1+\2",NULL);
      208:15736:            (*loper)->RIGHT = eval((*loper)->RIGHT);
      208:15737:            return rechtertak(top);          /* (1+a+b+c)^30+1 */
        -:15738:            }
        -:15739:        assert(Ltail == NULL);
        -:15740:        /*else if(Ltail != NULL) / *{?} (a+c+f)+b+d+g => a+b+c+d+f+g * /
        -:15741:            {
        -:15742:            adr[1] = Lterm;
        -:15743:            adr[2] = Ltail;
        -:15744:            adr[3] = top->RIGHT;
        -:15745:            return opb(top,"\1+\2+\3",NULL);
        -:15746:            }*/
        -:15747:        }
     5213:15748:    return pkn;
        -:15749:    }
        -:15750:
    15446:15751:static psk substmaal(psk pkn)
        -:15752:    {
        -:15753:    static const char *conc[] = {NULL,NULL,NULL,NULL};
        -:15754:    psk rkn,lkn;
        -:15755:    psk rvar,lvar;
        -:15756:    psk temp,llknoop,rlknoop;
        -:15757:    int knverschil;
    15446:15758:    rkn = rechteroperand(pkn);
        -:15759:
    15446:15760:    if(is_op(rkn))
     3585:15761:        rvar = NULL; /* (f.e)*(y.s) */
        -:15762:    else
        -:15763:        {
    11861:15764:        if(IS_EEN(rkn)) /* 20110221 */
        -:15765:            {
     2561:15766:            return linkertak(pkn); /*{?} (a=7)&!(a*1) => 7 */
        -:15767:            }
     9300:15768:        else if(RAT_NUL(rkn))/*{?} -1*140/1000 => -7/50 */
        -:15769:            {
       44:15770:            wis(pkn); /*{?} x*0 => 0 */
       44:15771:            return copievan(&nulk);
        -:15772:            }
     9256:15773:        rvar = rkn; /*{?} a*a => a^2 */
        -:15774:        }
        -:15775:
    12841:15776:    lkn = pkn->LEFT;
    12841:15777:    if(!is_op(lkn))
        -:15778:        {
    11521:15779:        if(RAT_NUL(lkn)) /*{?} -1*140/1000 => -7/50 */
        -:15780:            {
      307:15781:            wis(pkn); /*{?} 0*x => 0 */
      307:15782:            return copievan(&nulk);
        -:15783:            }
    11214:15784:        lvar = lkn;
        -:15785:
    11214:15786:        if(IS_EEN(lkn))
        -:15787:            {
      941:15788:            return rechtertak(pkn); /*{?} 1*-1 => -1 */
        -:15789:            }
    10273:15790:        else if(RATIONAAL_COMP(lkn) && rvar)
        -:15791:            {
     5078:15792:            if(RATIONAAL_COMP(rkn))
        -:15793:                {
     2200:15794:                if(rkn == lkn)
       81:15795:                    lvar = (pkn->LEFT = prive(lkn)); /*{?} 1/10*1/10 => 1/100 */
     2200:15796:                conc[0] = hekje6;
     2200:15797:                adr[6] = _qmaal(rvar,lvar);
     2200:15798:                if(rkn == pkn->RIGHT)
     1410:15799:                    conc[1] = NULL; /*{?} -1*140/1000 => -7/50 */
        -:15800:                else
        -:15801:                    {
      790:15802:                    adr[1] = pkn->RIGHT->RIGHT; /*{?} -1*1/4*e^(2*i*x) => -1/4*e^(2*i*x) */
      790:15803:                    conc[1] = "*\1";
        -:15804:                    }
     2200:15805:                pkn = vopb(pkn,conc);
     2200:15806:                wis(adr[6]);
     2200:15807:                return pkn;
        -:15808:                }
        -:15809:            else
        -:15810:                {
     2878:15811:                if(PLOBJ(rkn) == IM && RAT_NEG_COMP(lkn))
        -:15812:                    {
       12:15813:                    conc[0] = "(\2*\3)";
       12:15814:                    adr[2] = _qmaalmineen(lkn);
       12:15815:                    adr[3] = _qmaalmineen(rkn);
       12:15816:                    if(rkn == pkn->RIGHT)
        8:15817:                        conc[1] = NULL; /*{?} -1*i => -i */
        -:15818:                    else
        -:15819:                        {
        4:15820:                        adr[1] = pkn->RIGHT->RIGHT; /*{?} -3*i*x => 3*-i*x */
        4:15821:                        conc[1] = "*\1";
        -:15822:                        }
       12:15823:                    pkn = vopb(pkn,conc);
       12:15824:                    wis(adr[2]);
       12:15825:                    wis(adr[3]);
       12:15826:                    return pkn;
        -:15827:                    }
        -:15828:                }
        -:15829:            }
        -:15830:        }
        -:15831:
        -:15832:
     9381:15833:    rlknoop = kop(rkn) == EXP ? rkn->LEFT : rkn; /*{?} (f.e)*(y.s) => (f.e)*(y.s) */
     9381:15834:    llknoop = kop(lkn) == EXP ? lkn->LEFT : lkn;
     9381:15835:    if((knverschil = vgl(llknoop,rlknoop)) == 0)
        -:15836:        {
        -:15837:        /* a^n*a^m */
      587:15838:        if(rlknoop != rkn)
        -:15839:            {
      320:15840:            adr[1] = rlknoop; /*{?} e^(i*x)*e^(-i*x) => 1 */
      320:15841:            adr[2] = rkn->RIGHT;
      320:15842:            if(llknoop == lkn)
        -:15843:                {
      153:15844:                conc[0] = "\1^(1+\2)"; /*{?} a*a^n => a^(1+n) */
        -:15845:                }/* a^(1+n) */
        -:15846:            else
        -:15847:                {
        -:15848:                /* a^n*a^m */
      167:15849:                adr[3] = lkn->RIGHT; /*{?} e^(i*x)*e^(-i*x) => 1 */
      167:15850:                conc[0] = "\1^(\3+\2)";
        -:15851:                /* a^(n+m) */
        -:15852:                }
        -:15853:            }
        -:15854:        else
        -:15855:            {
      267:15856:            if(llknoop != lkn)
        -:15857:                {
      152:15858:                adr[1] = llknoop;     /*{?} a^m*a => a^(1+m) */
      152:15859:                adr[2] = lkn->RIGHT;
      152:15860:                conc[0] = "\1^(1+\2)";
        -:15861:                /* a^(m+1) */
        -:15862:                }
        -:15863:            else
        -:15864:                {
        -:15865:                /*{?} a*a => a^2 */
      115:15866:                adr[1] = llknoop; /*{?} i*i*(-1/2*e^(i*a)+1/2*e^(-i*a))*(-1/2*e^(i*b)+1/2*e^(-i*b)) => -1*(-1/2*e^(i*a)+1/2*e^(-i*a))*(-1/2*e^(i*b)+1/2*e^(-i*b)) */
      115:15867:                conc[0] = "\1^2";
        -:15868:                /* a^2 */
        -:15869:                }
        -:15870:            }
      587:15871:        if(rkn != (temp = pkn->RIGHT))
        -:15872:            {
      352:15873:            adr[4] = temp->RIGHT; /*{?} i*i*(-1/2*e^(i*a)+1/2*e^(-i*a))*(-1/2*e^(i*b)+1/2*e^(-i*b)) => -1*(-1/2*e^(i*a)+1/2*e^(-i*a))*(-1/2*e^(i*b)+1/2*e^(-i*b)) */
      352:15874:            conc[1] = "*\4";
        -:15875:            }
        -:15876:        else
      235:15877:            conc[1] = NULL; /*{?} e^(i*x)*e^(-i*x) => 1 */
      587:15878:        return vopb(pkn,(const char **)conc);
        -:15879:        }
        -:15880:    else
        -:15881:        {
        -:15882:        int graad;
     8794:15883:        graad = getal_graad(rlknoop) - getal_graad(llknoop); /*{?} (f.e)*(y.s) => (f.e)*(y.s) */
     8794:15884:        if(graad > 0
     8110:15885:        || (graad == 0 && (knverschil > 0)))
        -:15886:            {
        -:15887:            /* b^n*a^m */
        -:15888:            /* l^n*a^m */
      685:15889:            if((temp = pkn->RIGHT) == rkn)
        -:15890:                {
       65:15891:                pkn->RIGHT = lkn; /*{?} x*2 => 2*x */
       65:15892:                pkn->LEFT = rkn;
       65:15893:                pkn->v.fl &= ~READY;
        -:15894:                }
        -:15895:            else
        -:15896:                {
      620:15897:                adr[1] = lkn; /*{?} i*2*x => 2*i*x */
      620:15898:                adr[2] = temp->LEFT;
      620:15899:                adr[3] = temp->RIGHT;
      620:15900:                pkn = opb(pkn,"\2*\1*\3",NULL);
        -:15901:                }
      685:15902:            return pkn;
        -:15903:            /* a^m*b^n */
        -:15904:            /* a^m*l^n */
        -:15905:            }
     8109:15906:        else if(PLOBJ(rlknoop) == IM)
        -:15907:            {
       57:15908:            if(PLOBJ(llknoop) == IM) /*{?} -1*i^1/3 => -i^5/3 */
        -:15909:                {
        -:15910:                /*{?} i^n*-i^m => i^(-1*m+n) */
        6:15911:                if(rlknoop != rkn)
        -:15912:                    {
        3:15913:                    adr[1] = llknoop;
        3:15914:                    adr[2] = rkn->RIGHT;
        3:15915:                    if(llknoop == lkn)
        -:15916:                        /*{?} i*-i^n => i^(1+-1*n) */
        1:15917:                        conc[0] = "\1^(1+-1*\2)";
        -:15918:                        /* i^(1-n) */
        -:15919:                    else
        -:15920:                        {
        2:15921:                        adr[3] = lkn->RIGHT; /*{?} i^n*-i^m => i^(-1*m+n) */
        2:15922:                        conc[0] = "\1^(\3+-1*\2)";
        -:15923:                        /* i^(n-m) */
        -:15924:                        }
        -:15925:                    }
        -:15926:                else
        -:15927:                    {
        3:15928:                    if(llknoop != lkn)
        -:15929:                        {
        -:15930:                        /*{?} i^m*-i => i^(-1+m) */
        1:15931:                        adr[1] = llknoop;
        1:15932:                        adr[2] = lkn->RIGHT;
        1:15933:                        conc[0] = "\1^(-1+\2)";
        -:15934:                        /* i^(m-1) */
        -:15935:                        }
        -:15936:                    else
        -:15937:                        {
        -:15938:                        /*{?} i*-i => 1 */
        2:15939:                        conc[0] = "1";
        -:15940:                        /* 1 */
        -:15941:                        }
        -:15942:                    }
        -:15943:                }
       51:15944:            else if(  RAT_NEG_COMP(llknoop)
        -:15945:                /* -n*i^m -> n*-i^(2+m) */
        -:15946:                /*{?} -7*i^9 => 7*i */ /*{!} 7*-i^11 */
        -:15947:                /* -n*-i^m -> n*i^(2+m) */
        -:15948:                /*{?} -7*-i^9 => 7*-i */ /*{!}-> 7*i^11 */
        1:15949:                   && rlknoop != rkn
        1:15950:                   && llknoop == lkn
        -:15951:                   )
        -:15952:                { /*{?} -1*i^1/3 => -i^5/3 */
        1:15953:                adr[1] = llknoop;
        1:15954:                adr[2] = rkn->LEFT;
        1:15955:                adr[3] = rkn->RIGHT;
        1:15956:                adr[4] = &tweek;
        1:15957:                conc[0] = "(-1*\1)*\2^(\3+\4)";
        -:15958:                }
        -:15959:            else
       50:15960:                return pkn; /*{?} 2*i*x => 2*i*x */
        7:15961:            if(rkn != (temp = pkn->RIGHT))
        -:15962:                {
        1:15963:                adr[4] = temp->RIGHT; /*{?} i^n*-i^m*z => i^(-1*m+n)*z */
        1:15964:                conc[1] = "*\4";
        -:15965:                }
        -:15966:            else
        6:15967:                conc[1] = NULL; /*{?} -1*i^1/3 => -i^5/3 */ /*{?} i^n*-i^m => i^(-1*m+n) */
        7:15968:            return vopb(pkn,(const char **)conc);
        -:15969:            }
        -:15970:        else
     8052:15971:            return pkn; /*{?} (f.e)*(y.s) => (f.e)*(y.s) */
        -:15972:        }
        -:15973:    }
        -:15974:
   127493:15975:static int rechtsbrengen(psk kn)
        -:15976:    {
        -:15977:    /* (a*b*c*d)*a*b*c*d -> a*b*c*d*a*b*c*d */
        -:15978:    psk lknoop;
        -:15979:    int gedaan;
   127493:15980:    gedaan = FALSE;
   255774:15981:    for(;kop(lknoop = kn->LEFT) == kop(kn);)
        -:15982:        {
      788:15983:        lknoop = prive(lknoop);
      788:15984:        lknoop->v.fl &= ~READY;
      788:15985:        kn->LEFT = lknoop->LEFT;
      788:15986:        lknoop->LEFT = lknoop->RIGHT;
      788:15987:        lknoop->RIGHT = kn->RIGHT;
      788:15988:        kn->v.fl &= ~READY;
      788:15989:        kn->RIGHT = lknoop;
      788:15990:        kn = lknoop;
      788:15991:        gedaan = TRUE;
        -:15992:        }
   127493:15993:    return gedaan;
        -:15994:    }
        -:15995:/*
        -:15996:       1*
        -:15997:       / \
        -:15998:      /   \
        -:15999:     /     \
        -:16000:   2*      3*
        -:16001:   / \     / \
        -:16002:  a   x    b  c
        -:16003:
        -:16004:lhead = a
        -:16005:ltail = x
        -:16006:rhead = b
        -:16007:rtail = c
        -:16008:
        -:16009:repol = √ò
        -:16010:loper = (a * x) * b * c
        -:16011:lloper = a * x
        -:16012:
        -:16013:  2*
        -:16014:  / \
        -:16015: a
        -:16016: repol = a*√ò
        -:16017:
        -:16018:
        -:16019:             1*
        -:16020:             / \
        -:16021:            x  3*
        -:16022:               / \
        -:16023:              b   c
        -:16024:*/
   191028:16025:static int vglplus(psk kn1,psk kn2)
        -:16026:    {
   191028:16027:    if(RATIONAAL_COMP(kn2))
        -:16028:        {
   182325:16029:        if(RATIONAAL_COMP(kn1))
   181506:16030:            return 0;
      819:16031:        return 1; /* switch places */
        -:16032:        }
     8703:16033:    else if(RATIONAAL_COMP(kn1))
     1997:16034:        return -1;
        -:16035:    else
        -:16036:        {
        -:16037:        psk N1;
        -:16038:        psk I1;
        -:16039:        psk NNNI1;
        -:16040:        psk N2;
        -:16041:        psk I2;
        -:16042:        psk NNNI2;
     6706:16043:        splitProduct_number_im_rest(kn1,&N1,&I1,&NNNI1);
     6706:16044:        splitProduct_number_im_rest(kn2,&N2,&I2,&NNNI2);
     6706:16045:        if(I1 != NULL && I2 == NULL)
        4:16046:            return 1; /* switch places: imaginary terms after real terms */
     6702:16047:        if(NNNI2 == NULL)
        -:16048:            {
       11:16049:            if(NNNI1 != NULL)
        4:16050:                return 1;
        7:16051:            return 0;
        -:16052:            }
     6691:16053:        else if(NNNI1 == NULL)
        5:16054:            return -1;
        -:16055:        else
        -:16056:            {
     6686:16057:            int diff = vgl(NNNI1,NNNI2);
     6686:16058:            if(diff > 0)
        -:16059:                {
     1968:16060:                return 1; /* switch places */
        -:16061:                }
     4718:16062:            else if(diff < 0)
        -:16063:                {
     4400:16064:                return -1;
        -:16065:                }
        -:16066:            else
        -:16067:                {
      318:16068:                return 0;
        -:16069:                }
        -:16070:            }
        -:16071:        }
        -:16072:    }
        -:16073:
    15446:16074:static int vglmaal(psk kn1,psk kn2)
        -:16075:    {
        -:16076:    int diff;
    15446:16077:    if(kop(kn1) == EXP)
     1424:16078:        kn1 = kn1->LEFT;
    15446:16079:    if(kop(kn2) == EXP)
     1774:16080:        kn2 = kn2->LEFT;
        -:16081:
    15446:16082:    diff = getal_graad(kn2);
    15446:16083:    if(diff != 4)
     8245:16084:        diff -= getal_graad(kn1);
        -:16085:    else
        -:16086:        {
     7201:16087:        diff = -getal_graad(kn1);
     7201:16088:        if(!diff)
     3286:16089:            return 0; /* two numbers */
        -:16090:        }
    12160:16091:    if(diff > 0)
       70:16092:        return 1; /* switch places */
    12090:16093:    else if(diff == 0)
        -:16094:        {
     3522:16095:        diff = vgl(kn1,kn2);
     3522:16096:        if(diff > 0)
        -:16097:            {
     1087:16098:            return 1; /* switch places */
        -:16099:            }
     2435:16100:        else if(diff < 0)
        -:16101:            {
     1851:16102:            return -1;
        -:16103:            }
        -:16104:        else
        -:16105:            {
      584:16106:            return 0;
        -:16107:            }
        -:16108:        }
        -:16109:    else
        -:16110:        {
     8568:16111:        return -1;
        -:16112:        }
        -:16113:    }
        -:16114:
   194820:16115:static psk merge
        -:16116:            (psk pkn
        -:16117:            ,int (*comp)(psk,psk)
        -:16118:            ,psk (*combine)(psk)
        -:16119:#if EXPAND
        -:16120:            ,psk (*expand)(psk,int*)
        -:16121:#endif
        -:16122:            )
        -:16123:    {
        -:16124:    psk lhead,ltail,rhead,rtail;
   194820:16125:    psk Repol = &nilk; /* Will contain all evaluated nodes in inverse order.*/
        -:16126:    psk tmp;
        -:16127:    /*++level;
        -:16128:    printf("%dMerge:%*s",level,level,"");result(pkn);printf("\n");*/
        -:16129:    for(;;)
        -:16130:        {/* traverse from left to right
        -:16131:            to evaluate left side branches
        -:16132:         */
        -:16133:#if EXPAND
        -:16134:        Boolean ok;
        -:16135:#endif
   199443:16136:        pkn = prive(pkn);
        -:16137:        assert(!shared(pkn));
   199443:16138:        pkn->v.fl |= READY;
        -:16139:#if EXPAND
        -:16140:        do
        -:16141:            {
        -:16142:            pkn->LEFT = eval(pkn->LEFT);
        -:16143:            pkn->LEFT = expand(pkn->LEFT,&ok);
        -:16144:            }
        -:16145:            while(ok);
        -:16146:#else
   199443:16147:        pkn->LEFT = eval(pkn->LEFT);
        -:16148:#endif
   199443:16149:        tmp = pkn->RIGHT;
   199443:16150:        if(tmp->v.fl & READY)
        -:16151:            {
   179172:16152:            break;
        -:16153:            }
    20271:16154:        if(  !is_op(tmp)
     8314:16155:          || kop(pkn) != kop(tmp)
        -:16156:          )
        -:16157:            {
        -:16158:#if EXPAND
        -:16159:            do
        -:16160:                {
        -:16161:                tmp = eval(tmp);
        -:16162:                tmp = expand(tmp,&ok);
        -:16163:                }
        -:16164:                while(ok);
        -:16165:            pkn->RIGHT = tmp;
        -:16166:#else
    15648:16167:            pkn->RIGHT = eval(tmp);
        -:16168:#endif
    15648:16169:            break;
        -:16170:            }
     4623:16171:        pkn->RIGHT = Repol;
     4623:16172:        Repol = pkn;
     4623:16173:        pkn = tmp;
     4623:16174:        }
        -:16175:    /*printf("%d xxxx:%*s",level,level,"");result(pkn);printf("\n");*/
        -:16176:    for(;;)
        -:16177:        { /* From right to left, prepend sorted elements to result */
   199443:16178:        psk repol = &nilk; /*Will contain branches in inverse sorted order*/
   199443:16179:        psk L = linkeroperand_and_tail(pkn,&lhead,&ltail);
   199443:16180:        psk R = rechteroperand_and_tail(pkn,&rhead,&rtail);
        -:16181:        for(;;)
        -:16182:            { /* From right to left, prepend smallest of lhs and rhs
        -:16183:                 to repol
        -:16184:              */
        -:16185:            assert(rhead->v.fl & READY);
        -:16186:            assert((L == lhead && ltail == NULL) || L->RIGHT == ltail);
        -:16187:            assert((L == lhead && ltail == NULL) || L->LEFT == lhead);
        -:16188:            assert(pkn->LEFT == L);
        -:16189:            assert((R == rhead && rtail == NULL) || R->RIGHT == rtail);
        -:16190:            assert((R == rhead && rtail == NULL) || R->LEFT == rhead);
        -:16191:            assert(pkn->RIGHT == R);
        -:16192:            assert(L->v.fl & READY); /* 20120916 */
        -:16193:            assert(pkn->RIGHT->v.fl & READY); /* 20120916 */
   206474:16194:            if(comp(lhead,rhead) <= 0) /* a * b */
        -:16195:                {
        -:16196:                /*printf("<= "); */
   202522:16197:                if(ltail == NULL)   /* a * (b*c) */
        -:16198:                    {
        -:16199:                    assert(pkn->RIGHT->v.fl & READY); /* 20120916 */
        -:16200:                    /*if(pkn->RIGHT->v.fl & READY)
        -:16201:                        {*/
   197760:16202:                        break;
        -:16203:                        /*}
        -:16204:                    else
        -:16205:                        { / * unreachable * /
        -:16206:                        assert(!shared(pkn));
        -:16207:                        pkn->RIGHT = repol;
        -:16208:                        repol = pkn;
        -:16209:                        pkn = R;
        -:16210:                        L = linkeroperand_and_tail(pkn,&lhead,&ltail);
        -:16211:                        R = rechteroperand_and_tail(pkn,&rhead,&rtail);
        -:16212:                        }*/
        -:16213:                    }
        -:16214:                else                /* (a*d) * (b*c) */
        -:16215:                    {
     4762:16216:                    L = prive(L);
        -:16217:                    assert(!shared(L));
     4762:16218:                    if(ltail != L->RIGHT) /*20111130*/
        -:16219:                        {
    #####:16220:                        wis(L->RIGHT); /* rare, set REFCOUNTSTRESSTEST 1 */
    #####:16221:                        ltail = zelfde_als_w(ltail);
        -:16222:                        }
     4762:16223:                    L->RIGHT = repol;
     4762:16224:                    repol = L;
        -:16225:                    assert(!shared(pkn));
     4762:16226:                    pkn = prive(pkn);
        -:16227:                    assert(!shared(pkn));
     4762:16228:                    pkn->LEFT = ltail;
     4762:16229:                    L = linkeroperand_and_tail(pkn,&lhead,&ltail);
        -:16230:                    }               /* repol := a*repol */
        -:16231:                /* d * (b*c) */
        -:16232:                }
        -:16233:            else /* Wrong order */
        -:16234:                {
        -:16235:                /*printf("> "); */
     3952:16236:                pkn = prive(pkn);
        -:16237:                assert(!shared(pkn));
        -:16238:                assert(L->v.fl & READY); /* 20120916 */
     3952:16239:                if(rtail == NULL) /* (b*c) * a */
        -:16240:                    {
     1683:16241:                    pkn->LEFT = R;
        -:16242:                    assert(L->v.fl & READY); /* 20120916 */
        -:16243:                   /* if(L->v.fl & READY)
        -:16244:                        {*/
     1683:16245:                        pkn->RIGHT = L;
     1683:16246:                        break;
        -:16247:                        /*}
        -:16248:                    else
        -:16249:                        {/ * unreachable * /
        -:16250:                        pkn->RIGHT = repol;
        -:16251:                        repol = pkn;
        -:16252:                        pkn = L;
        -:16253:                        break;
        -:16254:                        }*/
        -:16255:                    }             /* a * (b*c) */
        -:16256:                else          /* (b*c) * (a*d)         c * (b*a) */
        -:16257:                    {
     2269:16258:                    R = prive(R);
        -:16259:                    assert(!shared(R));
     2269:16260:                    if(R->RIGHT != rtail) /*20111130*/
        -:16261:                        {
    #####:16262:                        wis(R->RIGHT); /* rare, set REFCOUNTSTRESSTEST 1 */
    #####:16263:                        rtail = zelfde_als_w(rtail);
        -:16264:                        }
     2269:16265:                    R->RIGHT = repol;
     2269:16266:                    repol = R;
        -:16267:                    assert(!shared(pkn));
     2269:16268:                    pkn->RIGHT = rtail;
     2269:16269:                    R = rechteroperand_and_tail(pkn,&rhead,&rtail);
        -:16270:                    }         /* repol :=  a*repol    repol := b*repol */
        -:16271:                /* (b*c) * d */
        -:16272:                }
     7031:16273:            }
        -:16274:        for(;;)
        -:16275:            { /*Combine combinable elements and prepend to result*/
   206474:16276:            pkn->v.fl |= READY;
   206474:16277:            pkn = combine(pkn);
   206474:16278:            if(!(pkn->v.fl & READY))
        -:16279:                { /*This may results in recursive call to merge
        -:16280:                    if the result of the evaluation is not in same
        -:16281:                    sorting position as unevaluated expression. */
        -:16282:                assert(!shared(pkn));
     3943:16283:                pkn = eval(pkn);
        -:16284:                }
   206474:16285:            if(repol != &nilk)
        -:16286:                {
     7031:16287:                psk n = repol->RIGHT;
        -:16288:                assert(!shared(repol));
     7031:16289:                repol->RIGHT = pkn;
     7031:16290:                pkn = repol;
     7031:16291:                repol = n;
        -:16292:                }
        -:16293:            else
   199443:16294:                break;
     7031:16295:            }
   199443:16296:        if(Repol == &nilk)
   194820:16297:            break;
     4623:16298:        tmp = Repol->RIGHT;
        -:16299:        assert(!shared(Repol));
     4623:16300:        Repol->RIGHT = pkn;
     4623:16301:        pkn = Repol;
        -:16302:        assert(!shared(pkn));
     4623:16303:        pkn->v.fl |= READY;
     4623:16304:        Repol = tmp;
     4623:16305:        }
        -:16306:    /*--level;*/
   194820:16307:    return pkn;
        -:16308:    }
        -:16309:
       75:16310:static psk substlog(psk pkn)
        -:16311:    {
        -:16312:    static const char *conc[] = {NULL,NULL,NULL,NULL};
       75:16313:    psk lknoop = pkn->LEFT,rknoop = pkn->RIGHT;
       75:16314:    if(!vgl(lknoop,rknoop))
        -:16315:        {
        4:16316:        wis(pkn);
        4:16317:        return copievan(&eenk);
        -:16318:        }
       71:16319:    else if(is_op(rknoop))  /*{?} x\L(2+y) => x\L(2+y) */
        -:16320:        {
        -:16321:        int ok;
        4:16322:        return tryq(pkn,f5,&ok); /*{?} x\L(a*x^n*z) => n+x\L(a*z) */
        -:16323:        }
       67:16324:    else if(IS_EEN(rknoop))  /*{?} x\L1 => 0 */ /*{!} 0 */
        -:16325:        {
        2:16326:        wis(pkn);
        2:16327:        return copievan(&nulk);
        -:16328:        }
       65:16329:    else if(RAT_NUL(rknoop)) /*{?} z\L0 => z\L0 */
        1:16330:        return pkn;
       64:16331:    else if(is_op(lknoop)) /*{?} (x+y)\Lz => (x+y)\Lz */
        1:16332:        return pkn;
       63:16333:    else if(RAT_NUL(lknoop))   /*{?} 0\Lx => 0\Lx */
        1:16334:        return pkn;
       62:16335:    else if(IS_EEN(lknoop))   /*{?} 1\Lx => 1\Lx */
        1:16336:        return pkn;
       61:16337:    else if(RAT_NEG(lknoop))  /*{?} -7\Lx => -7\Lx */
        1:16338:        return pkn;
       60:16339:    else if(RATIONAAL_COMP(rknoop))  /*{?} x\L7 => x\L7 */
        -:16340:        {
       50:16341:        if(_qvergelijk(rknoop,&nulk) & MINUS)
        -:16342:            {
        -:16343:            /* (nL-m = i*pi/eLn+nLm)  */ /*{?} 7\L-9 => 1+7\L9/7+i*pi*e\L7^-1 */ /*{!} i*pi/e\L7+7\L9)  */
        1:16344:            adr[1] = lknoop;
        1:16345:            adr[2] = rknoop;
        1:16346:            return opb(pkn,"(i*pi*e\016\1^-1+\1\016(-1*\2))",NULL);
        -:16347:            }
       49:16348:        else if(RATIONAAL_COMP(lknoop)) /* m\Ln */ /*{?} 7\L9 => 1+7\L9/7 */
        -:16349:            {
       45:16350:            if(_qvergelijk(lknoop,&eenk) & MINUS)
        -:16351:                {
        -:16352:                                        /* (1/n)Lm = -1*nLm */ /*{?} 1/7\L9 => -1*(1+7\L9/7) */ /*{!} -1*nLm */
        1:16353:                adr[1] = rknoop;
        1:16354:                conc[0] = "(-1*";
        1:16355:                conc[1] = hekje6;
        1:16356:                adr[6] = _q_qdeel(&eenk,lknoop);
        1:16357:                conc[2] = "\016\1)";
        1:16358:                pkn = vopb(pkn,conc);
        1:16359:                wis(adr[6]);
        1:16360:                return pkn;
        -:16361:                }
       44:16362:            else if(_qvergelijk(lknoop,rknoop) & MINUS)
        -:16363:                {
        -:16364:                                    /* nL(n+m) = 1+nL((n+m)/n) */ /*{?} 7\L(7+9) => 1+7\L16/7 */ /*{!} 1+nL((n+m)/n) */
       16:16365:                conc[0] = "(1+\1\016";
        -:16366:                assert(lknoop != rknoop);
        -:16367:                /*if(lknoop == rknoop)
        -:16368:                    rknoop = pkn->RIGHT = prive(rknoop);*/
       16:16369:                adr[1] = lknoop;
       16:16370:                conc[1] = hekje6;
       16:16371:                adr[6] = _q_qdeel(rknoop,lknoop);
       16:16372:                conc[2] = ")";
       16:16373:                pkn = vopb(pkn,conc);
       16:16374:                wis(adr[6]);
       16:16375:                return pkn;
        -:16376:                }
       28:16377:            else if(_qvergelijk(rknoop,&eenk) & MINUS)
        -:16378:                {
        -:16379:                                    /* nL(1/m) = -1+nL(n/m) */ /*{?} 7\L1/9 => -2+7\L49/9 */ /*{!} -1+nL(n/m) */
       14:16380:                conc[0] = "(-1+\1\016";
        -:16381:                assert(lknoop != rknoop);
        -:16382:                /*if(lknoop == rknoop)
        -:16383:                    rknoop = pkn->RIGHT = prive(rknoop);*/
       14:16384:                adr[1] = lknoop;
       14:16385:                conc[1] = hekje6;
       14:16386:                adr[6] = _qmaal(rknoop,lknoop);
       14:16387:                conc[2] = ")";
       14:16388:                pkn = vopb(pkn,conc);
       14:16389:                wis(adr[6]);
       14:16390:                return pkn;
        -:16391:                }
        -:16392:            }
        -:16393:        }
       28:16394:    return pkn;
        -:16395:    }
        -:16396:
      145:16397:static psk substdiff(psk pkn)
        -:16398:    {/*20120916 simplified*/
        -:16399:    psk lknoop,rknoop;
      145:16400:    lknoop = pkn->LEFT;
      145:16401:    rknoop = pkn->RIGHT;
      145:16402:    if(is_constant(lknoop) || is_constant(rknoop))
        -:16403:        {
       63:16404:        wis(pkn);
       63:16405:        pkn = copievan(&nulk);
        -:16406:        }
       82:16407:    else if(!vgl(lknoop,rknoop))
        -:16408:        {
        7:16409:        wis(pkn);
        7:16410:        pkn = copievan(&eenk);
        -:16411:        }
       75:16412:    else if(  (  kop(rknoop) == FUN
       75:16413:              || !is_op(rknoop)
        -:16414:              )
       25:16415:           && is_afhankelyk_van(lknoop,rknoop)
        -:16416:           )
        -:16417:        {
        -:16418:        ;
        -:16419:        }
       75:16420:    else if(!is_op(rknoop))
        -:16421:        {
       25:16422:        wis(pkn);
       25:16423:        pkn = copievan(&nulk);
        -:16424:        }
       50:16425:    else if(kop(rknoop) == PLUS)
        -:16426:        {
       15:16427:        adr[1] = lknoop;
       15:16428:        adr[2] = rknoop->LEFT;
       15:16429:        adr[3] = rknoop->RIGHT;
       15:16430:        pkn = opb(pkn,"((\1\017\2)+(\1\017\3))",NULL);
        -:16431:        }
       35:16432:    else if(is_op(rknoop))
        -:16433:        {
       35:16434:        adr[2] = rknoop->LEFT;
       35:16435:        adr[1] = lknoop;
       35:16436:        adr[3] = rknoop->RIGHT;
       35:16437:        switch(kop(rknoop))
        -:16438:            {
        -:16439:            case MAAL :
       28:16440:                pkn = opb(pkn,"(\001\017\2*\3+\2*\001\017\3)",NULL);
       28:16441:                break;
        -:16442:            case EXP:
        6:16443:                pkn = opb(pkn,
        -:16444:                    "(\2^(-1+\3)*\3*\001\017\2+\2^\3*e\016\2*\001\017\3)",NULL);
        6:16445:                break;
        -:16446:            case LOG :
        1:16447:                pkn = opb(pkn,
        -:16448:                    "(\2^-1*e\016\2^-2*e\016\3*\001\017\2+\3^-1*e\016\2^-1*\001\017\3)",NULL);
        1:16449:                break;
        -:16450:            }
        -:16451:        }
      145:16452:    return pkn;
        -:16453:    }
        -:16454:
        -:16455:
        -:16456:#if JMP /*Bart 20030410: Often no need for polling in multithreaded apps.*/
        -:16457:#include <windows.h>
        -:16458:#include <dde.h>
        -:16459:static void PeekMsg(void)
        -:16460:    {
        -:16461:    static MSG msg;
        -:16462:    while(PeekMessage(&msg,NULL,WM_PAINT,/*WM_MOUSELAST*/WM_DDE_LAST,PM_REMOVE))
        -:16463:        {
        -:16464:        if(msg.message == WM_QUIT)
        -:16465:            {
        -:16466:            PostThreadMessage(GetCurrentThreadId(), WM_QUIT,0,0L);
        -:16467:            longjmp(jumper,1);
        -:16468:            }
        -:16469:        TranslateMessage(&msg);        /* Translates virtual key codes */
        -:16470:        DispatchMessage(&msg);        /* Dispatches message to window*/
        -:16471:        }
        -:16472:    }
        -:16473:#endif
        -:16474:
        -:16475:/*
        -:16476:Iterative handling of LUCHT operator in evalueer.
        -:16477:Can now handle very deep structures without stack overflow
        -:16478:*/
        -:16479:
   106495:16480:static psk handleLUCHT(psk pkn)
        -:16481:    { /* assumption: (kop(*pkn) == LUCHT) && !((*pkn)->v.fl & READY) */
        -:16482:    static psk hulp;
        -:16483:    /*psk luchtknoop = *pkn;*/
        -:16484:    psk luchtknoop;
        -:16485:    psk next;
   106495:16486:    ppsk pluchtknoop = &pkn;
   106495:16487:    ppsk prevpluchtknoop = NULL;
        -:16488:    for(;;)
        -:16489:        {
   123036:16490:        luchtknoop = *pluchtknoop;
   123036:16491:        luchtknoop->LEFT = eval(luchtknoop->LEFT);
        -:16492:        /*evalueer(((luchtknoop = *pluchtknoop)->LEFT));*/
   123036:16493:        if  (  !is_op(hulp=luchtknoop->LEFT)
   122715:16494:            && !(hulp->u.obj)
      163:16495:            && !HAS_UNOPS(hulp)
        -:16496:            )
        -:16497:            {
      163:16498:            *pluchtknoop = rechtertak(luchtknoop);
        -:16499:            }
        -:16500:        else
        -:16501:            {
   122873:16502:            prevpluchtknoop = pluchtknoop;
   122873:16503:            pluchtknoop = &(luchtknoop->RIGHT);
        -:16504:            }
   123036:16505:        if(kop(luchtknoop = *pluchtknoop) == LUCHT && !(luchtknoop->v.fl & READY))
        -:16506:            {
    33082:16507:            if(shared(*pluchtknoop))
    13341:16508:                *pluchtknoop = copyop(*pluchtknoop);
        -:16509:            }
        -:16510:        else
        -:16511:            {
   106495:16512:            *pluchtknoop = eval(*pluchtknoop);
   106495:16513:            if(  prevpluchtknoop
   106472:16514:              && !is_op(luchtknoop = *pluchtknoop)
     5352:16515:              && !((luchtknoop)->u.obj)
       35:16516:              && !HAS_UNOPS(luchtknoop)
        -:16517:              )
       35:16518:                *prevpluchtknoop = linkertak(*prevpluchtknoop);
   106495:16519:            break;
        -:16520:            }
    16541:16521:        }
        -:16522:
   106495:16523:    luchtknoop = pkn;
   229382:16524:    while(kop(luchtknoop) == LUCHT)
        -:16525:        {
   122841:16526:        next = luchtknoop->RIGHT;
   122841:16527:        rechtsbrengen(luchtknoop);
   122841:16528:        if(next->v.fl & READY)
   106449:16529:            break;
    16392:16530:        luchtknoop = next;
    16392:16531:        luchtknoop->v.fl |= READY;
        -:16532:        }
   106495:16533:    return pkn;
        -:16534:    }
        -:16535:/*
        -:16536:Iterative handling of KOMMA operator in evalueer.
        -:16537:Can now handle very deep structures without stack overflow
        -:16538:*/
     4257:16539:static psk handleKOMMA(psk pkn)
        -:16540:    { /* assumption: (kop(*pkn) == KOMMA) && !((*pkn)->v.fl & READY) */
     4257:16541:    psk kommaknoop = pkn;
        -:16542:    psk next;
        -:16543:    ppsk pkommaknoop;
     8909:16544:    while(kop(kommaknoop->RIGHT) == KOMMA && !(kommaknoop->RIGHT->v.fl & READY))
        -:16545:        {
      395:16546:        kommaknoop->LEFT = eval(kommaknoop->LEFT);
      395:16547:        pkommaknoop = &(kommaknoop->RIGHT);
      395:16548:        kommaknoop = kommaknoop->RIGHT;
      395:16549:        if(shared(kommaknoop))
        -:16550:            {
      382:16551:            *pkommaknoop = kommaknoop = copyop(kommaknoop);
        -:16552:            }
        -:16553:        }
     4257:16554:    kommaknoop->LEFT = eval(kommaknoop->LEFT);
     4257:16555:    kommaknoop->RIGHT = eval(kommaknoop->RIGHT);
     4257:16556:    kommaknoop = pkn;
     8909:16557:    while(kop(kommaknoop) == KOMMA)
        -:16558:        {
     4652:16559:        next = kommaknoop->RIGHT;
     4652:16560:        rechtsbrengen(kommaknoop);
     4652:16561:        if(next->v.fl & READY)
     4257:16562:            break;
      395:16563:        kommaknoop = next;
      395:16564:        kommaknoop->v.fl |= READY;
        -:16565:        }
     4257:16566:    return pkn;
        -:16567:    }
        -:16568:
   642672:16569:static psk evalvar(psk pkn)
        -:16570:    {
        -:16571:    psk adr;
   642672:16572:    if((adr = Naamwoord_w(pkn,pkn->v.fl & DOUBLY_INDIRECT)) != NULL)
        -:16573:        {
   642632:16574:        wis(pkn);
   642632:16575:        pkn = adr;
        -:16576:        }
        -:16577:    else
        -:16578:        {
        -:16579:        DBGSRC(printf("evalvar(");result(pkn);printf("\n");)
       40:16580:        if(shared(pkn))
        -:16581:            {
        -:16582:            /*You can get here if a !variable is unitialized*/
    #####:16583:            dec_refcount(pkn);
    #####:16584:            pkn = icopievan(pkn);
        -:16585:            }
        -:16586:        assert(!shared(pkn));
       40:16587:        (pkn)->v.fl |= READY;
       40:16588:        (pkn)->v.fl ^= SUCCESS;
        -:16589:        }
   642672:16590:    return pkn;
        -:16591:    }
        -:16592:
   932364:16593:static void privatized(psk pkn,psk plkn)
        -:16594:    {
   932364:16595:    *plkn = *pkn;
   932364:16596:    if(shared(plkn))
        -:16597:        {
   930454:16598:        dec_refcount(pkn);
   930454:16599:        plkn->LEFT = zelfde_als_w(plkn->LEFT);
   930454:16600:        plkn->RIGHT = zelfde_als_w(plkn->RIGHT);
        -:16601:        }
        -:16602:    else
     1910:16603:        pskfree(pkn);
   932364:16604:    }
        -:16605:
      126:16606:static psk __rechtertak(psk pkn)
        -:16607:    {
        -:16608:    psk ret;
      126:16609:    int success = pkn->v.fl & SUCCESS;
      126:16610:    if(shared(pkn))
        -:16611:        {
       27:16612:        ret = zelfde_als_w(pkn->RIGHT);
       27:16613:        dec_refcount(pkn);
        -:16614:        }
        -:16615:    else
        -:16616:        {
       99:16617:        ret = pkn->RIGHT;
       99:16618:        wis(pkn->LEFT);
       99:16619:        pskfree(pkn);
        -:16620:        }
      126:16621:    if(!success)
        -:16622:        {
       99:16623:        ret = prive(ret);
       99:16624:        ret->v.fl ^= SUCCESS;
        -:16625:        }
      126:16626:    return ret;
        -:16627:    }
        -:16628:
        -:16629:
        -:16630:/*static int evalueer(ppsk pkn)*/
  2171463:16631:static psk eval(psk pkn)
        -:16632:    {
        -:16633:    ASTACK
        -:16634:    /*
        -:16635:    Notice the low number of local variables on the stack. This ensures maximal
        -:16636:    utilisation of stack-depth for recursion.
        -:16637:    */
        -:16638:    DBGSRC(Printf("evaluate:");result(pkn);Printf("\n");)
  6521312:16639:    while(!(pkn->v.fl & READY))
        -:16640:        {
  2178386:16641:        if(is_op(pkn))
        -:16642:            {
  1535877:16643:            sk lkn = *pkn;
        -:16644:            /* The operators MATCH, EN and OF are treated in another way than
        -:16645:            the other operators. These three operators are the only 'volatile'
        -:16646:            operators: they cannot occur in a fully evaluated tree. For that reason
        -:16647:            there is no need to allocate space for an evaluated version of such
        -:16648:            operators on the stack. Instead the local variable lkn is used.
        -:16649:            */
  1535877:16650:            switch(kop(pkn))
        -:16651:                {
        -:16652:                case MATCH :
        -:16653:                    {
   510824:16654:                    privatized(pkn,&lkn);
        -:16655:                    /*if(evalueer((lkn.LEFT)) == TRUE)*/
   510824:16656:                    lkn.LEFT = eval(lkn.LEFT);
   510824:16657:                    if(isSUCCESSorFENCE(lkn.LEFT))
        -:16658:                        /* 20080113
        -:16659:                        `~a:?b will assign `~a to b
        -:16660:                        */
        -:16661:                        {
        -:16662:                        DBGSRC(Printf("before match:");result(&lkn);\
        -:16663:                            Printf("\n");)
        -:16664:#if STRINGMATCH_CAN_BE_NEGATED
        -:16665:                        if(lkn.flgs & ATOM) /*20071229 should other flags be
        -:16666:                                            excluded, including ~ ?*/
        -:16667:#else
   510760:16668:                        if((lkn.flgs & ATOM) && !ONTKENNING(lkn.flgs,ATOM))
        -:16669:#endif
        -:16670:                            {
        -:16671:#if CUTOFFSUGGEST
      640:16672:                            if(!is_op(lkn.LEFT) && stringmatch(0,"V",SPOBJ(lkn.LEFT),NULL,lkn.RIGHT, lkn.LEFT,0,strlen((char*)POBJ(lkn.LEFT)),NULL,0) & TRUE)
        -:16673:#else
        -:16674:                            if(!is_op(lkn.LEFT) && stringmatch(0,"V",POBJ(lkn.LEFT),NULL,lkn.RIGHT, lkn.LEFT,0,strlen((char*)POBJ(lkn.LEFT))) & TRUE)
        -:16675:#endif
      278:16676:                                pkn = _linkertak(&lkn); /* 20071229 ~@(a:a) is now treated like ~(a:a)*/
        -:16677:                            else
        -:16678:                                {
       42:16679:                                if(is_op(lkn.LEFT))
        -:16680:                                    {
        -:16681:#if !defined NO_EXIT_ON_NON_SEVERE_ERRORS
    #####:16682:                                    errorprintf("Error in stringmatch: left operand is not atomic ");writeError(&lkn);
    #####:16683:                                    exit(117);
        -:16684:#endif
        -:16685:                                    }
       42:16686:                                pkn = _flinkertak(&lkn);/* 20071229 ~@(a:b) is now treated like ~(a:b)*/
        -:16687:                                }
        -:16688:                            }
        -:16689:                        else
        -:16690:                            {
   510440:16691:                            if(match(0,lkn.LEFT,lkn.RIGHT,NULL,0,lkn.LEFT,5555) & TRUE)
   495102:16692:                                pkn = _linkertak(&lkn);
        -:16693:                            else
    15338:16694:                                pkn = _flinkertak(&lkn);
        -:16695:                            }
        -:16696:                        }
        -:16697:                    else
        -:16698:                        {
       64:16699:                        pkn = _linkertak(&lkn);
        -:16700:                        }
        -:16701:                    DBGSRC(Printf("after match:");result(pkn);Printf("\n");\
        -:16702:                        if((pkn)->v.fl & SUCCESS) Printf(" SUCCESS\n");\
        -:16703:                        else Printf(" FENCE\n");)
   510824:16704:                    break;
        -:16705:                    }
        -:16706:                    /* The operators EN and OF are tail-recursion optimised. */
        -:16707:                case EN :
        -:16708:                    {
   342499:16709:                    privatized(pkn,&lkn);
   342499:16710:                    lkn.LEFT = eval(lkn.LEFT);
   342499:16711:                    if(isSUCCESSorFENCE(lkn.LEFT))
   329006:16712:                        pkn = _rechtertak(&lkn);/* TRUE of FENCE */
        -:16713:                    else
    13493:16714:                        pkn = _linkertak(&lkn);/* FAAL */
   342499:16715:                    break;
        -:16716:                    }
        -:16717:                case OF :
        -:16718:                    {
    79041:16719:                    privatized(pkn,&lkn);
    79041:16720:                    lkn.LEFT = eval(lkn.LEFT);
    79041:16721:                    if(isSUCCESSorFENCE(lkn.LEFT))
    68413:16722:                        pkn = _fencelinkertak(&lkn);/* FENCE of TRUE */
        -:16723:                    else
    10628:16724:                        pkn = _rechtertak(&lkn);/* FAAL */
    79041:16725:                    break;
        -:16726:                    }
        -:16727:                    /* Operators that can occur in evaluated expressions: */
        -:16728:                case WORDT :
     8763:16729:                    if(ISBUILTIN((objectknoop *)pkn))
        -:16730:                        {
        7:16731:                        pkn->v.fl |= READY;
        7:16732:                        break;
        -:16733:                        }
        -:16734:
     8756:16735:                    if(  !is_op(pkn->LEFT)
     8754:16736:                      && !pkn->LEFT->u.obj
     1744:16737:                      && (pkn->v.fl & INDIRECT)
      128:16738:                      && !(pkn->v.fl & DOUBLY_INDIRECT)
        -:16739:                      )
        -:16740:                        {
        -:16741:                        /*privatized(pkn,&lkn);*/
        -:16742:                        /*evalueer((lkn.LEFT));*/
        -:16743:                        /*pkn = _rechtertak(&lkn);*/
        -:16744:                        static int fl;
      126:16745:                        fl = pkn->v.fl & (UNOPS & ~INDIRECT);
      126:16746:                        pkn = __rechtertak(pkn);
      126:16747:                        if(fl)
        -:16748:                            {
        1:16749:                            pkn = prive(pkn);
        1:16750:                            pkn->v.fl |= fl; /* {?} <>#@`/%?!(=b) => /#<>%@?`b */
        -:16751:                            }
      126:16752:                        break;
        -:16753:
        -:16754:                        /*                    pkn = pkn->RIGHT;*/
        -:16755:                        }
        -:16756:                    else
        -:16757:                        {
     8630:16758:                        if(shared(pkn))
        -:16759:                            {
     8163:16760:                            pkn = copyop(pkn);
        -:16761:                            }
     8630:16762:                        pkn->v.fl |= READY;
     8630:16763:                        pkn->LEFT = eval(pkn->LEFT);
     8630:16764:                        if(is_op(pkn->LEFT))
        -:16765:                            {
        2:16766:                            if(update(pkn->LEFT,pkn->RIGHT))
        1:16767:                                pkn = linkertak(pkn);
        -:16768:                            else
        1:16769:                                pkn = flinkertak(pkn);
        -:16770:                            }
     8628:16771:                        else if(pkn->LEFT->u.obj)
        -:16772:                            {
     7010:16773:                            insert(pkn->LEFT,pkn->RIGHT);
     7010:16774:                            pkn = linkertak(pkn);
        -:16775:                            }
     1618:16776:                        else if(pkn->v.fl & INDIRECT)
        -:16777:                            /* 20080103: !(=a) -> a */
        -:16778:                            {
        2:16779:                            pkn = evalvar(pkn);
        -:16780:                            }
        -:16781:                        }
     8630:16782:                    break;
        -:16783:                case DOT :
        -:16784:                    {
     7319:16785:                    if(shared(pkn))
        -:16786:                        {
     7132:16787:                        pkn = copyop(pkn);
        -:16788:                        }
     7319:16789:                    pkn->v.fl |= READY;
     7319:16790:                    pkn->LEFT = eval(pkn->LEFT);
     7319:16791:                    pkn->RIGHT = eval(pkn->RIGHT);
     7319:16792:                    if(pkn->v.fl & INDIRECT)
        -:16793:                        {
      112:16794:                        pkn = evalvar(pkn);
        -:16795:                        }
     7319:16796:                    break;
        -:16797:                    }
        -:16798:                case KOMMA :
     4257:16799:                    if(shared(pkn))
        -:16800:                        {
     4247:16801:                        pkn = copyop(pkn);
        -:16802:                        }
     4257:16803:                    pkn->v.fl |= READY;
     4257:16804:                    pkn = handleKOMMA(pkn);/* do not recurse, iterate! */
     4257:16805:                    if(lkn.v.fl & INDIRECT)
        -:16806:                        {
        1:16807:                        pkn = evalvar(pkn);
        -:16808:                        }
     4257:16809:                    break;
        -:16810:                case LUCHT :
   106495:16811:                    if(shared(pkn))
        -:16812:                        {
   106401:16813:                        pkn = copyop(pkn);
        -:16814:                        }
   106495:16815:                    pkn->v.fl |= READY;
   106495:16816:                    pkn = handleLUCHT(pkn);/* do not recurse, iterate! */
   106495:16817:                    if(lkn.v.fl & INDIRECT)
        -:16818:                        {
        1:16819:                        pkn = evalvar(pkn);
        -:16820:                        }
   106495:16821:                    break;
        -:16822:                case PLUS :
   186395:16823:                    if(shared(pkn))
        -:16824:                        {
   183131:16825:                        pkn = copyop(pkn);
        -:16826:                        }
   186395:16827:                    pkn = merge(pkn,vglplus,plus_samenvoegen_of_sorteren
        -:16828:#if EXPAND
        -:16829:                        ,expandProduct
        -:16830:#endif
        -:16831:                        );
   186395:16832:                    if(lkn.v.fl & INDIRECT)
        -:16833:                        {
        1:16834:                        pkn = evalvar(pkn);
        -:16835:                        }
   186395:16836:                    break;
        -:16837:                case MAAL :
     8425:16838:                    if(shared(pkn))
        -:16839:                        {
     5333:16840:                        pkn = copyop(pkn);
        -:16841:                        }
     8425:16842:                    pkn->v.fl |= READY;
        -:16843:                    /*if(evalueer((pkn->LEFT)) == TRUE
        -:16844:                    This creates enormous stackdepth && evalueer((pkn->RIGHT)) == TRUE
        -:16845:                    )*/
        -:16846:                    {
     8425:16847:                    pkn = merge(pkn,vglmaal,substmaal
        -:16848:#if EXPAND
        -:16849:                        ,expandDummy
        -:16850:#endif
        -:16851:                        );
        -:16852:                    }
     8425:16853:                    if(lkn.v.fl & INDIRECT)
        -:16854:                        {
        1:16855:                        pkn = evalvar(pkn);                             /* {?} a=7 & !(a*1) */
        -:16856:                        }
     8425:16857:                    break;
        -:16858:                case EXP :
     1845:16859:                    if(shared(pkn))
        -:16860:                        {
      865:16861:                        pkn = copyop(pkn);
        -:16862:                        }
     1845:16863:                    pkn->v.fl |= READY;
     1845:16864:                    if(  evalueer((pkn->LEFT)) == TRUE
     1844:16865:                      && evalueer((pkn->RIGHT)) == TRUE
        -:16866:                      )
        -:16867:                        {
     1843:16868:                        pkn = stapelmacht(pkn);
        -:16869:                        }
        -:16870:                    else
        2:16871:                        pkn->v.fl ^= SUCCESS;
     1845:16872:                    if(lkn.v.fl & INDIRECT)
        -:16873:                        {
        1:16874:                        pkn = evalvar(pkn);
        -:16875:                        }
     1845:16876:                    break;
        -:16877:                case LOG :
       77:16878:                    if(shared(pkn))
        -:16879:                        {
       32:16880:                        pkn = copyop(pkn);
        -:16881:                        }
       77:16882:                    pkn->v.fl |= READY;
       77:16883:                    if(  evalueer((pkn->LEFT)) == TRUE
       76:16884:                      && evalueer((pkn->RIGHT)) == TRUE
        -:16885:                      )
        -:16886:                        {
       75:16887:                        pkn = substlog(pkn);
        -:16888:                        }
        -:16889:                    else
        -:16890:                        {
        2:16891:                        pkn->v.fl ^= SUCCESS;
        -:16892:                        }
       77:16893:                    if(lkn.v.fl & INDIRECT)
        -:16894:                        {
        1:16895:                        pkn = evalvar(pkn);
        -:16896:                        }
       77:16897:                    break;
        -:16898:                case DIF :
      147:16899:                    if(shared(pkn))
        -:16900:                        {
       47:16901:                        pkn = copyop(pkn);
        -:16902:                        }
      147:16903:                    pkn->v.fl |= READY;
      147:16904:                    if(  !(lkn.v.fl & INDIRECT)
      146:16905:                      && evalueer((pkn->LEFT)) == TRUE
      145:16906:                      && evalueer((pkn->RIGHT)) == TRUE
        -:16907:                      )
        -:16908:                        {
      145:16909:                        pkn = substdiff(pkn);
      145:16910:                        break;
        -:16911:                        }
        2:16912:                    pkn->v.fl ^= SUCCESS;
        2:16913:                    break;
        -:16914:                case FUN :
        -:16915:                case FUU :
   279033:16916:                    if(shared(pkn))
        -:16917:                        {
   276695:16918:                        pkn = copyop(pkn);
        -:16919:                        }
   279033:16920:                    pkn->v.fl |= READY;
   279033:16921:                    pkn->LEFT = eval(pkn->LEFT);
   279033:16922:                    if(kop(pkn) == FUN)
        -:16923:                        {
   276686:16924:                        pkn->RIGHT = eval(pkn->RIGHT);
        -:16925:                        }
   279033:16926:                    pkn = functies(pkn);
   279033:16927:                    if(lkn.v.fl & INDIRECT)
        -:16928:                        {
       42:16929:                        pkn = evalvar(pkn);
        -:16930:                        }
   279033:16931:                    break;
        -:16932:                case STREEP :
      757:16933:                    if(shared(pkn))
        -:16934:                        {
      757:16935:                        pkn = copyop(pkn);
        -:16936:                        }
      757:16937:                    pkn->v.fl |= READY;
      757:16938:                    if(dummy_op == WORDT)
        -:16939:                        {
        1:16940:                        psk old = pkn;
        1:16941:                        pkn = (psk)bmalloc(__LINE__,sizeof(objectknoop));
        -:16942:#ifdef BUILTIN
        1:16943:                        ((typedObjectknoop*)(pkn))->u.Int = 0;
        -:16944:#else
        -:16945:                        ((typedObjectknoop*)(pkn))->refcount = 0;
        -:16946:                        UNSETCREATEDWITHNEW((typedObjectknoop*)pkn);
        -:16947:                        UNSETBUILTIN((typedObjectknoop*)pkn);
        -:16948:#endif
        1:16949:                        pkn->LEFT = subboomcopie(old->LEFT);
        1:16950:                        old->RIGHT = Head(old->RIGHT);
        1:16951:                        pkn->RIGHT = subboomcopie(old->RIGHT);
        1:16952:                        wis(old);
        -:16953:                        }
      757:16954:                    pkn->v.fl &= (~OPERATOR & ~READY);
      757:16955:                    pkn->ops |= dummy_op;
      757:16956:                    pkn->v.fl |= SUCCESS;
      757:16957:                    if(lkn.v.fl & INDIRECT)
        -:16958:                        {/* (a=b=127)&(.):(_)&!(a_b) */
        1:16959:                        pkn = evalvar(pkn);
        -:16960:                        }
      757:16961:                    break;
        -:16962:                }
        -:16963:            }
        -:16964:        else
        -:16965:            {
        -:16966:            /*assert(!shared(pkn));*/ /* 20120916 evalvar now expects not shared arg. */
        -:16967:            /* An unevaluated leaf can only be an atom with ! or !!,
        -:16968:            so we don't need to test for this condition.*/
   642509:16969:            pkn = evalvar(pkn);
        -:16970:            /* After evaluation of a variable, the loop continues.
        -:16971:            Together with how & and | (EN and OF) are treated, this ensures that
        -:16972:            a loop can run indefinitely, without using stack space. */
        -:16973:            }
        -:16974:        }
        -:16975:#if JMP
        -:16976:    PeekMsg();
        -:16977:#endif
        -:16978:    ZSTACK
  2171463:16979:    return pkn;
        -:16980:    }
        -:16981:
        1:16982:int startProc(
        -:16983:#if _BRACMATEMBEDDED
        -:16984:    startStruct * init
        -:16985:#else
        -:16986:    void
        -:16987:#endif
        -:16988:    )
        -:16989:    {
        -:16990:    int tel;
        -:16991:    int err; /* 20100802, evaluation of version string */
        -:16992:    static int called = 0;
        -:16993:    /*printf("startProc ");*/
        1:16994:    if(called)
        -:16995:        {
        -:16996:        /*printf("already called\n");*/
    #####:16997:        return 2;
        -:16998:        }
        -:16999:    /*printf("call\n");*/
        1:17000:    called = 1;
        -:17001:#if _BRACMATEMBEDDED
        -:17002:    if(init)
        -:17003:        {
        -:17004:        if(init->WinIn)
        -:17005:            {
        -:17006:            WinIn = init->WinIn;
        -:17007:            }
        -:17008:        if(init->WinOut)
        -:17009:            {
        -:17010:            WinOut = init->WinOut;
        -:17011:            }
        -:17012:        if(init->WinFlush)
        -:17013:            {
        -:17014:            WinFlush = init->WinFlush;
        -:17015:            }
        -:17016:        }
        -:17017:#endif
        1:17018:    for(tel = 0;tel<256;variabelen[tel++] = NULL)
        -:17019:        ;
        1:17020:    if(!init_ruimte())
    #####:17021:        return 0;
        1:17022:    init_opcode();
        1:17023:    anker = NULL;
        1:17024:    fpi = stdin;
        1:17025:    fpo = stdout;
        -:17026:
        1:17027:    argk.flgs = READY | SUCCESS;
        1:17028:    argk.u.lobj = O('a','r','g');
        -:17029:
        1:17030:    sjt.flgs = READY | SUCCESS;/*20100910*/
        1:17031:    sjt.u.lobj = O('s','j','t');/*20100910*/
        -:17032:
        1:17033:    selfkn.flgs = READY | SUCCESS;
        1:17034:    selfkn.u.lobj = O('i','t','s');
        -:17035:
        1:17036:    Selfkn.flgs = READY | SUCCESS;
        1:17037:    Selfkn.u.lobj = O('I','t','s');
        -:17038:
        1:17039:    nilk.flgs = READY | SUCCESS | IDENT;
        1:17040:    nilk.u.lobj = 0L;
        -:17041:
        1:17042:    nulk.flgs = READY | SUCCESS | IDENT | QGETAL | QNUL;
        1:17043:    nulk.u.lobj = 0L;
        1:17044:    nulk.u.obj = '0';
        -:17045:
        1:17046:    eenk.u.lobj = 0L;
        1:17047:    eenk.u.obj = '1';
        1:17048:    eenk.flgs = READY | SUCCESS | IDENT | QGETAL;
        1:17049:    *(&(eenk.u.obj)+1) = 0;
        -:17050:
        1:17051:    mintweek.u.lobj = 0L;
        1:17052:    mintweek.u.obj = '2';
        1:17053:    mintweek.flgs = READY | SUCCESS | QGETAL | MINUS;
        1:17054:    *(&(mintweek.u.obj)+1) = 0;
        -:17055:
        1:17056:    mineenk.u.lobj = 0L;
        1:17057:    mineenk.u.obj = '1';
        1:17058:    mineenk.flgs = READY | SUCCESS | QGETAL | MINUS;
        1:17059:    *(&(mineenk.u.obj)+1) = 0;
        -:17060:
        1:17061:    tweek.u.lobj = 0L;
        1:17062:    tweek.u.obj = '2';
        1:17063:    tweek.flgs = READY | SUCCESS | QGETAL;
        1:17064:    *(&(tweek.u.obj)+1) = 0;
        -:17065:
        1:17066:    vierk.u.lobj = 0L;
        1:17067:    vierk.u.obj = '4';
        1:17068:    vierk.flgs = READY | SUCCESS | QGETAL;
        1:17069:    *(&(vierk.u.obj)+1) = 0;
        -:17070:
        1:17071:    minvierk.u.lobj = 0L;
        1:17072:    minvierk.u.obj = '4';
        1:17073:    minvierk.flgs = READY | SUCCESS | QGETAL | MINUS;
        1:17074:    *(&(minvierk.u.obj)+1) = 0;
        -:17075:
        1:17076:    m0 = opb(m0,"?*(%+%)^~/#>1*?" , NULL);
        1:17077:    m1 = opb(m1,"?*(%+%)*?" , NULL);
        1:17078:    f0 = opb(f0,"(g,k,pow"
        -:17079:                ".(pow"
        -:17080:                  "=b,c,d,l,s,f"
        -:17081:                  ".!arg:(%?b+%?c)^?d"
        -:17082:                  "&1:?f"
        -:17083:                  "&(s"
        -:17084:                   "=!d:1&0"
        -:17085:                   "|(!f*!d*(1+!l:?l)^-1:?f)"
        -:17086:                    "*!b^!l"
        -:17087:                    "*pow$(!c^(-1+!d:?d))"
        -:17088:                   "+!s"
        -:17089:                   ")"
        -:17090:                  "&!b^!d+!c^!d+!s"
        -:17091:                  "|!arg"
        -:17092:                  ")"
        -:17093:                  "&!arg:?g*((%+%)^~/#>1:?arg)*?k"
        -:17094:                  "&!g*pow$!arg*!k)",NULL);
        1:17095:    f1 = opb(f1,
        -:17096:        "((\177g,\177h,\177i).!arg:?\177g*(%?\177h+%?\177i)*",
        -:17097:        "?arg&!\177g*!\177h*!arg+!\177g*!\177i*!arg)",NULL);
        1:17098:    f4 = opb(f4,  "l,a,b,c,e,f"
        -:17099:                ".(a"
        -:17100:                 "=j,g,h,i"
        -:17101:                  ".!arg:?l^(?j+?g*!l\016?h*?i+?arg)"
        -:17102:                   "&!l^(!j+!arg)*!h^(!g*!i)"
        -:17103:                 ")"
        -:17104:                "&(e"
        -:17105:                 "=j,g,I"
        -:17106:                 ".!arg:?j+#?g*((i|-i):?I)*pi+?arg"
        -:17107:                   "&1:?l"
        -:17108:                   "&!j+(mod$(1+!g,2)+-1)*!I*pi+!arg"
        -:17109:                 ")"
        -:17110:                "&(f"
        -:17111:                 "=j,i"
        -:17112:                  ".!arg:?j+#?l*((i|-i):?I)*pi+?arg"
        -:17113:                   "&!I^(2*!l):?l"
        -:17114:                   "&!j+!arg"
        -:17115:                 ")"
        -:17116:                "&(b"
        -:17117:                 "="
        -:17118:                  "(!l:(<-1|>1)&e"
        -:17119:                  "|(-1|1/2|-1/2)&f"
        -:17120:                  ")"
        -:17121:                  ":?l"
        -:17122:                 ")"
        -:17123:                "&(c"
        -:17124:                 "="
        -:17125:                  ".1+!arg:?arg"
        -:17126:                   "&1:?l"
        -:17127:                   "&-1+!arg"
        -:17128:                 ")"
        -:17129:                "&(!arg:?l^(?+?*!l\016?*?+?)&a$!arg"
        -:17130:                 "|!arg"
        -:17131:                  ":e^((?+#?l*(i|-i)*pi+?&`!b"
        -:17132:                      "|?"
        -:17133:                       "*(pi|i|-i)"
        -:17134:                       "*?"
        -:17135:                       "*(?+?*(pi|i|-i)*?+?:%+%)"
        -:17136:                       "*?"
        -:17137:                        "&c:?l"
        -:17138:                      ")"
        -:17139:                     ":?arg"
        -:17140:                     ")"
        -:17141:                   "&e^!l$!arg*!l"
        -:17142:                 ")",NULL);
        1:17143:    f5 = opb(f5,
        -:17144:         "l,d"
        -:17145:         ".(d"
        -:17146:          "=j,g,h"
        -:17147:           ".!arg:?l\016(?j*!l^?g*?h)&!g+!l\016(!j*!h)"
        -:17148:          ")"
        -:17149:          "&!arg:?l\016(?*!l^?*?)"
        -:17150:          "&d$!arg", NULL);
        -:17151:
        1:17152:    anker = startboom_w(anker ,
        -:17153:        "(cat=flt,sin,tay,fct,cos,out,sgn.!arg:((?flt,(?sin,?tay)|?sin&:?tay)|?flt&:?sin:"
        -:17154:        "?tay)&(fct=.!arg:%?cos ?arg&!cos:((?out.?)|?out)&'(? ($out|($out.?)"
        -:17155:        ") ?):(=?sgn)&(!flt:!sgn&!(glf$(=~.!sin:!sgn))&!cos|) fct$!arg|)&(:!flt:!sin&mem$!tay|(:!flt&mem$:?flt"
        -:17156:        "|)&fct$(mem$!tay))),",
        -:17157:
        -:17158:        /* 20110823
        -:17159:        "(cat=flt,sin,tay,fct,cos,out,sgn.!arg:((?flt,(?sin,?tay)|?sin&:?tay)|?flt&:?sin:"
        -:17160:        "?tay)&(fct=.!arg:%?cos ?arg&!cos:((?out.?)|?out)&'(? (`=$out|($out.?)"
        -:17161:        ") ?):?sgn&(!flt:!sgn&~$(!sin:!sgn)&!cos|) fct$!arg|)&(:!flt:!sin|(:!flt&mem$:?flt"
        -:17162:        "|)&fct)$(mem$!tay)),",
        -:17163:        */
        -:17164:        "(out=(.put$!arg:?arg&put$\212&!arg)),"
        -:17165:        "(flt=((e,d,m,s,f).!arg:(?arg,~<0:?d)&!arg:0|(-1*!arg:>0:?arg&-1|1):?s&"
        -:17166:        "10\016!arg:?e+(10\016?m|0&1:?m)&(!m+1/2*1/10^!d:~<10&1+!e:?e&!m*1/10"
        -:17167:        ":?m|)&@(div$(!m+1/2*(1/10^!d:?d),!d):"
        -:17168:        "`%?f ?m)&str$(!s*!f (!d:~1&\254|) !m \252\261\260\305 !e))),",
        -:17169:
        -:17170:        "(tay=((f,tot,x,fac,cnt,res,R).",
        -:17171:        "(R=!cnt:!tot&!res|!res+(sub$(!x\017!f:?f.!x.0))*((!fac*(!cnt+1:?cnt))"
        -:17172:        ":?fac)^-1*!x^!cnt:?res&!R)&",
        -:17173:        "!arg:(?f,?x,?tot)&(fac=1)&(cnt=0)&((sub$(!f.!x.0)):?res)&!R)),",
        -:17174:
        -:17175:        /*"(ego=(r.sub$(sub$(!arg.(sin.?r).'sin$!r).(cos.?r).'cos$!r))),",
        -:17176:
        -:17177:        "(goe=((h,s).sub$(!arg.'(e^?h).",
        -:17178:        "'(-1*(sgn$(-1+i*!h+1:?h):?s)*i*(sin.-1+!s*!h+1:?s)+(cos.!s))))),",*/
        -:17179:
        -:17180:        "(sin=(.i*(-1/2*e^(i*!arg)+1/2*e^(-i*!arg)))),",
        -:17181:
        -:17182:        "(cos=(.1/2*(e^(i*!arg)+e^(-i*!arg)))),",
        -:17183:
        -:17184:        "(sgn=(.!arg:?#%arg*%+?&sgn$!arg|!arg:<0&-1|1)),",
        -:17185:        "(abs=(.sgn$!arg*!arg)),",
        -:17186:        "(sub=\177e,\177x,\177v,\177F.(\177F=\177l,\177r.!arg:!\177x&!\177v|"
        -:17187:        "!arg:%?\177l_%?\177r&(\177F$!\177l)_(\177F$!\177r)|!arg)&!arg:(("
        -:17188:        "?\177e.?\177x.?\177v)|out$(str$((=sub$(expr.var.rep)) !arg))&get'&~`)"
        -:17189:        "&\177F$!\177e),",
        -:17190:        fct,
        -:17191:        NULL);
        -:17192:
        -:17193:
        -:17194:#if JMP
        -:17195:    if(setjmp(jumper) != 0)
        -:17196:        return;
        -:17197:#endif
        1:17198:    anker = eval(anker);
        1:17199:    stringEval("(v=\"Bracmat version " VERSION ", build " BUILD " (" DATUM ")\")",NULL,&err);
        1:17200:    return 1;
        -:17201:}
        -:17202:
        1:17203:void endProc(void)
        -:17204:    {
        -:17205:    int err;
        -:17206:    static int called = 0;
        1:17207:    if(called)
        1:17208:        return;
        1:17209:    called = 1;
        -:17210:/*  stringEval("cat$:? CloseDown ? & CloseDown$ | out$\"No CloseDown function provided, exiting all the same.\"",NULL,&err);*/
        1:17211:    stringEval("cat$:? CloseDown ? & CloseDown$ | ",NULL,&err);
        1:17212:    if(err)
    #####:17213:        errorprintf("Error executing CloseDown\n");
        -:17214:    }
        -:17215:
        -:17216:/* main - the text-mode front end for bracmat */
        -:17217:
        -:17218:
        -:17219:#if _BRACMATEMBEDDED
        -:17220:#else
        -:17221:
        -:17222:#include <stddef.h>
        -:17223:
        1:17224:int mainlus(int argc,char *argv[])
        -:17225:    {
        -:17226:    int err;
        -:17227:    char * mainloop;
        -:17228:    const char * ret;
        1:17229:    if(argc > 1)
        -:17230:        { /* to get here, e.g.: ./bracmat out$hello */
        1:17231:        ARGC = argc;
        1:17232:        ARGV = argv;
        1:17233:        mainloop = "arg$&whl'(get$(arg$,MEM):?\"?...@#$*~%!\")&!\"?...@#$*~%!\"";
        1:17234:        stringEval(mainloop,&ret,&err);
        1:17235:        return (int)STRTOL(ret,0,10);
        -:17236:        /*
        -:17237:        int i;
        -:17238:        for(i = 1;i < argc;++i) / *20090630* /
        -:17239:            {
        -:17240:            stringEval(argv[i],NULL,&err);
        -:17241:            }
        -:17242:            */
        -:17243:        }
        -:17244:    else
        -:17245:        {
    #####:17246:        mainloop =
        -:17247:        "(w=\"11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY\\n"
        -:17248:        "FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN\\n"
        -:17249:        "OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES\\n"
        -:17250:        "PROVIDE THE PROGRAM \\\"AS IS\\\" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED\\n"
        -:17251:        "OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF\\n"
        -:17252:        "MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS\\n"
        -:17253:        "TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE\\n"
        -:17254:        "PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,\\n"
        -:17255:        "REPAIR OR CORRECTION.\\n\")&"
        -:17256:        "(c=\"12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING\\n"
        -:17257:        "WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR\\n"
        -:17258:        "REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,\\n"
        -:17259:        "INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING\\n"
        -:17260:        "OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED\\n"
        -:17261:        "TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY\\n"
        -:17262:        "YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER\\n"
        -:17263:        "PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE\\n"
        -:17264:        "POSSIBILITY OF SUCH DAMAGES.\\n\")&"
        -:17265:        "out$!v&"
        -:17266:        "out$\"Copyright (C) 2002 Bart Jongejan\\n"
        -:17267:        "Bracmat comes with ABSOLUTELY NO WARRANTY; for details type `!w'.\\n"
        -:17268:        "This is free software, and you are welcome to redistribute it\\n"
        -:17269:        "under certain conditions; type `!c' for details.\\n\\n"
        -:17270:        "\\n\\n{?} get$help { tutorial }\\n{?} )        { stop }\"&"
        -:17271:        "(main=put$\"{?} \"&clk$():?SEC&((get':?!(=):(|?&clk$+-1*!SEC:?SEC&"
        -:17272:        "put$\"{!} \"&put$!&put$(\"\\n    S  \" str$(div$(!SEC,1) \",\" (div$(mod$("
        -:17273:        "!SEC*100,100),1):?SEC&!SEC:<10&0|) !SEC) sec))|put$\"\\n    F\")|"
        -:17274:        "put$\"\\n    I\")&"
        -:17275:
        -:17276:
        -:17277:
        -:17278:
        -:17279:#if TELMAX
        -:17280:
        -:17281:        "out$str$(\"  \" bez')&"
        -:17282:#else
        -:17283:        "out$&"
        -:17284:#endif
        -:17285:
        -:17286:        "!main)&!main";
    #####:17287:        stringEval(mainloop,NULL,&err);
        -:17288:        }
    #####:17289:    return 0;
        -:17290:    }
        -:17291:
        1:17292:int main(int argc,char *argv[])
        -:17293:    {
        -:17294:    int ret; /*20100310 numerical result of mainlus becomes exit code.
        -:17295:             If out of integer range or not numerical: 0*/
        1:17296:    char * p = argv[0] + strlen(argv[0]);
        -:17297:#if 0
        -:17298:#ifdef _WIN64 /* Microsoft 64 bit */
        -:17299:    printf("_WIN64\n");
        -:17300:    printf("sizeof(char *) %lld\n",sizeof(char *));
        -:17301:    printf("sizeof(LONG) %lld\n",sizeof(LONG));
        -:17302:    printf("sizeof(size_t) %lld\n",sizeof(size_t));
        -:17303:    printf("WORD32 %d\n",WORD32);
        -:17304:    printf("RADIX %lld\n",(LONG)RADIX);
        -:17305:    printf("RADIX2 %lld\n",(LONG)RADIX2);
        -:17306:    printf("TEN_LOG_RADIX %lld\n",(LONG)TEN_LOG_RADIX);
        -:17307:    printf("HEADROOM %lld\n",(LONG)HEADROOM);
        -:17308:#else /* 32 bit and gcc 64 bit */
        -:17309:    printf("!_WIN64\n");
        -:17310:    printf("sizeof(char *) %ld\n",sizeof(char *));
        -:17311:    printf("sizeof(LONG) %ld\n",sizeof(LONG));
        -:17312:    printf("sizeof(size_t) %ld\n",sizeof(size_t));
        -:17313:    printf("WORD32 %d\n",WORD32);
        -:17314:    printf("RADIX %ld\n",(LONG)RADIX);
        -:17315:    printf("RADIX2 %ld\n",(LONG)RADIX2);
        -:17316:    printf("TEN_LOG_RADIX %ld\n",(LONG)TEN_LOG_RADIX);
        -:17317:    printf("HEADROOM %ld\n",(LONG)HEADROOM);
        -:17318:#endif
        -:17319:#endif
        -:17320:#ifndef NDEBUG
        -:17321:        {
        -:17322:        LONG radix,ten_log_radix;
        -:17323:        assert(HEADROOM*RADIX2 < LONG_MAX);
        -:17324:        for(radix = 1,ten_log_radix = 1;ten_log_radix <= TEN_LOG_RADIX;radix *= 10,++ten_log_radix)
        -:17325:            ;
        -:17326:        assert(RADIX == radix);
        -:17327:        }
        -:17328:#endif
        -:17329:    assert(sizeof(tFlags) == sizeof(unsigned int));
        7:17330:    while(--p >= argv[0])
        6:17331:        if(*p == '\\' || *p == '/')
        -:17332:            {
        1:17333:            ++p;
        1:17334:            targetPath = (char *)malloc(p - argv[0] + 1);
        1:17335:            if(targetPath)
        -:17336:                {
        1:17337:                strncpy(targetPath,argv[0],p - argv[0]);
        1:17338:                targetPath[p - argv[0]] = '\0';
        -:17339:                }
        1:17340:            break;
        -:17341:            }
        -:17342:/*  Printf("targetPath=%s\n",targetPath);*/
        -:17343:
        1:17344:    errorStream = stderr;
        1:17345:    if(!startProc())
    #####:17346:        return -1;
        1:17347:    ret = mainlus(argc,argv);
        1:17348:    endProc();/* to get here, eg: {?} main=out$bye! */
        1:17349:    if(targetPath)
        1:17350:        free(targetPath);
        1:17351:    return ret;
        -:17352:    }
        -:17353:
        -:17354:#endif /*#if !_BRACMATEMBEDDED*/
        -:17355:
