        -:    0:Source:xml.c
        -:    0:Graph:xml.gcno
        -:    0:Data:xml.gcda
        -:    0:Runs:1
        -:    0:Programs:1
        -:    1:/*
        -:    2:    Bracmat. Programming language with pattern matching on tree structures.
        -:    3:    Copyright (C) 2002  Bart Jongejan
        -:    4:
        -:    5:    This program is free software; you can redistribute it and/or modify
        -:    6:    it under the terms of the GNU General Public License as published by
        -:    7:    the Free Software Foundation; either version 2 of the License, or
        -:    8:    (at your option) any later version.
        -:    9:
        -:   10:    This program is distributed in the hope that it will be useful,
        -:   11:    but WITHOUT ANY WARRANTY; without even the implied warranty of
        -:   12:    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
        -:   13:    GNU General Public License for more details.
        -:   14:
        -:   15:    You should have received a copy of the GNU General Public License
        -:   16:    along with this program; if not, write to the Free Software
        -:   17:    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
        -:   18:*/
        -:   19:/*
        -:   20:xml.c
        -:   21:Convert XML file to Bracmat file.
        -:   22:XML entities are converted to their UTF-8 equivalents.
        -:   23:
        -:   24:Each tag is output to the Bracmat file. Combining opening tags with their
        -:   25:closing tags must be done elsewhere, if needed.
        -:   26:
        -:   27:Because the program does not make an attempt at nesting, combining
        -:   28:closing tags with their opening tags, the program can handle SGML and HTML as
        -:   29:well as XML.
        -:   30:
        -:   31:Attribute values need not be surrounded in ' ' or " ".
        -:   32:Attribute values need not even be present.
        -:   33:A closing angled parenthesis > is implied in certain circumstances:
        -:   34:<p<span>  is interpreted as <p><span>
        -:   35:attributes can be empty (no =[value])
        -:   36:*/
        -:   37:
        -:   38:#include <stdio.h>
        -:   39:#include <string.h>
        -:   40:#include <stdlib.h>
        -:   41:#include <assert.h>
        -:   42:
        -:   43:#include <limits.h>
        -:   44:
        -:   45:#if defined _WIN64
        -:   46:/*Microsoft*/
        -:   47:#define LONG long long
        -:   48:#else
        -:   49:#define LONG long
        -:   50:#endif
        -:   51:
        -:   52:
        -:   53:#define TRUE 1
        -:   54:#define FALSE 0
        -:   55:
        -:   56:extern void putOperatorChar(int c);
        -:   57:extern void putLeaveChar(int c);
        -:   58:extern char * putCodePoint(unsigned LONG val,char * s);
        -:   59:
        -:   60:typedef enum {notag,tag,endoftag,endoftag_startoftag} estate;
        -:   61:static estate (*tagState)(int kar);
        -:   62:
        -:   63:static int Put(char * c);
        -:   64:static int (*xput)(char * c) = Put;
        -:   65:
   187166:   66:static int rawput(int c)
        -:   67:    {
   187166:   68:    putLeaveChar(c);
   187166:   69:    return TRUE;
        -:   70:    }
        -:   71:
     1307:   72:static int nrawput(char * c)
        -:   73:    {
    11900:   74:    while(*c)
     9286:   75:        if(!rawput(*c++))
    #####:   76:            return FALSE;
     1307:   77:    return TRUE;
        -:   78:    }
        -:   79:/*
        -:   80:Handle such things:  &amp;security-level;
        -:   81:
        -:   82:In this case, &amp; must not be converted to &, because &security-level; is
        -:   83:(probably) not a declared entity reference name.
        -:   84: 
        -:   85:[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
        -:   86:[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
        -:   87:[5]   	Name	   ::=   	NameStartChar (NameChar)*
        -:   88:
        -:   89:
        -:   90:The charref thing can first be done after the string following it is sure
        -:   91:not to be an entity reference.
        -:   92:
        -:   93:If you want &amp; always to be converted to &, #define ALWAYSREPLACEAMP 1
        -:   94:*/
        -:   95:#define ALWAYSREPLACEAMP 1
        -:   96:
        -:   97:struct lowup
        -:   98:    {
        -:   99:    int  l;
        -:  100:    int u;
        -:  101:    int s; /* NameStartChar */
        -:  102:    };
        -:  103:
        -:  104:struct lowup lu[] =
        -:  105:    {     {'-','-',FALSE}
        -:  106:        , {'.','.',FALSE}
        -:  107:        , {'0','9',FALSE}
        -:  108:        , {':',':',TRUE}
        -:  109:        , {'A','Z',TRUE}
        -:  110:        , {'_','_',TRUE}
        -:  111:        , {'a','z',TRUE} 
        -:  112:        , {0xB7,0xB7,FALSE}
        -:  113:        , {0xC0,0xD6,TRUE} 
        -:  114:        , {0xD8,0xF6,TRUE}
        -:  115:        , {0xF8,0x2FF,TRUE}
        -:  116:        , {0x300,0x36F,FALSE}
        -:  117:        , {0x370,0x37D,TRUE}
        -:  118:        , {0x37F,0x1FFF,TRUE}
        -:  119:        , {0x200C,0x200D,TRUE}
        -:  120:        , {0x203F,0x2040,FALSE}
        -:  121:        , {0x2070,0x218F,TRUE}
        -:  122:        , {0x2C00,0x2FEF,TRUE}
        -:  123:        , {0x3001,0xD7FF,TRUE}
        -:  124:        , {0xF900,0xFDCF,TRUE}
        -:  125:        , {0xFDF0,0xFFFD,TRUE}
        -:  126:        , {0x10000,0xEFFFF,TRUE}
        -:  127:        , {0x7FFFFFFF,0x7FFFFFFF,TRUE}
        -:  128:    };
        -:  129:
        -:  130:#define BUFSIZE 35000
        -:  131:
        -:  132:static char * buf;
        -:  133:static char * p;
        -:  134:#if !ALWAYSREPLACEAMP
        -:  135:static char * q;
        -:  136:#endif
        -:  137:static int anychar = FALSE;
        -:  138:
        -:  139:static int (*namechar)(int c);
        -:  140:
     9106:  141:static int NameChar(int c)
        -:  142:    {
        -:  143:    int i;
    70779:  144:    for( i = 0
    61673:  145:       ; c > lu[i].u
    52567:  146:       ; ++i
        -:  147:       )
        -:  148:       ;
     9106:  149:    return c >= lu[i].l && (anychar || lu[i].s);        
        -:  150:    }
        -:  151:
       33:  152:static int decimal(int c)
        -:  153:    {
       33:  154:    if('0' <= c && c <= '9')
       33:  155:        return TRUE;
    #####:  156:    return FALSE;
        -:  157:    }
        -:  158:
    #####:  159:static int hex(int c)
        -:  160:    {
    #####:  161:    if(  ('0' <= c && c <= '9')
    #####:  162:      || ('A' <= c && c <= 'F')
    #####:  163:      || ('a' <= c && c <= 'f')
        -:  164:      )
    #####:  165:        return TRUE;
    #####:  166:    return FALSE;
        -:  167:    }
        -:  168:
       11:  169:static int number(int c)
        -:  170:    {
       11:  171:    if(c == 'x' || c == 'X')
        -:  172:        {
    #####:  173:        namechar = hex;
    #####:  174:        return TRUE;
        -:  175:        }
       11:  176:    if(decimal(c))
        -:  177:        {
       11:  178:        namechar = decimal;
       11:  179:        return TRUE;
        -:  180:        }
    #####:  181:    return FALSE;
        -:  182:    }
        -:  183:
     1310:  184:static int entity(int c)
        -:  185:    {
     1310:  186:    if(c == '#')
        -:  187:        {
       11:  188:        namechar = number;
       11:  189:        return TRUE;
        -:  190:        }
        -:  191:    else
        -:  192:        {
     1299:  193:        anychar = FALSE;
     1299:  194:        if(NameChar(c))
        -:  195:            {
     1299:  196:            anychar = TRUE;
     1299:  197:            namechar = NameChar;
     1299:  198:            return TRUE;
        -:  199:            }
        -:  200:        }
    #####:  201:    return FALSE;
        -:  202:    }
        -:  203:
        -:  204:#if !ALWAYSREPLACEAMP
        -:  205:static int charrefamp(char * c)
        -:  206:    {
        -:  207:    if(*c == ';')
        -:  208:        { /* Found something like &amp;security-level; */
        -:  209:        *p = '\0';
        -:  210:        rawput('&');
        -:  211:        nrawput(buf);
        -:  212:        rawput(';');
        -:  213:        p = buf;
        -:  214:        xput = Put;
        -:  215:        return FALSE;
        -:  216:        }
        -:  217:    else if(!namechar(*c))
        -:  218:        { /* Found something like &amp;security-level# */
        -:  219:        rawput('&');
        -:  220:        *p = '\0';
        -:  221:        nrawput(q);
        -:  222:        if(*c > 0)
        -:  223:            rawput(*c);
        -:  224:        p = buf;
        -:  225:        xput = Put;
        -:  226:        return FALSE;
        -:  227:        }
        -:  228:    else if(p < buf+BUFSIZE-1)
        -:  229:        {
        -:  230:        *p++ = *c;
        -:  231:        }
        -:  232:    return TRUE;
        -:  233:    }
        -:  234:#endif
        -:  235:
        -:  236:typedef struct Entity {char * ent;int code;} Entity;
        -:  237:static Entity entities[]={
        -:  238:{"AElig",198},	/* latin capital letter AE = latin capital ligature AE, U+00C6 ISOlat1 */
        -:  239:{"Aacute",193},	/* latin capital letter A with acute, U+00C1 ISOlat1 */
        -:  240:{"Acirc",194},	/* latin capital letter A with circumflex, U+00C2 ISOlat1 */
        -:  241:{"Agrave",192},	/* latin capital letter A with grave = latin capital letter A grave, U+00C0 ISOlat1 */
        -:  242:{"Alpha",913},	/* greek capital letter alpha, U+0391 */
        -:  243:{"Aring",197},	/* latin capital letter A with ring above = latin capital letter A ring, U+00C5 ISOlat1 */
        -:  244:{"Atilde",195},	/* latin capital letter A with tilde, U+00C3 ISOlat1 */
        -:  245:{"Auml",196},	/* latin capital letter A with diaeresis, U+00C4 ISOlat1 */
        -:  246:{"Beta",914},	/* greek capital letter beta, U+0392 */
        -:  247:{"Ccedil",199},	/* latin capital letter C with cedilla, U+00C7 ISOlat1 */
        -:  248:{"Chi",935},	/* greek capital letter chi, U+03A7 */
        -:  249:{"Dagger",8225},	/* double dagger, U+2021 ISOpub */
        -:  250:{"Delta",916},	/* greek capital letter delta, U+0394 ISOgrk3 */
        -:  251:{"ETH",208},	/* latin capital letter ETH, U+00D0 ISOlat1 */
        -:  252:{"Eacute",201},	/* latin capital letter E with acute, U+00C9 ISOlat1 */
        -:  253:{"Ecirc",202},	/* latin capital letter E with circumflex, U+00CA ISOlat1 */
        -:  254:{"Egrave",200},	/* latin capital letter E with grave, U+00C8 ISOlat1 */
        -:  255:{"Epsilon",917},	/* greek capital letter epsilon, U+0395 */
        -:  256:{"Eta",919},	/* greek capital letter eta, U+0397 */
        -:  257:{"Euml",203},	/* latin capital letter E with diaeresis, U+00CB ISOlat1 */
        -:  258:{"Gamma",915},	/* greek capital letter gamma, U+0393 ISOgrk3 */
        -:  259:{"Iacute",205},	/* latin capital letter I with acute, U+00CD ISOlat1 */
        -:  260:{"Icirc",206},	/* latin capital letter I with circumflex, U+00CE ISOlat1 */
        -:  261:{"Igrave",204},	/* latin capital letter I with grave, U+00CC ISOlat1 */
        -:  262:{"Iota",921},	/* greek capital letter iota, U+0399 */
        -:  263:{"Iuml",207},	/* latin capital letter I with diaeresis, U+00CF ISOlat1 */
        -:  264:{"Kappa",922},	/* greek capital letter kappa, U+039A */
        -:  265:{"Lambda",923},	/* greek capital letter lambda, U+039B ISOgrk3 */
        -:  266:{"Mu",924},	/* greek capital letter mu, U+039C */
        -:  267:{"Ntilde",209},	/* latin capital letter N with tilde, U+00D1 ISOlat1 */
        -:  268:{"Nu",925},	/* greek capital letter nu, U+039D */
        -:  269:{"OElig",338},	/* latin capital ligature OE, U+0152 ISOlat2 */
        -:  270:{"Oacute",211},	/* latin capital letter O with acute, U+00D3 ISOlat1 */
        -:  271:{"Ocirc",212},	/* latin capital letter O with circumflex, U+00D4 ISOlat1 */
        -:  272:{"Ograve",210},	/* latin capital letter O with grave, U+00D2 ISOlat1 */
        -:  273:{"Omega",937},	/* greek capital letter omega, U+03A9 ISOgrk3 */
        -:  274:{"Omicron",927},	/* greek capital letter omicron, U+039F */
        -:  275:{"Oslash",216},	/* latin capital letter O with stroke = latin capital letter O slash, U+00D8 ISOlat1 */
        -:  276:{"Otilde",213},	/* latin capital letter O with tilde, U+00D5 ISOlat1 */
        -:  277:{"Ouml",214},	/* latin capital letter O with diaeresis, U+00D6 ISOlat1 */
        -:  278:{"Phi",934},	/* greek capital letter phi, U+03A6 ISOgrk3 */
        -:  279:{"Pi",928},	/* greek capital letter pi, U+03A0 ISOgrk3 */
        -:  280:{"Prime",8243},	/* double prime = seconds = inches, U+2033 ISOtech */
        -:  281:{"Psi",936},	/* greek capital letter psi, U+03A8 ISOgrk3 */
        -:  282:{"Rho",929},	/* greek capital letter rho, U+03A1 */
        -:  283:{"Scaron",352},	/* latin capital letter S with caron, U+0160 ISOlat2 */
        -:  284:{"Sigma",931},	/* greek capital letter sigma, U+03A3 ISOgrk3 */
        -:  285:{"THORN",222},	/* latin capital letter THORN, U+00DE ISOlat1 */
        -:  286:{"Tau",932},	/* greek capital letter tau, U+03A4 */
        -:  287:{"Theta",920},	/* greek capital letter theta, U+0398 ISOgrk3 */
        -:  288:{"Uacute",218},	/* latin capital letter U with acute, U+00DA ISOlat1 */
        -:  289:{"Ucirc",219},	/* latin capital letter U with circumflex, U+00DB ISOlat1 */
        -:  290:{"Ugrave",217},	/* latin capital letter U with grave, U+00D9 ISOlat1 */
        -:  291:{"Upsilon",933},	/* greek capital letter upsilon, U+03A5 ISOgrk3 */
        -:  292:{"Uuml",220},	/* latin capital letter U with diaeresis, U+00DC ISOlat1 */
        -:  293:{"Xi",926},	/* greek capital letter xi, U+039E ISOgrk3 */
        -:  294:{"Yacute",221},	/* latin capital letter Y with acute, U+00DD ISOlat1 */
        -:  295:{"Yuml",376},	/* latin capital letter Y with diaeresis, U+0178 ISOlat2 */
        -:  296:{"Zeta",918},	/* greek capital letter zeta, U+0396 */
        -:  297:{"aacute",225},	/* latin small letter a with acute, U+00E1 ISOlat1 */
        -:  298:{"acirc",226},	/* latin small letter a with circumflex, U+00E2 ISOlat1 */
        -:  299:{"acute",180},	/* acute accent = spacing acute, U+00B4 ISOdia */
        -:  300:{"aelig",230},	/* latin small letter ae = latin small ligature ae, U+00E6 ISOlat1 */
        -:  301:{"agrave",224},	/* latin small letter a with grave = latin small letter a grave, U+00E0 ISOlat1 */
        -:  302:{"alefsym",8501},	/* alef symbol = first transfinite cardinal, U+2135 NEW */
        -:  303:{"alpha",945},	/* greek small letter alpha, U+03B1 ISOgrk3 */
        -:  304:/*{"amp",38},*/	/* ampersand, U+0026 ISOnum */
        -:  305:{"and",8743},	/* logical and = wedge, U+2227 ISOtech */
        -:  306:{"ang",8736},	/* angle, U+2220 ISOamso */
        -:  307:{"aring",229},	/* latin small letter a with ring above = latin small letter a ring, U+00E5 ISOlat1 */
        -:  308:{"asymp",8776},	/* almost equal to = asymptotic to, U+2248 ISOamsr */
        -:  309:{"atilde",227},	/* latin small letter a with tilde, U+00E3 ISOlat1 */
        -:  310:{"auml",228},	/* latin small letter a with diaeresis, U+00E4 ISOlat1 */
        -:  311:{"bdquo",8222},	/* double low-9 quotation mark, U+201E NEW */
        -:  312:{"beta",946},	/* greek small letter beta, U+03B2 ISOgrk3 */
        -:  313:{"brvbar",166},	/* broken bar = broken vertical bar, U+00A6 ISOnum */
        -:  314:{"bull",8226},	/* bullet = black small circle, U+2022 ISOpub */
        -:  315:{"cap",8745},	/* intersection = cap, U+2229 ISOtech */
        -:  316:{"ccedil",231},	/* latin small letter c with cedilla, U+00E7 ISOlat1 */
        -:  317:{"cedil",184},	/* cedilla = spacing cedilla, U+00B8 ISOdia */
        -:  318:{"cent",162},	/* cent sign, U+00A2 ISOnum */
        -:  319:{"chi",967},	/* greek small letter chi, U+03C7 ISOgrk3 */
        -:  320:{"circ",710},	/* modifier letter circumflex accent, U+02C6 ISOpub */
        -:  321:{"clubs",9827},	/* black club suit = shamrock, U+2663 ISOpub */
        -:  322:{"cong",8773},	/* approximately equal to, U+2245 ISOtech */
        -:  323:{"copy",169},	/* copyright sign, U+00A9 ISOnum */
        -:  324:{"crarr",8629},	/* downwards arrow with corner leftwards = carriage return, U+21B5 NEW */
        -:  325:{"cup",8746},	/* union = cup, U+222A ISOtech */
        -:  326:{"curren",164},	/* currency sign, U+00A4 ISOnum */
        -:  327:{"dArr",8659},	/* downwards double arrow, U+21D3 ISOamsa */
        -:  328:{"dagger",8224},	/* dagger, U+2020 ISOpub */
        -:  329:{"darr",8595},	/* downwards arrow, U+2193 ISOnum */
        -:  330:{"deg",176},	/* degree sign, U+00B0 ISOnum */
        -:  331:{"delta",948},	/* greek small letter delta, U+03B4 ISOgrk3 */
        -:  332:{"diams",9830},	/* black diamond suit, U+2666 ISOpub */
        -:  333:{"divide",247},	/* division sign, U+00F7 ISOnum */
        -:  334:{"eacute",233},	/* latin small letter e with acute, U+00E9 ISOlat1 */
        -:  335:{"ecirc",234},	/* latin small letter e with circumflex, U+00EA ISOlat1 */
        -:  336:{"egrave",232},	/* latin small letter e with grave, U+00E8 ISOlat1 */
        -:  337:{"empty",8709},	/* empty set = null set = diameter, U+2205 ISOamso */
        -:  338:{"emsp",8195},	/* em space, U+2003 ISOpub */
        -:  339:{"ensp",8194},	/* en space, U+2002 ISOpub */
        -:  340:{"epsilon",949},	/* greek small letter epsilon, U+03B5 ISOgrk3 */
        -:  341:{"equiv",8801},	/* identical to, U+2261 ISOtech */
        -:  342:{"eta",951},	/* greek small letter eta, U+03B7 ISOgrk3 */
        -:  343:{"eth",240},	/* latin small letter eth, U+00F0 ISOlat1 */
        -:  344:{"euml",235},	/* latin small letter e with diaeresis, U+00EB ISOlat1 */
        -:  345:{"euro",8364},	/* euro sign, U+20AC NEW */
        -:  346:{"exist",8707},	/* there exists, U+2203 ISOtech */
        -:  347:{"fnof",402},	/* latin small f with hook = function = florin, U+0192 ISOtech */
        -:  348:{"forall",8704},	/* for all, U+2200 ISOtech */
        -:  349:{"frac12",189},	/* vulgar fraction one half = fraction one half, U+00BD ISOnum */
        -:  350:{"frac14",188},	/* vulgar fraction one quarter = fraction one quarter, U+00BC ISOnum */
        -:  351:{"frac34",190},	/* vulgar fraction three quarters = fraction three quarters, U+00BE ISOnum */
        -:  352:{"frasl",8260},	/* fraction slash, U+2044 NEW */
        -:  353:{"gamma",947},	/* greek small letter gamma, U+03B3 ISOgrk3 */
        -:  354:{"ge",8805},	/* greater-than or equal to, U+2265 ISOtech */
        -:  355:/*{"gt",62},*/	/* greater-than sign, U+003E ISOnum */
        -:  356:{"hArr",8660},	/* left right double arrow, U+21D4 ISOamsa */
        -:  357:{"harr",8596},	/* left right arrow, U+2194 ISOamsa */
        -:  358:{"hearts",9829},	/* black heart suit = valentine, U+2665 ISOpub */
        -:  359:{"hellip",8230},	/* horizontal ellipsis = three dot leader, U+2026 ISOpub */
        -:  360:{"iacute",237},	/* latin small letter i with acute, U+00ED ISOlat1 */
        -:  361:{"icirc",238},	/* latin small letter i with circumflex, U+00EE ISOlat1 */
        -:  362:{"iexcl",161},	/* inverted exclamation mark, U+00A1 ISOnum */
        -:  363:{"igrave",236},	/* latin small letter i with grave, U+00EC ISOlat1 */
        -:  364:{"image",8465},	/* blackletter capital I = imaginary part, U+2111 ISOamso */
        -:  365:{"infin",8734},	/* infinity, U+221E ISOtech */
        -:  366:{"int",8747},	/* integral, U+222B ISOtech */
        -:  367:{"iota",953},	/* greek small letter iota, U+03B9 ISOgrk3 */
        -:  368:{"iquest",191},	/* inverted question mark = turned question mark, U+00BF ISOnum */
        -:  369:{"isin",8712},	/* element of, U+2208 ISOtech */
        -:  370:{"iuml",239},	/* latin small letter i with diaeresis, U+00EF ISOlat1 */
        -:  371:{"kappa",954},	/* greek small letter kappa, U+03BA ISOgrk3 */
        -:  372:{"lArr",8656},	/* leftwards double arrow, U+21D0 ISOtech */
        -:  373:{"lambda",955},	/* greek small letter lambda, U+03BB ISOgrk3 */
        -:  374:{"lang",9001},	/* left-pointing angle bracket = bra, U+2329 ISOtech */
        -:  375:{"laquo",171},	/* left-pointing double angle quotation mark = left pointing guillemet, U+00AB ISOnum */
        -:  376:{"larr",8592},	/* leftwards arrow, U+2190 ISOnum */
        -:  377:{"lceil",8968},	/* left ceiling = apl upstile, U+2308 ISOamsc */
        -:  378:{"ldquo",8220},	/* left double quotation mark, U+201C ISOnum */
        -:  379:{"le",8804},	/* less-than or equal to, U+2264 ISOtech */
        -:  380:{"lfloor",8970},	/* left floor = apl downstile, U+230A ISOamsc */
        -:  381:{"lowast",8727},	/* asterisk operator, U+2217 ISOtech */
        -:  382:{"loz",9674},	/* lozenge, U+25CA ISOpub */
        -:  383:{"lrm",8206},	/* left-to-right mark, U+200E NEW RFC 2070 */
        -:  384:{"lsaquo",8249},	/* single left-pointing angle quotation mark, U+2039 ISO proposed */
        -:  385:{"lsquo",8216},	/* left single quotation mark, U+2018 ISOnum */
        -:  386:/*{"lt",60},*/	/* less-than sign, U+003C ISOnum */
        -:  387:{"macr",175},	/* macron = spacing macron = overline = APL overbar, U+00AF ISOdia */
        -:  388:{"mdash",8212},	/* em dash, U+2014 ISOpub */
        -:  389:{"micro",181},	/* micro sign, U+00B5 ISOnum */
        -:  390:{"middot",183},	/* middle dot = Georgian comma = Greek middle dot, U+00B7 ISOnum */
        -:  391:{"minus",8722},	/* minus sign, U+2212 ISOtech */
        -:  392:{"mu",956},	/* greek small letter mu, U+03BC ISOgrk3 */
        -:  393:{"nabla",8711},	/* nabla = backward difference, U+2207 ISOtech */
        -:  394:{"nbsp",160},	/* no-break space = non-breaking space, U+00A0 ISOnum */
        -:  395:{"ndash",8211},	/* en dash, U+2013 ISOpub */
        -:  396:{"ne",8800},	/* not equal to, U+2260 ISOtech */
        -:  397:{"ni",8715},	/* contains as member, U+220B ISOtech */
        -:  398:{"not",172},	/* not sign, U+00AC ISOnum */
        -:  399:{"notin",8713},	/* not an element of, U+2209 ISOtech */
        -:  400:{"nsub",8836},	/* not a subset of, U+2284 ISOamsn */
        -:  401:{"ntilde",241},	/* latin small letter n with tilde, U+00F1 ISOlat1 */
        -:  402:{"nu",957},	/* greek small letter nu, U+03BD ISOgrk3 */
        -:  403:{"oacute",243},	/* latin small letter o with acute, U+00F3 ISOlat1 */
        -:  404:{"ocirc",244},	/* latin small letter o with circumflex, U+00F4 ISOlat1 */
        -:  405:{"oelig",339},	/* latin small ligature oe, U+0153 ISOlat2 */
        -:  406:{"ograve",242},	/* latin small letter o with grave, U+00F2 ISOlat1 */
        -:  407:{"oline",8254},	/* overline = spacing overscore, U+203E NEW */
        -:  408:{"omega",969},	/* greek small letter omega, U+03C9 ISOgrk3 */
        -:  409:{"omicron",959},	/* greek small letter omicron, U+03BF NEW */
        -:  410:{"oplus",8853},	/* circled plus = direct sum, U+2295 ISOamsb */
        -:  411:{"or",8744},	/* logical or = vee, U+2228 ISOtech */
        -:  412:{"ordf",170},	/* feminine ordinal indicator, U+00AA ISOnum */
        -:  413:{"ordm",186},	/* masculine ordinal indicator, U+00BA ISOnum */
        -:  414:{"oslash",248},	/* latin small letter o with stroke, = latin small letter o slash, U+00F8 ISOlat1 */
        -:  415:{"otilde",245},	/* latin small letter o with tilde, U+00F5 ISOlat1 */
        -:  416:{"otimes",8855},	/* circled times = vector product, U+2297 ISOamsb */
        -:  417:{"ouml",246},	/* latin small letter o with diaeresis, U+00F6 ISOlat1 */
        -:  418:{"para",182},	/* pilcrow sign = paragraph sign, U+00B6 ISOnum */
        -:  419:{"part",8706},	/* partial differential, U+2202 ISOtech */
        -:  420:{"permil",8240},	/* per mille sign, U+2030 ISOtech */
        -:  421:{"perp",8869},	/* up tack = orthogonal to = perpendicular, U+22A5 ISOtech */
        -:  422:{"phi",966},	/* greek small letter phi, U+03C6 ISOgrk3 */
        -:  423:{"pi",960},	/* greek small letter pi, U+03C0 ISOgrk3 */
        -:  424:{"piv",982},	/* greek pi symbol, U+03D6 ISOgrk3 */
        -:  425:{"plusmn",177},	/* plus-minus sign = plus-or-minus sign, U+00B1 ISOnum */
        -:  426:{"pound",163},	/* pound sign, U+00A3 ISOnum */
        -:  427:{"prime",8242},	/* prime = minutes = feet, U+2032 ISOtech */
        -:  428:{"prod",8719},	/* n-ary product = product sign, U+220F ISOamsb */
        -:  429:{"prop",8733},	/* proportional to, U+221D ISOtech */
        -:  430:{"psi",968},	/* greek small letter psi, U+03C8 ISOgrk3 */
        -:  431:/*{"quot",34},*/	/* quotation mark = APL quote, U+0022 ISOnum */
        -:  432:{"rArr",8658},	/* rightwards double arrow, U+21D2 ISOtech */
        -:  433:{"radic",8730},	/* square root = radical sign, U+221A ISOtech */
        -:  434:{"rang",9002},	/* right-pointing angle bracket = ket, U+232A ISOtech */
        -:  435:{"raquo",187},	/* right-pointing double angle quotation mark = right pointing guillemet, U+00BB ISOnum */
        -:  436:{"rarr",8594},	/* rightwards arrow, U+2192 ISOnum */
        -:  437:{"rceil",8969},	/* right ceiling, U+2309 ISOamsc */
        -:  438:{"rdquo",8221},	/* right double quotation mark, U+201D ISOnum */
        -:  439:{"real",8476},	/* blackletter capital R = real part symbol, U+211C ISOamso */
        -:  440:{"reg",174},	/* registered sign = registered trade mark sign, U+00AE ISOnum */
        -:  441:{"rfloor",8971},	/* right floor, U+230B ISOamsc */
        -:  442:{"rho",961},	/* greek small letter rho, U+03C1 ISOgrk3 */
        -:  443:{"rlm",8207},	/* right-to-left mark, U+200F NEW RFC 2070 */
        -:  444:{"rsaquo",8250},	/* single right-pointing angle quotation mark, U+203A ISO proposed */
        -:  445:{"rsquo",8217},	/* right single quotation mark, U+2019 ISOnum */
        -:  446:{"sbquo",8218},	/* single low-9 quotation mark, U+201A NEW */
        -:  447:{"scaron",353},	/* latin small letter s with caron, U+0161 ISOlat2 */
        -:  448:{"sdot",8901},	/* dot operator, U+22C5 ISOamsb */
        -:  449:{"sect",167},	/* section sign, U+00A7 ISOnum */
        -:  450:{"shy",173},	/* soft hyphen = discretionary hyphen, U+00AD ISOnum */
        -:  451:{"sigma",963},	/* greek small letter sigma, U+03C3 ISOgrk3 */
        -:  452:{"sigmaf",962},	/* greek small letter final sigma, U+03C2 ISOgrk3 */
        -:  453:{"sim",8764},	/* tilde operator = varies with = similar to, U+223C ISOtech */
        -:  454:{"spades",9824},	/* black spade suit, U+2660 ISOpub */
        -:  455:{"sub",8834},	/* subset of, U+2282 ISOtech */
        -:  456:{"sube",8838},	/* subset of or equal to, U+2286 ISOtech */
        -:  457:{"sum",8721},	/* n-ary sumation, U+2211 ISOamsb */
        -:  458:{"sup",8835},	/* superset of, U+2283 ISOtech */
        -:  459:{"sup1",185},	/* superscript one = superscript digit one, U+00B9 ISOnum */
        -:  460:{"sup2",178},	/* superscript two = superscript digit two = squared, U+00B2 ISOnum */
        -:  461:{"sup3",179},	/* superscript three = superscript digit three = cubed, U+00B3 ISOnum */
        -:  462:{"supe",8839},	/* superset of or equal to, U+2287 ISOtech */
        -:  463:{"szlig",223},	/* latin small letter sharp s = ess-zed, U+00DF ISOlat1 */
        -:  464:{"tau",964},	/* greek small letter tau, U+03C4 ISOgrk3 */
        -:  465:{"there4",8756},	/* therefore, U+2234 ISOtech */
        -:  466:{"theta",952},	/* greek small letter theta, U+03B8 ISOgrk3 */
        -:  467:{"thetasym",977},	/* greek small letter theta symbol, U+03D1 NEW */
        -:  468:{"thinsp",8201},	/* thin space, U+2009 ISOpub */
        -:  469:{"thorn",254},	/* latin small letter thorn, U+00FE ISOlat1 */
        -:  470:{"tilde",732},	/* small tilde, U+02DC ISOdia */
        -:  471:{"times",215},	/* multiplication sign, U+00D7 ISOnum */
        -:  472:{"trade",8482},	/* trade mark sign, U+2122 ISOnum */
        -:  473:{"uArr",8657},	/* upwards double arrow, U+21D1 ISOamsa */
        -:  474:{"uacute",250},	/* latin small letter u with acute, U+00FA ISOlat1 */
        -:  475:{"uarr",8593},	/* upwards arrow, U+2191 ISOnum*/
        -:  476:{"ucirc",251},	/* latin small letter u with circumflex, U+00FB ISOlat1 */
        -:  477:{"ugrave",249},	/* latin small letter u with grave, U+00F9 ISOlat1 */
        -:  478:{"uml",168},	/* diaeresis = spacing diaeresis, U+00A8 ISOdia */
        -:  479:{"upsih",978},	/* greek upsilon with hook symbol, U+03D2 NEW */
        -:  480:{"upsilon",965},	/* greek small letter upsilon, U+03C5 ISOgrk3 */
        -:  481:{"uuml",252},	/* latin small letter u with diaeresis, U+00FC ISOlat1 */
        -:  482:{"weierp",8472},	/* script capital P = power set = Weierstrass p, U+2118 ISOamso */
        -:  483:{"xi",958},	/* greek small letter xi, U+03BE ISOgrk3 */
        -:  484:{"yacute",253},	/* latin small letter y with acute, U+00FD ISOlat1 */
        -:  485:{"yen",165},	/* yen sign = yuan sign, U+00A5 ISOnum */
        -:  486:{"yuml",255},	/* latin small letter y with diaeresis, U+00FF ISOlat1 */
        -:  487:{"zeta",950},	/* greek small letter zeta, U+03B6 ISOgrk3 */
        -:  488:{"zwj",8205},	/* zero width joiner, U+200D NEW RFC 2070 */
        -:  489:{"zwnj",8204}};	/* zero width non-joiner, U+200C NEW RFC 2070 */
        -:  490:
    #####:  491:int compareEntities(const void * a, const void * b)
        -:  492:    {
    #####:  493:    return strcmp(((Entity*)a)->ent,((Entity*)b)->ent);
        -:  494:    }
        -:  495:
        -:  496:static int HT = 0;
    10460:  497:static int charref(char * c)
        -:  498:    {
    10460:  499:    if(*c == ';')
        -:  500:        {
     1310:  501:        *p = '\0';
     1310:  502:        if(  !strcmp(buf,"amp")
     1270:  503:          || !strcmp(buf,"#38")
     1270:  504:          || !strcmp(buf,"#x26")
        -:  505:          )
        -:  506:#if ALWAYSREPLACEAMP
       40:  507:            rawput('&');
        -:  508:#else
        -:  509:            {
        -:  510:            *p++ = ';';
        -:  511:            q = p;
        -:  512:            namechar = entity;
        -:  513:            xput = charrefamp;
        -:  514:            return TRUE;
        -:  515:            }
        -:  516:#endif
     1270:  517:        else if(!strcmp(buf,"apos"))
    #####:  518:            rawput('\'');
     1270:  519:        else if(!strcmp(buf,"quot"))
        -:  520:            {
    #####:  521:            rawput('\"');
        -:  522:            }
     1270:  523:        else if(!strcmp(buf,"lt"))
       78:  524:            rawput('<');
     1192:  525:        else if(!strcmp(buf,"gt"))
       18:  526:            rawput('>');
     1174:  527:        else if(buf[0] == '#')
        -:  528:            {
        -:  529:            unsigned long N;
        -:  530:            char tmp[22];
       11:  531:            N = (buf[1] == 'x') ? strtoul(buf+2,NULL,16) : strtoul(buf+1,NULL,10);
       11:  532:            p = buf;
       11:  533:            xput = Put;
       11:  534:            if(putCodePoint(N,tmp))
        -:  535:                {
       11:  536:                return nrawput(tmp);
        -:  537:                }
        -:  538:            else
    #####:  539:                return 0;
        -:  540:            }
        -:  541:        else
        -:  542:            {
     1163:  543:            if(HT)
        -:  544:                {
        -:  545:                Entity * pItem;
        -:  546:                Entity key;
    #####:  547:                key.ent = buf;
    #####:  548:                pItem = (Entity*)bsearch( &key
        -:  549:                                        , entities
        -:  550:                                        , sizeof(entities)/sizeof(entities[0])
        -:  551:                                        , sizeof(entities[0])
        -:  552:                                        , compareEntities
        -:  553:                                        );
    #####:  554:                if (pItem!=NULL)
        -:  555:                    {
        -:  556:                    char tmp[22];
    #####:  557:                    p = buf;
    #####:  558:                    xput = Put;
    #####:  559:                    if(putCodePoint(pItem->code,tmp))
        -:  560:                        {
    #####:  561:                        return nrawput(tmp);
        -:  562:                        }
        -:  563:                    }
        -:  564:                }
     1163:  565:            rawput('&');
     1163:  566:            nrawput(buf);
     1163:  567:            rawput(';');
     1163:  568:            p = buf;
     1163:  569:            xput = Put;
     1163:  570:            return FALSE;
        -:  571:            }
      136:  572:        p = buf;
      136:  573:        xput = Put;
        -:  574:        }
     9150:  575:    else if(!namechar(*c))
        -:  576:        {
    #####:  577:        rawput('&');
    #####:  578:        *p = '\0';
    #####:  579:        nrawput(buf);
    #####:  580:        if(*c > 0)
    #####:  581:            rawput(*c);
    #####:  582:        p = buf;
    #####:  583:        xput = Put;
    #####:  584:        return FALSE;
        -:  585:        }
     9150:  586:    else if(p < buf+BUFSIZE-1)
        -:  587:        {
     9150:  588:        *p++ = *c;
        -:  589:        }
     9286:  590:    return TRUE;
        -:  591:    }
        -:  592:
   136015:  593:static int Put(char * c)
        -:  594:    {
   136015:  595:    if(*c == '&')
        -:  596:        {
     1310:  597:        xput = charref;
     1310:  598:        namechar = entity;
     1310:  599:        return TRUE;
        -:  600:        }
   134705:  601:    return rawput(*c);
        -:  602:    }
        -:  603:
    11145:  604:static void flush()
        -:  605:    {
    11145:  606:    if(xput != Put)
    #####:  607:        xput("");
    11145:  608:    }
        -:  609:
     6611:  610:static void nxput(char * start,char *end)
        -:  611:    {
    37351:  612:    for(;start < end;++start)
    30740:  613:        xput(start);
     6611:  614:    flush();
     6611:  615:    }
        -:  616:
      133:  617:static void nxputWithoutEntityUnfolding(char * start,char *end)
        -:  618:    {
    40846:  619:    for(;start < end;++start)
    40713:  620:        rawput(*start);
      133:  621:    }
        -:  622:
      133:  623:static void nonTagWithoutEntityUnfolding(char * kind,char * start,char * end)
        -:  624:    {
      133:  625:    nrawput(kind);
      133:  626:    putOperatorChar('.');
      133:  627:    nxputWithoutEntityUnfolding(start,end);
      133:  628:    putOperatorChar(')');
      133:  629:    }
        -:  630:
    #####:  631:static void nonTag(char * kind,char * start,char * end)
        -:  632:    {
    #####:  633:    nrawput(kind);
    #####:  634:    putOperatorChar('.');
    #####:  635:    nxput(start,end);
    #####:  636:    putOperatorChar(')');
    #####:  637:    }
        -:  638:
        -:  639:static char * ch;
        -:  640:static char * startScript = 0;
        -:  641:static char * startMarkup = NULL;
        -:  642:static char * startComment = NULL;
        -:  643:static char * startDOCTYPE = NULL;
        -:  644:static char * startCDATA = NULL;
        -:  645:static char * startElementName = NULL;
        -:  646:static char * startAttributeName = NULL;
        -:  647:static char * startValue = NULL;
        -:  648:
     4534:  649:static void cbStartMarkUp()/* called when <!X has been read, where X != [ or - */
        -:  650:    {
     4534:  651:    flush();
     4534:  652:    startMarkup = ch+2;
     4534:  653:    putOperatorChar(' ');
     4534:  654:    putOperatorChar('(');
     4534:  655:    }
        -:  656:
      116:  657:static void cbEndMarkUp()/* called when > has been read */
        -:  658:    {
      116:  659:    if(startMarkup)
    #####:  660:        nonTag("!",startMarkup,ch);
      116:  661:    }
        -:  662:
        1:  663:static void cbEndDOCTYPE()/* called when > has been read */
        -:  664:    {
        1:  665:    startMarkup = NULL;
        1:  666:    nonTagWithoutEntityUnfolding("!DOCTYPE",startDOCTYPE,ch);
        1:  667:    }
        -:  668:
     4401:  669:static void cbEndElementName()
        -:  670:    {
     4401:  671:    nxput(startElementName,ch);
     4401:  672:    putOperatorChar('.');
     4401:  673:    }
        -:  674:
     1105:  675:static void cbEndAttributeName()
        -:  676:    {
     1105:  677:    nxput(startAttributeName,ch);
     1105:  678:    putOperatorChar('.');
     1105:  679:    }
        -:  680:
     1105:  681:static void cbEndAttribute()
        -:  682:    {
     1105:  683:    putOperatorChar(')');
     1105:  684:    putOperatorChar(' ');
     1105:  685:    }
        -:  686:
        -:  687:static estate def(int kar);
        -:  688:static estate lt(int kar);
        -:  689:static estate element(int kar);
        -:  690:static estate elementonly(int kar);
        -:  691:static estate gt(int kar);
        -:  692:static estate emptytag(int kar);
        -:  693:static estate atts(int kar);
        -:  694:static estate name(int kar);
        -:  695:static estate value(int kar);
        -:  696:static estate atts_or_value(int kar);
        -:  697:static estate invalue(int kar);
        -:  698:static estate singlequotes(int kar);
        -:  699:static estate doublequotes(int kar);
        -:  700:static estate insinglequotedvalue(int kar);
        -:  701:static estate indoublequotedvalue(int kar);
        -:  702:static estate endvalue(int kar);
        -:  703:static estate markup(int kar); /* <! */
        -:  704:static estate unknownmarkup(int kar);
        -:  705:static estate script(int kar);
        -:  706:static estate endscript(int kar);
        -:  707:static estate DOCTYPE1(int kar); /* <!D */
        -:  708:static estate DOCTYPE7(int kar); /* <!DOCTYPE */
        -:  709:static estate DOCTYPE8(int kar); /* <!DOCTYPE S */
        -:  710:static estate DOCTYPE9(int kar); /* <!DOCTYPE S [ */
        -:  711:static estate DOCTYPE10(int kar); /* <!DOCTYPE S [ ] */
        -:  712:static estate CDATA1(int kar); /* <![ */
        -:  713:static estate CDATA7(int kar); /* <![CDATA[ */
        -:  714:static estate CDATA8(int kar); /* <![CDATA[ ] */
        -:  715:static estate CDATA9(int kar); /* <![CDATA[ ]] */
        -:  716:static estate h1(int kar); /* <!- */
        -:  717:static estate h2(int kar); /* <!-- */
        -:  718:static estate h3(int kar); /* <!--  - */
        -:  719:static estate endtag(int kar);
        -:  720:
   120269:  721:static estate def(int kar)
        -:  722:    {
   120269:  723:    switch(kar)
        -:  724:        {
        -:  725:        case '<':
     4534:  726:            tagState = lt;
     4534:  727:            cbStartMarkUp();
     4534:  728:            return tag;
        -:  729:        default:
   115735:  730:            return notag;
        -:  731:        }
        -:  732:    }
        -:  733:
     4534:  734:static estate lt(int kar)
        -:  735:    {
     4534:  736:    switch(kar)
        -:  737:        {
        -:  738:        case '>':
    #####:  739:            tagState = def;
    #####:  740:            return notag;
        -:  741:        case '!':
      131:  742:            tagState = markup;
      131:  743:            return tag;
        -:  744:        case '?':
        2:  745:            startScript = ch;
        2:  746:            tagState = script;
        2:  747:            return tag;
        -:  748:        case '/':
     2174:  749:            putOperatorChar('.');
     2174:  750:            tagState = endtag;
        -:  751:        case 0xA0:
        -:  752:        case ' ':
        -:  753:        case '\t':
        -:  754:        case '\n':
        -:  755:        case '\r':
     2174:  756:            return tag;
        -:  757:        default:
     2227:  758:            if(('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
        -:  759:                {
     2227:  760:                tagState = element;
     2227:  761:                startElementName = ch;
     2227:  762:                return tag;
        -:  763:                }
        -:  764:            else
        -:  765:                {
    #####:  766:                tagState = def;
    #####:  767:                return notag;
        -:  768:                }
        -:  769:        }
        -:  770:    }
        -:  771:
     8314:  772:static estate element(int kar)
        -:  773:    {
     8314:  774:    switch(kar)
        -:  775:        {
        -:  776:        case '<':
    #####:  777:            tagState = lt;
    #####:  778:            cbEndElementName();
    #####:  779:            putOperatorChar(')');
    #####:  780:            cbStartMarkUp();
    #####:  781:            return endoftag_startoftag;
        -:  782:        case '>':
     1264:  783:            tagState = def;
     1264:  784:            cbEndElementName();
     1264:  785:            putOperatorChar(')');
     1264:  786:            return endoftag;
        -:  787:        case '-':
        -:  788:        case '_':
        -:  789:        case ':':
        -:  790:        case '.':
        7:  791:            return tag;
        -:  792:        case 0xA0:
        -:  793:        case ' ':
        -:  794:        case '\t':
        -:  795:        case '\n':
        -:  796:        case '\r':
      963:  797:            cbEndElementName();
      963:  798:            tagState = atts;
      963:  799:            return tag;
        -:  800:        case '/':
    #####:  801:            cbEndElementName();
    #####:  802:            putOperatorChar(',');
    #####:  803:            putOperatorChar(')');
    #####:  804:            tagState = emptytag;
    #####:  805:            return tag;
        -:  806:        default:
     6080:  807:            if(('0' <= kar && kar <= '9') || ('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
     6080:  808:                return tag;
        -:  809:            else
        -:  810:                {
    #####:  811:                tagState = def;
    #####:  812:                return notag;
        -:  813:                }
        -:  814:        }
        -:  815:    }
        -:  816:
     8141:  817:static estate elementonly(int kar)
        -:  818:    {
     8141:  819:    switch(kar)
        -:  820:        {
        -:  821:        case '<':
    #####:  822:            tagState = lt;
    #####:  823:            cbEndElementName();
    #####:  824:            putOperatorChar(')');
    #####:  825:            cbStartMarkUp();
    #####:  826:            return endoftag_startoftag;
        -:  827:        case '>':
     2174:  828:            tagState = def;
     2174:  829:            cbEndElementName();
     2174:  830:            putOperatorChar(')');
     2174:  831:            return endoftag;
        -:  832:        case '-':
        -:  833:        case '_':
        -:  834:        case ':':
        -:  835:        case '.':
        7:  836:            return tag;
        -:  837:        case 0xA0:
        -:  838:        case ' ':
        -:  839:        case '\t':
        -:  840:        case '\n':
        -:  841:        case '\r':
    #####:  842:            cbEndElementName();
    #####:  843:            tagState = gt;
    #####:  844:            return tag;
        -:  845:        default:
     5960:  846:            if(('0' <= kar && kar <= '9') || ('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
     5960:  847:                return tag;
        -:  848:            else
        -:  849:                {
    #####:  850:                tagState = def;
    #####:  851:                return notag;
        -:  852:                }
        -:  853:        }
        -:  854:    }
        -:  855:
    #####:  856:static estate gt(int kar)
        -:  857:    {
    #####:  858:    switch(kar)
        -:  859:        {
        -:  860:        case '<':
    #####:  861:            tagState = lt;
    #####:  862:            putOperatorChar(')');
    #####:  863:            cbStartMarkUp();
    #####:  864:            return endoftag_startoftag;
        -:  865:        case '>':
    #####:  866:            tagState = def;
    #####:  867:            putOperatorChar(')');
    #####:  868:            return endoftag;
        -:  869:        case 0xA0:
        -:  870:        case ' ':
        -:  871:        case '\t':
        -:  872:        case '\n':
        -:  873:        case '\r':
    #####:  874:            return tag;
        -:  875:        default:
    #####:  876:            tagState = def;
    #####:  877:            return notag;
        -:  878:        }
        -:  879:    }
        -:  880:
       53:  881:static estate emptytag(int kar)
        -:  882:    {
       53:  883:    switch(kar)
        -:  884:        {
        -:  885:        case '<':
    #####:  886:            tagState = lt;
    #####:  887:            cbStartMarkUp();
    #####:  888:            return endoftag_startoftag;
        -:  889:        case '>':
       53:  890:            tagState = def;
       53:  891:            return endoftag;
        -:  892:        case 0xA0:
        -:  893:        case ' ':
        -:  894:        case '\t':
        -:  895:        case '\n':
        -:  896:        case '\r':
    #####:  897:            return tag;
        -:  898:        default:
    #####:  899:            tagState = def;
    #####:  900:            return notag;
        -:  901:        }
        -:  902:    }
        -:  903:
     1115:  904:static estate atts(int kar)
        -:  905:    {
     1115:  906:    switch(kar)
        -:  907:        {
        -:  908:        case '<':
    #####:  909:            tagState = lt;
    #####:  910:            putOperatorChar(')');
    #####:  911:            cbStartMarkUp();
    #####:  912:            return endoftag_startoftag;
        -:  913:        case '>':
        1:  914:            tagState = def;
        1:  915:            putOperatorChar(')');
        1:  916:            return endoftag;
        -:  917:        case 0xA0:
        -:  918:        case ' ':
        -:  919:        case '\t':
        -:  920:        case '\n':
        -:  921:        case '\r':
        8:  922:            return tag;
        -:  923:        case '/':
        1:  924:            putOperatorChar(',');
        1:  925:            putOperatorChar(')');
        1:  926:            tagState = emptytag;
        1:  927:            return tag;
        -:  928:        default:
     1105:  929:            if(('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
        -:  930:                {
     1105:  931:                putOperatorChar('(');
     1105:  932:                startAttributeName = ch;
     1105:  933:                tagState = name;
     1105:  934:                return tag;
        -:  935:                }
        -:  936:            else
        -:  937:                {
    #####:  938:                tagState = def;
    #####:  939:                return notag;
        -:  940:                }
        -:  941:        }
        -:  942:    }
        -:  943:
     3527:  944:static estate name(int kar)
        -:  945:    {
     3527:  946:    switch(kar)
        -:  947:        {
        -:  948:        case '<':
    #####:  949:            tagState = lt;
    #####:  950:            cbEndAttributeName();
    #####:  951:            cbEndAttribute();
    #####:  952:            putOperatorChar(')');
    #####:  953:            cbStartMarkUp();
    #####:  954:            return endoftag_startoftag;
        -:  955:        case '>':
    #####:  956:            tagState = def;
    #####:  957:            cbEndAttributeName();
    #####:  958:            cbEndAttribute();
    #####:  959:            putOperatorChar(')');
    #####:  960:            return endoftag;
        -:  961:        case '-':
        -:  962:        case '_':
        -:  963:        case ':':
        -:  964:        case '.':
        7:  965:            return tag;
        -:  966:        case 0xA0:
        -:  967:        case ' ':
        -:  968:        case '\t':
        -:  969:        case '\n':
        -:  970:        case '\r':
    #####:  971:            cbEndAttributeName();
    #####:  972:            tagState = atts_or_value;
    #####:  973:            return tag;
        -:  974:        case '/':
    #####:  975:            cbEndAttributeName();
    #####:  976:            cbEndAttribute();
    #####:  977:            putOperatorChar(',');
    #####:  978:            tagState = emptytag;
    #####:  979:            return tag;
        -:  980:        case '=':
     1105:  981:            cbEndAttributeName();
     1105:  982:            tagState = value;
     1105:  983:            return tag;
        -:  984:        default:
     2415:  985:            if(('0' <= kar && kar <= '9') || ('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
     2415:  986:                return tag;
        -:  987:            else
        -:  988:                {
    #####:  989:                tagState = def;
    #####:  990:                return notag;
        -:  991:                }
        -:  992:        }
        -:  993:    }
        -:  994:
     1105:  995:static estate value(int kar)
        -:  996:    {
     1105:  997:    switch(kar)
        -:  998:        {
        -:  999:        case '>':
        -: 1000:        case '/':
        -: 1001:        case '=':
    #####: 1002:            tagState = def;
    #####: 1003:            return notag;
        -: 1004:        case 0xA0:
        -: 1005:        case ' ':
        -: 1006:        case '\t':
        -: 1007:        case '\n':
        -: 1008:        case '\r':
    #####: 1009:            return tag;
        -: 1010:        case '\'':
      735: 1011:            tagState = singlequotes;
      735: 1012:            return tag;
        -: 1013:        case '"':
      370: 1014:            tagState = doublequotes;
      370: 1015:            return tag;
        -: 1016:        default:
    #####: 1017:            if(('0' <= kar && kar <= '9') || ('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
        -: 1018:                {
    #####: 1019:                startValue = ch;
    #####: 1020:                tagState = invalue;
    #####: 1021:                return tag;
        -: 1022:                }
        -: 1023:            else
        -: 1024:                {
    #####: 1025:                tagState = def;
    #####: 1026:                return notag;
        -: 1027:                }
        -: 1028:        }
        -: 1029:    }
        -: 1030:
    #####: 1031:static estate atts_or_value(int kar)
        -: 1032:    {
    #####: 1033:    switch(kar)
        -: 1034:        {
        -: 1035:        case '<':
    #####: 1036:            tagState = lt;
    #####: 1037:            cbEndAttribute();
    #####: 1038:            putOperatorChar(')');
    #####: 1039:            cbStartMarkUp();
    #####: 1040:            return endoftag_startoftag;
        -: 1041:        case '>':
    #####: 1042:            tagState = def;
    #####: 1043:            cbEndAttribute();
    #####: 1044:            putOperatorChar(')');
    #####: 1045:            return endoftag;
        -: 1046:        case '-':
        -: 1047:        case '_':
        -: 1048:        case ':':
        -: 1049:        case '.':
    #####: 1050:            tagState = def;
    #####: 1051:            return notag;
        -: 1052:        case 0xA0:
        -: 1053:        case ' ':
        -: 1054:        case '\t':
        -: 1055:        case '\n':
        -: 1056:        case '\r':
    #####: 1057:            return tag;
        -: 1058:        case '/':
    #####: 1059:            cbEndAttribute();
    #####: 1060:            putOperatorChar(',');
    #####: 1061:            putOperatorChar(')');
    #####: 1062:            tagState = emptytag;
    #####: 1063:            return tag;
        -: 1064:        case '=':
    #####: 1065:            tagState = value;
    #####: 1066:            return tag;
        -: 1067:        default:
    #####: 1068:            if(('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
        -: 1069:                {
    #####: 1070:                cbEndAttribute();
    #####: 1071:                putOperatorChar('(');
    #####: 1072:                startAttributeName = ch;
    #####: 1073:                tagState = name;
    #####: 1074:                return tag;
        -: 1075:                }
        -: 1076:            else
        -: 1077:                {
    #####: 1078:                tagState = def;
    #####: 1079:                return notag;
        -: 1080:                }
        -: 1081:        }
        -: 1082:    }
        -: 1083:
    #####: 1084:static estate invalue(int kar)
        -: 1085:    {
    #####: 1086:    switch(kar)
        -: 1087:        {
        -: 1088:        case '<':
    #####: 1089:            tagState = lt;
    #####: 1090:            nxput(startValue,ch);
    #####: 1091:            cbEndAttribute();
    #####: 1092:            putOperatorChar(')');
    #####: 1093:            cbStartMarkUp();
    #####: 1094:            return endoftag_startoftag;
        -: 1095:        case '>':
    #####: 1096:            tagState = def;
    #####: 1097:            nxput(startValue,ch);
    #####: 1098:            cbEndAttribute();
    #####: 1099:            putOperatorChar(')');
    #####: 1100:            return endoftag;
        -: 1101:        case 0xA0:
        -: 1102:        case ' ':
        -: 1103:        case '\t':
        -: 1104:        case '\n':
        -: 1105:        case '\r':
    #####: 1106:            nxput(startValue,ch);
    #####: 1107:            cbEndAttribute();
    #####: 1108:            tagState = atts;
    #####: 1109:            return tag;
        -: 1110:        default:
    #####: 1111:            if(('0' <= kar && kar <= '9') || ('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
        -: 1112:                {
    #####: 1113:                return tag;
        -: 1114:                }
        -: 1115:            else
        -: 1116:                {
    #####: 1117:                tagState = def;
    #####: 1118:                return notag;
        -: 1119:                }
        -: 1120:        }
        -: 1121:    }
        -: 1122:
      735: 1123:static estate singlequotes(int kar)
        -: 1124:    {
      735: 1125:    startValue = ch;
      735: 1126:    switch(kar)
        -: 1127:        {
        -: 1128:        case '\'':
    #####: 1129:            nxput(startValue,ch);
    #####: 1130:            cbEndAttribute();
    #####: 1131:            tagState = endvalue;
    #####: 1132:            return tag;
        -: 1133:        default:
      735: 1134:            tagState = insinglequotedvalue;
      735: 1135:            return tag;
        -: 1136:        }
        -: 1137:    }
        -: 1138:
      370: 1139:static estate doublequotes(int kar)
        -: 1140:    {
      370: 1141:    startValue = ch;
      370: 1142:    switch(kar)
        -: 1143:        {
        -: 1144:        case '\"':
    #####: 1145:            nxput(startValue,ch);
    #####: 1146:            cbEndAttribute();
    #####: 1147:            tagState = endvalue;
    #####: 1148:            return tag;
        -: 1149:        default:
      370: 1150:            tagState = indoublequotedvalue;
      370: 1151:            return tag;
        -: 1152:        }
        -: 1153:    }
        -: 1154:
     7301: 1155:static estate insinglequotedvalue(int kar)
        -: 1156:    {
     7301: 1157:    switch(kar)
        -: 1158:        {
        -: 1159:        case '\'':
      735: 1160:            nxput(startValue,ch);
      735: 1161:            cbEndAttribute();
      735: 1162:            tagState = endvalue;
      735: 1163:            return tag;
        -: 1164:        default:
     6566: 1165:            return tag;
        -: 1166:        }
        -: 1167:    }
        -: 1168:
     3457: 1169:static estate indoublequotedvalue(int kar)
        -: 1170:    {
     3457: 1171:    switch(kar)
        -: 1172:        {
        -: 1173:        case '\"':
      370: 1174:            nxput(startValue,ch);
      370: 1175:            cbEndAttribute();
      370: 1176:            tagState = endvalue;
      370: 1177:            return tag;
        -: 1178:        default:
     3087: 1179:            return tag;
        -: 1180:        }
        -: 1181:    }
        -: 1182:
        -: 1183:
     1105: 1184:static estate endvalue(int kar)
        -: 1185:    {
     1105: 1186:    switch(kar)
        -: 1187:        {
        -: 1188:        case '<':
    #####: 1189:            tagState = lt;
    #####: 1190:            putOperatorChar(')');
    #####: 1191:            cbStartMarkUp();
    #####: 1192:            return endoftag_startoftag;
        -: 1193:        case '>':
      909: 1194:            tagState = def;
      909: 1195:            putOperatorChar(')');
      909: 1196:            return endoftag;
        -: 1197:        case 0xA0:
        -: 1198:        case ' ':
        -: 1199:        case '\t':
        -: 1200:        case '\n':
        -: 1201:        case '\r':
      144: 1202:            tagState = atts;
      144: 1203:            return tag;
        -: 1204:        case '/':
       52: 1205:            putOperatorChar(',');
       52: 1206:            putOperatorChar(')');
       52: 1207:            tagState = emptytag;
       52: 1208:            return tag;
        -: 1209:        default:
    #####: 1210:            tagState = def;
    #####: 1211:            return notag;
        -: 1212:        }
        -: 1213:    }
        -: 1214:
      247: 1215:static estate markup(int kar) /* <! */
        -: 1216:    {
      247: 1217:    switch(kar)
        -: 1218:        {
        -: 1219:        case '<':
    #####: 1220:            tagState = lt;
    #####: 1221:            cbEndMarkUp();
    #####: 1222:            cbStartMarkUp();
    #####: 1223:            return endoftag_startoftag;
        -: 1224:        case '>':
      116: 1225:            tagState = def;
      116: 1226:            cbEndMarkUp();
      116: 1227:            return endoftag;
        -: 1228:        case '-':
      116: 1229:            tagState = h1;
      116: 1230:            return tag;
        -: 1231:        case '[':
       14: 1232:            tagState = CDATA1;
       14: 1233:            return tag;
        -: 1234:        case 'D':
        1: 1235:            tagState = DOCTYPE1;
        1: 1236:            return tag;
        -: 1237:        default:
    #####: 1238:            tagState = unknownmarkup;
    #####: 1239:            return tag;
        -: 1240:        }
        -: 1241:    }
        -: 1242:
    #####: 1243:static estate unknownmarkup(int kar) /* <! */
        -: 1244:    {
    #####: 1245:    switch(kar)
        -: 1246:        {
        -: 1247:        case '<':
    #####: 1248:            tagState = lt;
    #####: 1249:            cbEndMarkUp();
    #####: 1250:            cbStartMarkUp();
    #####: 1251:            return endoftag_startoftag;
        -: 1252:        case '>':
    #####: 1253:            tagState = def;
    #####: 1254:            cbEndMarkUp();
    #####: 1255:            return endoftag;
        -: 1256:        default:
    #####: 1257:            return tag;
        -: 1258:        }
        -: 1259:    }
        -: 1260:
       33: 1261:static estate script(int kar)
        -: 1262:    {
       33: 1263:    switch(kar)
        -: 1264:        {
        -: 1265:        case '<':
    #####: 1266:            tagState = lt;
    #####: 1267:            nonTagWithoutEntityUnfolding("?",startScript+1,ch-1);
    #####: 1268:            cbStartMarkUp();
    #####: 1269:            return endoftag_startoftag;
        -: 1270:        case '>':
    #####: 1271:            tagState = def;
    #####: 1272:            nonTagWithoutEntityUnfolding("?",startScript+1,ch-1);
    #####: 1273:            return endoftag;
        -: 1274:        case '?':
        2: 1275:            tagState = endscript;
        2: 1276:            return tag;
        -: 1277:        default:
       31: 1278:            return tag;
        -: 1279:        }
        -: 1280:    }
        -: 1281:
        2: 1282:static estate endscript(int kar)
        -: 1283:    {
        2: 1284:    switch(kar)
        -: 1285:        {
        -: 1286:        case '>':
        2: 1287:            tagState = def;
        2: 1288:            nonTagWithoutEntityUnfolding("?",startScript+1,ch-1);
        2: 1289:            return endoftag;
        -: 1290:        default:
    #####: 1291:            tagState = CDATA7;
    #####: 1292:            return tag;
        -: 1293:        }
        -: 1294:    }
        -: 1295:
        -: 1296:static int doctypei = 0;
        6: 1297:static estate DOCTYPE1(int kar) /* <!D */
        -: 1298:    {
        -: 1299:    static char octype[] = "OCTYPE";
        -: 1300:    static int doctypei = 0;
        6: 1301:    switch(kar)
        -: 1302:        {
        -: 1303:        case '<':
    #####: 1304:            tagState = lt;
    #####: 1305:            cbStartMarkUp();
    #####: 1306:            doctypei = 0;
    #####: 1307:            return endoftag_startoftag;
        -: 1308:        case '>':
    #####: 1309:            tagState = def;
    #####: 1310:            doctypei = 0;
    #####: 1311:            return endoftag;
        -: 1312:        default:
        6: 1313:            if(kar == octype[doctypei])
        -: 1314:                {
        6: 1315:                if(doctypei == sizeof(octype) - 2)
        -: 1316:                    {
        1: 1317:                    tagState = DOCTYPE7;
        -: 1318:                    }
        -: 1319:                else
        5: 1320:                    ++doctypei;
        6: 1321:                return tag;
        -: 1322:                }
        -: 1323:            else
        -: 1324:                {
    #####: 1325:                doctypei = 0;
    #####: 1326:                tagState = unknownmarkup;
    #####: 1327:                return tag;
        -: 1328:                }
        -: 1329:        }
        -: 1330:    }
        -: 1331:
        -: 1332:
        1: 1333:static estate DOCTYPE7(int kar) /* <!DOCTYPE */
        -: 1334:    {
        1: 1335:    switch(kar)
        -: 1336:        {
        -: 1337:        case '<':
    #####: 1338:            tagState = lt;
    #####: 1339:            cbStartMarkUp();
    #####: 1340:            return endoftag_startoftag;
        -: 1341:        case '>':
    #####: 1342:            tagState = def;
    #####: 1343:            cbEndDOCTYPE();
    #####: 1344:            return endoftag;
        -: 1345:        case ' ':
        -: 1346:        case '\t':
        -: 1347:        case '\r':
        -: 1348:        case '\n':
        1: 1349:            startDOCTYPE = ch+1;
        1: 1350:            tagState = DOCTYPE8;
        1: 1351:            return tag;
        -: 1352:        default:
    #####: 1353:            tagState = unknownmarkup;
    #####: 1354:            return tag;
        -: 1355:        }
        -: 1356:    }
        -: 1357:
       24: 1358:static estate DOCTYPE8(int kar) /* <!DOCTYPE S */
        -: 1359:    {
       24: 1360:    switch(kar)
        -: 1361:        {
        -: 1362:        case '<':
    #####: 1363:            tagState = lt;
    #####: 1364:            cbStartMarkUp();
    #####: 1365:            return endoftag_startoftag;
        -: 1366:        case '>':
    #####: 1367:            tagState = def;
    #####: 1368:            cbEndDOCTYPE();
    #####: 1369:            return endoftag;
        -: 1370:        case '[':
        1: 1371:            tagState = DOCTYPE9;
        1: 1372:            return tag;
        -: 1373:        default:
       23: 1374:            return tag;
        -: 1375:        }
        -: 1376:    }
        -: 1377:
     6461: 1378:static estate DOCTYPE9(int kar)  /* <!DOCTYPE S [ */
        -: 1379:    {
     6461: 1380:    switch(kar)
        -: 1381:        {
        -: 1382:        case ']':
        1: 1383:            tagState = DOCTYPE10;
        1: 1384:            return tag;
        -: 1385:        default:
     6460: 1386:            tagState = DOCTYPE9;
     6460: 1387:            return tag;
        -: 1388:        }
        -: 1389:    }
        -: 1390:
        1: 1391:static estate DOCTYPE10(int kar)  /* <!DOCTYPE S [ ] */
        -: 1392:    {
        1: 1393:    switch(kar)
        -: 1394:        {
        -: 1395:        case '<':
    #####: 1396:            tagState = lt;
    #####: 1397:            cbStartMarkUp();
    #####: 1398:            return endoftag_startoftag;
        -: 1399:        case '>':
        1: 1400:            tagState = def;
        1: 1401:            cbEndDOCTYPE();
        1: 1402:            return endoftag;
        -: 1403:        case ' ':
        -: 1404:        case '\t':
        -: 1405:        case '\r':
        -: 1406:        case '\n':
    #####: 1407:            tagState = DOCTYPE10;
    #####: 1408:            return tag;
        -: 1409:        default:
    #####: 1410:            tagState = markup;
    #####: 1411:            return tag;
        -: 1412:        }
        -: 1413:    }
        -: 1414:
        -: 1415:
        -: 1416:static int cdatai = 0;
       84: 1417:static estate CDATA1(int kar) /* <![ */
        -: 1418:    {
        -: 1419:    static char cdata[] = "CDATA[";
       84: 1420:    switch(kar)
        -: 1421:        {
        -: 1422:        case '<':
    #####: 1423:            tagState = lt;
    #####: 1424:            cbStartMarkUp();
    #####: 1425:            cdatai = 0;
    #####: 1426:            return endoftag_startoftag;
        -: 1427:        case '>':
    #####: 1428:            tagState = def;
    #####: 1429:            cdatai = 0;
    #####: 1430:            return endoftag;
        -: 1431:        default:
       84: 1432:            if(cdata[cdatai] == kar)
        -: 1433:                {
       84: 1434:                if(cdatai == sizeof(cdata) - 2)
        -: 1435:                    {
       14: 1436:                    tagState = CDATA7;
       14: 1437:                    startCDATA = ch+1;
       14: 1438:                    cdatai = 0;
        -: 1439:                    }
        -: 1440:                else
       70: 1441:                    ++cdatai;
       84: 1442:                return tag;
        -: 1443:                }
        -: 1444:            else
        -: 1445:                {
    #####: 1446:                tagState = unknownmarkup;
    #####: 1447:                cdatai = 0;
    #####: 1448:                return tag;
        -: 1449:                }
        -: 1450:        }
        -: 1451:    }
        -: 1452:
     1685: 1453:static estate CDATA7(int kar) /* <![CDATA[ */
        -: 1454:    {
     1685: 1455:    switch(kar)
        -: 1456:        {
        -: 1457:        case ']':
       16: 1458:            tagState = CDATA8;
       16: 1459:            return tag;
        -: 1460:        default:
     1669: 1461:            return tag;
        -: 1462:        }
        -: 1463:    }
        -: 1464:
       16: 1465:static estate CDATA8(int kar) /* <![CDATA[ ] */
        -: 1466:    {
       16: 1467:    switch(kar)
        -: 1468:        {
        -: 1469:        case ']':
       14: 1470:            tagState = CDATA9;
       14: 1471:            return tag;
        -: 1472:        default:
        2: 1473:            tagState = CDATA7;
        2: 1474:            return tag;
        -: 1475:        }
        -: 1476:    }
        -: 1477:
       14: 1478:static estate CDATA9(int kar) /* <![CDATA[ ]] */
        -: 1479:    {
       14: 1480:    switch(kar)
        -: 1481:        {
        -: 1482:        case '>':  /* <![CDATA[ ]]> */
       14: 1483:            tagState = def;
       14: 1484:            startMarkup = NULL;
       14: 1485:            nonTagWithoutEntityUnfolding("![CDATA[",startCDATA,ch-2);
       14: 1486:            return endoftag;
        -: 1487:        default:
    #####: 1488:            tagState = CDATA7;
    #####: 1489:            return tag;
        -: 1490:        }
        -: 1491:    }
        -: 1492:
        -: 1493:
      116: 1494:static estate h1(int kar) /* <!- */
        -: 1495:    {
      116: 1496:    switch(kar)
        -: 1497:        {
        -: 1498:        case '<':
    #####: 1499:            tagState = lt;
    #####: 1500:            cbStartMarkUp();
    #####: 1501:            return notag;
        -: 1502:        case '>':
    #####: 1503:            tagState = def;
    #####: 1504:            return notag;
        -: 1505:        case '-':
      116: 1506:            tagState = h2;
      116: 1507:            startComment = ch+1;
      116: 1508:            return tag;
        -: 1509:        default:
    #####: 1510:            tagState = unknownmarkup;
    #####: 1511:            return tag;
        -: 1512:        }
        -: 1513:    }
        -: 1514:
    32333: 1515:static estate h2(int kar) /* <!-- */
        -: 1516:    {
    32333: 1517:    switch(kar)
        -: 1518:        {
        -: 1519:        case '-':
      423: 1520:            tagState = h3;
      423: 1521:            return tag;
        -: 1522:        default:
    31910: 1523:            return tag;
        -: 1524:        }
        -: 1525:    }
        -: 1526:
      423: 1527:static estate h3(int kar) /* <!--  - */
        -: 1528:    {
      423: 1529:    switch(kar)
        -: 1530:        {
        -: 1531:        case '-': /* <!-- -- */
      116: 1532:            tagState = markup;
      116: 1533:            startMarkup = NULL;
      116: 1534:            nonTagWithoutEntityUnfolding("!--",startComment,ch-1);
      116: 1535:            return tag;
        -: 1536:        default:
      307: 1537:            tagState = h2;
      307: 1538:            return tag;
        -: 1539:        }
        -: 1540:    }
        -: 1541:
     2174: 1542:static estate endtag(int kar)
        -: 1543:    {
     2174: 1544:    switch(kar)
        -: 1545:        {
        -: 1546:        case '<':
    #####: 1547:            tagState = lt;
    #####: 1548:            putOperatorChar(')');
    #####: 1549:            cbStartMarkUp();
    #####: 1550:            return endoftag_startoftag;
        -: 1551:        case '>':
    #####: 1552:            tagState = def;
    #####: 1553:            putOperatorChar(')');
    #####: 1554:            return endoftag;
        -: 1555:        case 0xA0:
        -: 1556:        case ' ':
        -: 1557:        case '\t':
        -: 1558:        case '\n':
        -: 1559:        case '\r':
    #####: 1560:            return tag;
        -: 1561:        default:
     2174: 1562:            if(('A' <= kar && kar <= 'Z') || ('a' <= kar && kar <= 'z') || (kar & 0x80))
        -: 1563:                {
     2174: 1564:                tagState = elementonly;
     2174: 1565:                startElementName = ch;
     2174: 1566:                return tag;
        -: 1567:                }
        -: 1568:            else
        -: 1569:                {
    #####: 1570:                tagState = def;
    #####: 1571:                return notag;
        -: 1572:                }
        -: 1573:        }
        -: 1574:    }
        -: 1575:
        1: 1576:int XMLtext(FILE * fpi,char * bron,int trim,int html)
        -: 1577:    {
        -: 1578:    int kar;
        1: 1579:    int retval = 0;
        1: 1580:    int inc = 0x10000;
        1: 1581:    int incs = 1;
        -: 1582:    LONG filesize;
        1: 1583:    if(fpi)
        -: 1584:        {
        1: 1585:        if(fpi == stdin)
        -: 1586:            {
    #####: 1587:            filesize = inc - 1;
        -: 1588:            }
        -: 1589:        else
        -: 1590:            {
        1: 1591:            fseek(fpi,0,SEEK_END);
        1: 1592:            filesize = ftell(fpi);
        1: 1593:            rewind(fpi);
        -: 1594:            }
        -: 1595:        }
    #####: 1596:    else if(bron)
        -: 1597:        {
    #####: 1598:        filesize = strlen(bron);
        -: 1599:        }
        -: 1600:    else
    #####: 1601:        return 0;
        1: 1602:    if(filesize > 0)
        -: 1603:        {
        -: 1604:        char * alltext;
        1: 1605:        doctypei = 0;
        1: 1606:        cdatai = 0;
        1: 1607:        retval = 1;
        1: 1608:        buf = (char*)malloc(BUFSIZE);
        1: 1609:        p = buf;
        -: 1610:#if !ALWAYSREPLACEAMP
        -: 1611:        q = buf;
        -: 1612:#endif
        1: 1613:        alltext = (fpi || trim) ? (char*)malloc(filesize+1) : bron;
        1: 1614:        HT = html;
        1: 1615:        if(buf && alltext)
        1: 1616:            {
        -: 1617:            char * curr_pos;
        -: 1618:            char * endpos;
        1: 1619:            estate Seq = notag;
        1: 1620:            if(trim)
        -: 1621:                {
    #####: 1622:                char * p = alltext;
    #####: 1623:                int whitespace = FALSE;
    #####: 1624:                if(fpi)
        -: 1625:                    {
    #####: 1626:                    while((kar = getc(fpi)) != EOF)
        -: 1627:                        {
    #####: 1628:                        switch(kar)
        -: 1629:                            {
        -: 1630:                            case ' ':
        -: 1631:                            case '\t':
        -: 1632:                            case '\n':
        -: 1633:                            case '\r':
        -: 1634:                                {
    #####: 1635:                                if(!whitespace)
        -: 1636:                                    {
    #####: 1637:                                    whitespace = TRUE;
    #####: 1638:                                    *p++ = ' ';
        -: 1639:                                    }
    #####: 1640:                                break;
        -: 1641:                                }
        -: 1642:                            default:
        -: 1643:                                {
    #####: 1644:                                whitespace = FALSE;
    #####: 1645:                                *p++ = (char)kar;
        -: 1646:                                }
        -: 1647:                            }
    #####: 1648:                        if(p >= alltext + incs * inc)
        -: 1649:                            {
    #####: 1650:                            size_t dif = p - alltext; 
    #####: 1651:                            ++incs;                            
    #####: 1652:                            alltext = realloc(alltext,incs * inc);
    #####: 1653:                            p = alltext + dif;
        -: 1654:                            }
        -: 1655:                        }
        -: 1656:                    }
        -: 1657:                else
        -: 1658:                    {
    #####: 1659:                    while((kar = *bron++) != 0)
        -: 1660:                        {
    #####: 1661:                        switch(kar)
        -: 1662:                            {
        -: 1663:                            case ' ':
        -: 1664:                            case '\t':
        -: 1665:                            case '\n':
        -: 1666:                            case '\r':
        -: 1667:                                {
    #####: 1668:                                if(!whitespace)
        -: 1669:                                    {
    #####: 1670:                                    whitespace = TRUE;
    #####: 1671:                                    *p++ = ' ';
        -: 1672:                                    }
    #####: 1673:                                break;
        -: 1674:                                }
        -: 1675:                            default:
        -: 1676:                                {
    #####: 1677:                                whitespace = FALSE;
    #####: 1678:                                *p++ = (char)kar;
        -: 1679:                                }
        -: 1680:                            }
        -: 1681:                        }
        -: 1682:                    }
    #####: 1683:                *p = '\0';
        -: 1684:                }
        1: 1685:            else if(fpi)
        -: 1686:                {
        1: 1687:                if(fpi == stdin)
        -: 1688:                    {
    #####: 1689:                    char * endp = alltext + incs * inc;
    #####: 1690:                    char * p = alltext;
    #####: 1691:                    while((kar = getc(fpi)) != EOF)
        -: 1692:                        {
    #####: 1693:                        *p++ = (char)kar;
    #####: 1694:                        if(p >= endp)
        -: 1695:                            {
    #####: 1696:                            size_t dif = p - alltext; 
    #####: 1697:                            ++incs;                            
    #####: 1698:                            alltext = realloc(alltext,incs * inc);
    #####: 1699:                            p = alltext + dif;
    #####: 1700:                            endp = alltext + incs * inc;
        -: 1701:                            }
        -: 1702:                        }
    #####: 1703:                    *p = '\0';
        -: 1704:                    }
        -: 1705:                else
        -: 1706:                    {
        1: 1707:                    LONG result = fread(alltext,1,filesize,fpi);
        -: 1708:                    assert(result <= filesize); 
        -: 1709:                    /* The file is perhaps not opened
        -: 1710:                    in binary mode, but in text mode. In that case the number of
        -: 1711:                    bytes read can be smaller than the number of bytes in the file.
        -: 1712:                    */
        1: 1713:                    alltext[result] = '\0';
        -: 1714:                    }
        -: 1715:                }
        -: 1716:
        1: 1717:            tagState = def;
        -: 1718:
        1: 1719:            ch = alltext;
        -: 1720:
        1: 1721:            curr_pos = alltext;
     4536: 1722:            while(*ch)
        -: 1723:                {
    87912: 1724:                while(  *ch 
    83378: 1725:                     && (( Seq = (*tagState)(*ch)) == tag 
     4534: 1726:                        || Seq == endoftag_startoftag
        -: 1727:                        )
        -: 1728:                     )
        -: 1729:                    {
    78844: 1730:                    ch++;
        -: 1731:                    }
     4534: 1732:                if(Seq == notag)
        -: 1733:                    { /* Not an HTML tag. Backtrack. */
    #####: 1734:                    endpos = ch;
    #####: 1735:                    ch = curr_pos;
    #####: 1736:                    while(ch < endpos)
        -: 1737:                        {
    #####: 1738:                        rawput(*ch);
    #####: 1739:                        ch++;
        -: 1740:                        }
        -: 1741:                    }
     4534: 1742:                else if(Seq == endoftag)
        -: 1743:                    {
     4534: 1744:                    putOperatorChar(' ');
     4534: 1745:                    ++ch; /* skip > */
        -: 1746:                    }
     4534: 1747:                if(*ch)
        -: 1748:                    {
   124803: 1749:                    while(  *ch 
   120268: 1750:                         && (Seq = (*tagState)(*ch)) == notag
        -: 1751:                         )
        -: 1752:                        {
   115735: 1753:                        xput(ch);
   115735: 1754:                        ++ch;
        -: 1755:                        }
     4534: 1756:                    if(Seq == tag)
        -: 1757:                        {
     4533: 1758:                        curr_pos = ch++; /* skip < */
        -: 1759:                        }
        -: 1760:                    }
        -: 1761:                }
        1: 1762:            if(Seq == tag)
        -: 1763:                { /* Incomplete SGML tag. Backtrack. */
    #####: 1764:                endpos = ch;
    #####: 1765:                ch = curr_pos;
    #####: 1766:                while(ch < endpos)
        -: 1767:                    {
    #####: 1768:                    rawput(*ch);
    #####: 1769:                    ch++;
        -: 1770:                    }
        -: 1771:                }
        -: 1772:            }
        -: 1773:        else
    #####: 1774:            retval = 0;
        1: 1775:        if(buf)
        1: 1776:            free(buf);
        1: 1777:        if(alltext && alltext != bron)
        1: 1778:            free(alltext);
        -: 1779:        }
        1: 1780:    return retval;
        -: 1781:    }
