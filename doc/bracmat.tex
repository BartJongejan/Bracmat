\documentclass[12pt]{article}

\usepackage[utf8]{inputenc}
%\usepackage{times}
\usepackage{fancyvrb}
\usepackage[x11names]{xcolor}
\usepackage[a4paper,margin=2.54cm]{geometry}
\usepackage{makeidx}
\usepackage{booktabs}
\usepackage[pdftex,colorlinks,linkcolor={blue!40!black},bookmarks]{hyperref}
\usepackage{tocloft}

\makeindex

\DefineVerbatimEnvironment
  {ex}
  {Verbatim}
  {baselinestretch=1.2,formatcom=\color{blue},vspace=0ex,xleftmargin=2em,commandchars=_\[\]}
\DefineVerbatimEnvironment
  {v}
  {Verbatim}
  {baselinestretch=1.2,vspace=0ex,xleftmargin=2em,commandchars=_\[\]}
\definecolor{comcolor}{HTML}{2D4D0E}
\newcommand{\com}[1]{\textcolor{comcolor}{\textrm{\{ #1 \}}}}
\newcommand{\coma}[1]{\textcolor{comcolor}{\textrm{\{ #1}}}
\newcommand{\comb}[1]{\textcolor{comcolor}{\textrm{\phantom{\{ }#1}}}
\newcommand{\comc}[1]{\textcolor{comcolor}{\textrm{\phantom{\{ }#1 \}}}}
\newcommand{\oct}{\color{Firebrick3}}
\newcommand{\dollar}{\$}
\newcommand{\bfun}[1]{\subsubsection*{\normalfont{#1}}}
\newcommand{\bc}[1]{\texttt{#1}}
\newcommand{\bi}[1]{\textit{#1}}
\renewcommand{\d}{\$}

\parindent=0cm
\parskip=1ex
\frenchspacing

\begin{document}

\title{Bracmat}
\author{Bart Jongejan}

\maketitle

\newpage

\tableofcontents

\newpage

\section{Introduction}

Bracmat makes it a joy to find your way in oddly shaped data and
manipulate it at your will. Bracmat occupies a niche were you find
few, if any, other computer programming languages.

This chapter may give you an impression of what Bracmat can do for
you.

\subsection{What is Bracmat?}

Bracmat is a computer programming language designed for analysis and
manipulation of complex data, be it evaluation of algebraic
expressions, parsing natural language, validation of HTML or automatic
chaining multifacetted webservices into a workflow. In several
projects, Bracmat has been combined with other programming languages
to take care of high level activities that otherwise would be very
time consuming to implement.

Bracmat was originally developed as a calculator for symbolic
algebra. Like a table calculator, Bracmat ran a Read Eval Print
Loop (REPL). It added, multiplied, took powers and logarithms and
differentiated algebraic expressions.

Later additions transformed the calculator into a programming
language. The subject matter, algebraic expressions, had often to be
destructured and recombined in a different way, e.g. to find terms
with like factors and recombining these into a group of new terms with
a common factor. What was needed was advanced pattern matching with a
notation that requires little more than your intuition to understand,
because the algebraic transformations to be implemented were already
hard enough to grasp. Envisioning that pattern matching also would be
very useful in natural language related problems, the subject domain
was extended to cover almost any kind of data.

True to its roots, Bracmat still has an important feature in common
with calculators: as long as the input data are simple enough, the
user does (and can) not specify how these data have to be
processed. Calculators handle basic calculations in a predictable,
unchangeable way, e.g. \verb|4+7| will always result in \verb|11|, and
not in, say, \verb|10| or \verb|23-12|. That is because the
manufacturer had good reasons to think that \verb|11| is what the user
expects and nothing else.

In the same way, Bracmat handles basic ``calculations'' with a much
wider variety of data: rational numbers, symbols, words and
collections thereof. For example, \verb|a+b+a| becomes \verb|2*a+b|
and not, say, \verb|x.a| or \verb|b+2*a|. Again, Bracmat takes
decisions that you can't easily circumvent. However, the more complex
the data are, the better are the chances that not all results,
although defensible, have an appearance that suits you. It is here
that programming comes in: Bracmat leaves certain kinds of data
unchanged, but opens the possibility to dissect data, to perform
calculations on the parts, and to assemble an answer from the
resulting subanswers.

Bracmat makes no distinction between data and instructions. All there
is are expressions. Some expressions stay the same upon evaluation,
other expressions change radically, and then there are expressions
that contain some parts that are stable upon evaluation and other
parts that change. The advantage of having the same syntax for data
and instructions is not in the first place that you could deconstruct
and recombine program code (generally not a good idea), but that you
can embed code in a data structure that adds more data upon
evaluation. Such code can function as growing tips in list or tree
structures, as variable fields in a standard letter, or as places of
particular interest inside a pattern, to name some examples.

Another advantage of not having to distinguish between code and data
is that reading a program and reading data from a file are no
different. And saving a program is the same as saving data to a
file. Which brings us to yet another enormous advantage: a Bracmat
expression is virtually undecipherable if it doesn't obey the
canonical layout rules, which are \ldots{} canonical. Whereas layout
doesn't matter to Bracmat, it does to you, and therefore Bracmat, when
asked to save an expression to file, imposes the canonical lay-out
rules on the output, unless you insist on wanting to have it all in
one line, no superfluous spaces allowed.

Bracmat expressions have a simple syntax: a mix of parentheses, binary
operators, operands and prefixes preceding those operands or
parentheses. When programmability was added to Bracmat, no new syntax
was invented, but only a few handfuls of prefixes and binary operators
dedicated to assignment, function calling, pattern matching and
program flow, in addition to the operators for addition,
multiplication, etc.

\subsection{Why use Bracmat?}

Bracmat is not a general purpose programming language, but a
programming language that was conceived in the 1980's with a single
aim: to make tedious algebraic manipulations easy and, most
importantly, not prone to human errors. Now hang on.

Many problems can be solved by following steps similar to those taken when solving an algebraic problem:
\begin{itemize}
\item Find stuff
\item Find the context of stuff
\item Sort stuff
\item Merge stuff
\item Combine stuff
\item Replace stuff
\item Cope with labyrinthine problems with many culs-de-sac
\end{itemize}

\subsection{User interaction with Bracmat}

Bracmat offers a simple environment for input of both data and
code. After the prompt \verb|{?}| you can write your input. When you
hit the return key, Bracmat evaluates your input and writes the result
to the screen following a \verb|{!}| sequence (unless there was no
visible result). Under the result follows a line that tells whether
the evaluation was successful (\verb|S|) or not (\verb|F|) (in rare
cases you may see an \verb|I|, which, for the time being, you may
interpret as failure). In the same line the machine shows how much
processor time it needed. Intermediary results may also appear on the
screen.

When instructions are entered from the keyboard, the program waits
until all of the conditions below are fulfilled:
\begin{itemize}
\item \emph{return} (or \emph{enter}) is the last key that has been pressed
\item every opening parenthesis has a closing counterpart
\item every opening brace (start of comment) has a closing counterpart
\item every string has either two enclosing double quotes, or none.
\end{itemize}

You can freely have parentheses and double quotes in a comment and you
can freely have parentheses and braces in a string, provided the
string is enclosed in double quotes.

You can write a multiple-line instruction by putting the instruction
inside an extra pair of parentheses. After each non-terminating
\emph{return}, Bracmat shows in the next line how many closing
parentheses are needed for the completion of the instruction. If you
are in the middle of a string or a comment when pressing
\emph{return}, the next line starts with \verb|{str}| or \verb|{com}|,
respectively.

If you want to enter several instructions on the same line, you should
write a semicolon \verb|;| between the instructions. These
instructions are executed in the same order. If you do not want to see
the result of a calculation, you may write a semicolon after the last
instruction. Instructions in a text file must be separated by
semicolons.

You may freely surround binary operators with whitespace characters
(e.g. space, tab, line feed). Take care not to put spaces between the
characters that make up a fraction or negative number,
\verb|- 1234 / 5678| is not the same as \verb|-1234/5678|.

Bracmat can open and read a text file and execute the instructions as
they are read. After the last instruction has been executed, the file
is closed. For example, the program that produces the text you are
reading just now, is read from a file named \verb|help| and
immediately executed.

The instruction for reading a file \verb|myprog| and executing the
instructions therein is \verb|get$myprog|. The \verb|$| is a binary
operator that initiates function evaluation. \verb|get| is the
function name of one of the few built-in functions.

The result of the last executed instruction in a file is written to
the screen. For better control over screen output one may use the
built-in function \verb|put|, which writes from the current cursor
position to the right, or the predefined (but changeable) function
\verb|out|, which writes an extra line feed after its argument has
been written to the screen.
\begin{ex}
{?} put_dollar(x*x);put_dollar(y+y)
_oct[]x^22*y{!} 2*y
\end{ex}

Often you will need the result of the last evaluated instruction in
the next instruction. You can use the exclamation mark \verb|!| instead of
re-entering the result. Example:
\begin{ex}
{?} 1+1
_oct{!} 2
{?} !^!^!^!
_oct{!} 65536
\end{ex}

When you write programs in the Bracmat language you will normally use
an external text editor. You can enter small programs directly at the
Bracmat prompt \verb|{?}|, but a small change in an instruction can
only be done by re-entering the whole instruction. You may save
instructions that are still held in memory, by the built-in \verb|lst|
function. This function takes a number of optional parameters that
tell the system whether the instruction has to be written in a compact
and barely readable form, or in a more pretty form, with lots of
indentations. Comments are never written, as they are ignored at input
time. As an example, you can write the definition of the predefined
factorisation function \verb|fct| to a file factorise by entering the
following instruction:
\begin{ex}
{?} lst_dollar(fct,factorise,NEW) _com[_bc[NEW]: replace old file with same name]
_oct{!} fct
\end{ex}

At first sight, a Bracmat program doesn't look like programs written
in other languages. This may even become a permanent impression. So
here are some recommendations about programming habits:
\begin{itemize}
\item Experiment with the examples in this document.
\item Use a modular and incremental style of programming: test every
  function before going on to the next one.
\item Keep functions small, to begin with. Error messages point to
  functions, not to line numbers.
\item Use meaningful names. There is no limit to their length and you
  may use the minus-sign as separator in multiple-word-names.
\item Let Bracmat indent your code: regularly save your code, read it
  in Bracmat, save it from Bracmat using the lst function to the file
  you are editing and reread the file in your editor.
\item Try to evade the ``not'' prefix \verb|~| and the use of arrays.
\end{itemize}

\subsection{Limitations}

Oddly enough, Bracmat has no operators for subtraction and
division. The reason is that these operations lack a very desirable
property: associativity. Addition and multiplication are associative,
because
\begin{v}
a+(b+c)
\end{v}
is equivalent with
\begin{v}
(a+b)+c
\end{v}
and can be written as
\begin{v}
a+b+c
\end{v}
On the other hand, subtraction and division are not associative, as
can be seen in this example
\begin{v}
a-(b-c)
\end{v}
which is not equivalent with
\begin{v}
(a-b)-c
\end{v}
because
\begin{v}
a-(b-c) = a-b+c
\end{v}
while
\begin{v}
(a-b)-c = a-b-c
\end{v}

So we see that an expression with binary minus operations and written
without parentheses is a left descending tree: the topmost binary
operator is the operator to the far right. And indeed, the first
incarnation of Bracmat internally represented sums and products as
left descending trees. However, we are used to see numerical factors
to the left of non-numerical symbols. If sums and products are
left-descending, adding \verb|3*a*b*c+4*a*b*c| becomes unnecessary
expensive
\begin{v}
3*a*b*c+4*a*b*c = ((3*a)*b)*c+((4*a)*b)*c
\end{v}

The first expensive step is finding the numerical factors \verb|3| and
\verb|4|, because they are several levels deep.

The second expensive step is that in the result
\begin{v}
((7*a)*b)*c
\end{v}
all multiplication operators necessarily have to be new nodes, so to
do this simple addition, 4 new nodes (one for the 7 and three for the
multiplication operators) had to be created. Compare this with a right
descending tree as the default internal representation for sums and
products:
\begin{v}
3*a*b*c+4*a*b*c = 3*(a*(b*c))+4*(a*(b*c))
\end{v}

The numerical factors are very close to the root of the tree and
therefore easy to find. Moreover, for the result
\begin{v}
7*(a*(b*c))
\end{v}
Bracmat only needs to create one node for the numerical factor
\verb|7| and one node for a single multiplication operator, because
the subexpression
\begin{v}
(a*(b*c))
\end{v}
can be shared with the original expression.

Fortunately, subtraction and division are unnecessary operations if
you have negative numbers and the operations of multiplication and
exponentiation, because
\begin{v}
a - b
\end{v}
can be written as
\begin{v}
a + -1 * b
\end{v}
and
\begin{v}
a / b
\end{v}
can be written as
\begin{v}
a * b ^ -1
\end{v}
A completely unrelated limitation is that in Bracmat, calculations
always have to be exact. Number expressions for which no rational
representation exists are not further evaluated. Bracmat knows how to
handle the special symbols \verb|i|, \verb|e| and \verb|pi|, but it
offers no numerical representation for \verb|e| and
\verb|pi|.

Examples:
\begin{ex}[baselinestretch=1.3,commandchars=_\[\]]
{?} a+b+-1*a            _com[this is how you subtract in Bracmat]
_oct{!} b
{?} 1+(1+i)*(1+-1*i)+-1 _coma[the leading and trailing terms]
                        _comc[force Bracmat to expand the product]
_oct{!} 2
{?} 12345/54321 ^ 1/2   _com[the square root of 12345/54321]
_oct{!} 5^1/2*19^-1/2*823^1/2*953^-1/2
{?} x^(a+x\L2*100)
_oct{!} 1267650600228229401496703205376*x^a
{?} 5/2 \L 987654
_oct{!} 15+5/2\L32363446272/3051757812
{?} y\D(x\D((x+y)^-2))
_oct{!} 6*(x+y)^-4
\end{ex}

Whereas Bracmat lacks floating point arithmetic, it can perform
arithmetic operations with integer and rational numbers and happily
adds and multiplies numbers with thousands of digits. Only available
computer memory and address size impose a limit to the size of
numerical operands, but before you decide to multiply two ten-million
digit numbers you should realize that Bracmat is not optimised for
number crunching on that scale.

Bracmat handles non-integer powers of positive rational numbers
(square root, for example) provided that the number (if it is an
integer) or the numerator and the denominator (if the number is a
fraction) are less than \verb|2^32| (or \verb|2^64|, if Bracmat is compiled
for a 64-bit platform).

There is a predefined function, \verb|flt$|, that represents rational
numbers in a scientific floating point notation, but Bracmat cannot do
calculations with these floating point numbers, unless you write a
function to convert them back to rational numbers.

\subsection{How Bracmat evolved}

Bracmat originated from a Basic program that was meant (and able) to
do some algebraic calculations in General Relativity. This program
could do the mathematical operations that Bracmat can: add, multiply,
take powers and logarithms and differentiate. This calculator was not
programmable, all program flow had to be done in Basic. It became
clear that the program could only solve the simplest algebraic
problems. The reason for this was its inability to recognise complex
patterns in the subject expressions. All pattern recognition had to be
done in Basic and this was a very fault prone business. It would be
nice to have an interpreter at hand that could interpret human
readable production rules. That is exactly what Bracmat embodies. This
program is written in ANSI C and developed on the fastest home
computer that existed at that time (Acorn Archimedes). Although
Bracmat is much faster than its predecessor, its main virtue lies in
its programmability and the advanced pattern matching. The speed at
which it processed formulae was not impressive, so Bracmat always
needed a fast machine. Fortunately computers have become faster and
faster, and nowadays Bracmat performs at a speed that is quite
acceptable, even in real time systems with users expecting immediate
responses.

Compared with other algebra systems, Bracmat has few built-in
functions and even its set of mathematical operators is small. There
are no operators for subtraction and division, for
example. Nevertheless, Bracmat is general and flexible enough to solve
even problems outside the field of computer algebra in an elegant
way. This flexibility on the programming level is traded off against
the inability to change the behaviour of the interpreter itself. There
are no switches (toggles) that could influence, for example, the order
of terms within a polynomial, or whether or not complex products are
expanded, or the way backtracking is done. This choice was, of course,
easier to implement, but it also has benefits for the user: the
working of Bracmat programs is not obscured by deep side effects of
switch settings. The only side effects that Bracmat allows are
expression binding and change of focus in a multiple valued variable
(array indexing, stacking). A later addition is support of objects,
i.e. data structures that allow for partial updates. This introduced
another kind of side effect.

One peculiar thing about the original, object-less Bracmat is the way
in which it manages data:
\begin{enumerate}
\item Processes are not periodically interrupted for garbage
  collection.
\item Each piece of data has a reference counter. If the reference
  counter equals zero, the occupied memory is returned to the memory
  pool at once. If the reference counter is about to overflow, a fresh
  copy of this piece of data is made with a reference counter set to
  one.
\item Data is only created and destroyed. It is never changed.
\item To the user, there is no difference between two expressions
  being equal, but stored in different parts of memory, and two
  expressions being two representations of the same parts of memory.
\item There is no facility for named fields within a data structure.
\end{enumerate}

Leaving one of these features out would have severe consequences for
the other features. (2) explains why (1) is true. (3) ensures that (2)
is workable: if two pieces of data are created equal they will remain
so. This, in turn, explains why (4) is true. (5) almost follows from
(3): in any full fledged programming language, named fields allow all
types of actions on the named parts of a data structure that are
allowed on whole data structures, that is: creation and
destruction. But the possibility to destroy only part of a data
structure means that the data structure as a whole is changeable,
which violates (3).

In the current version of Bracmat, with objects, the last restriction
(5) no longer exists. As a consequence, restrictions (3) and (4) are
not true for objects. (2) needs the additional remark that the
reference counter for objects is made so big (counting to more than
1000000000000 before overflowing), that overflow is practically ruled
out. Restriction (1) is still true, which means that the Bracmat
programmer must take care of the deletion of some pathological
structures (to be precise: circular structures, which were
non-existent in the object-less Bracmat).

How can a programming language that is created for handling data
structures do without named fields? If I only can create and destroy
data, how can I let data evolve gradually, piecemeal? The answer lies
in the well-developed pattern matching mechanism. Change of data is a
two step process. In the first step you retrieve, by means of pattern
matching, all those parts of the data that you want to keep. The
second step is building the new data from the retrieved parts,
together with new pieces. Creation of complex data structures from
parts is straightforward in Bracmat. For example, the variable
\verb|Row|\ is a list of three words. We want to change the second
word into the word \verb|cat|:
\begin{ex}
{?} the dog runs:?Row     _com[initial creation]
{?} !Row:%?one % %?three  _com[step 1: retrieval of 1st and 3rd word]
{?} !one cat !three:?Row  _com[step 2: reconstruction]
_oct{!} the cat runs
\end{ex}

This may seem complicated and cumbersome, but look at this:
\begin{ex}
{?} 123:?a                 _com[create three variables _bc[a], _bc[b] and _bc[c]]
{?} a sentence:?b
{?} (a.silly,data*structure):?c
{?} (!a.!b.!c):(?b.?c.?a)  _com[permutation of 3 values in just 1 ``statement'']
\end{ex}

Bracmat has no clear genealogy, but it has borrowed features from a
number of programming languages. It is not declarative, like Prolog,
nor deeply object oriented, like Smalltalk, but it is more or less
procedural, like the majority of languages. Below, I have tried to
make the origin of some details more explicit:

\begin{description}
\item C
  \begin{itemize}
  \item conditional execution of right operands of ``and'' and ``or''
  \item parameter passing (only ``by value'')
  \end{itemize}
  
\item Pascal
  \begin{itemize}
  \item locally defined functions and routines
  \end{itemize}

\item Lisp
  \begin{itemize}
  \item implementation of expressions in binary trees
  \item weak type checking
  \item late binding
  \end{itemize}
  
\item Logo
  \begin{itemize}
  \item different notations for the same variable, depending on whether
    it produces or receives a value
  \end{itemize}
  
\item Snobol, Icon
  \begin{itemize}
  \item a well developed pattern matching apparatus including
    backtracking
  \item dual results of evaluations: both value and success/failure
  \end{itemize}
\end{description}

Every similarity to other computer algebra systems is a matter of
evolutionary convergence.

\subsection{Why the name ``Bracmat''?}

The name Bracmat stems from Ludvig Holbergs novel ``Nicolai Klimii iter
subterraneum'', the history of Niels Klim who visits the planet Nazar
and comments the habits of its inhabitants. For example, the people of
the country Bracmat are clumsy juniper trees and Niels Klim initially
thinks they must be more or less blind. But he discovers that their
sight is so sharp that they can see the smallest details in the far
distance and therefore don't see what is right in front of them. They
are mostly occupied with astronomy and transcendental philosophy, but
the state also uses them to do prospection for minerals in the mines.

It so happens that the Latin word ``brachiatus,'' meaning ``with
arms'' or ``with branches'', in literature of botany often is
shortened to ``brachiat.'' I like to think that Ludvig Holberg, who
wrote the story in 1741, knew about the works of Carl Linnaeus
(1707--1778) and was inspired by him to populate his planet with smart
trees. The word ``bracmat'' is easily morphed into the word
``brachiat,'' and there is at least one case that can be found on the
internet where the Optical Character Reader has misinterpreted
``brachiat'' as ``bracmat,'' caused by a black speck that almost connects
the ``h'' and the ``i'' in the word ``brachiat!'' Whether true or not, this
derivation highlights one of the most prominent characteristics of the
programming language Bracmat: it is all about tree branches.

\subsection{How to obtain Bracmat}

There are a few download options. You can get the last revision from
\texttt{https://github.com/\allowbreak{}BartJongejan/\allowbreak{}Bracmat}.

At \texttt{http://cst.dk/download/bracmat/} you can follow the history
of Bracmat from its inception somewhere in the eighties up to the last
version. At this site you can also find compiled versions for some
platforms.

Alternatively, you can obtain a copy of Bracmat by sending an e-mail
to me (Bart Jongejan) at \texttt{bart[AT]cst.dk}. Please state your
hardware/OS.

\subsection{Where to find example code on the internet}

At \texttt{http://rosettacode.org/wiki/Category:Bracmat} over 100
tasks are solved using Bracmat. The site is an excellent way to
compare how the same task is solved in a great number of programming
languages.

\section{Pattern matching}

The single most outstanding feature of Bracmat is how it can recognise
patterns in data. The data can be an algebraic expression, a directory
listing in table form, a thesaurus structured like a tree, a text or
whatever data that can be expressed as a string of characters or as a
tree of such strings. Bracmat's patterns are much more advanced than
regular expressions. Regular expressions are fixed patterns once the
matching operation is started. Bracmat implements not only
propositional rules comparable to regular expressions, but also first
order predicate rules, backtracking to search the space of
combinations of data that make its predicates come true. In this way
it is very easy to implement a relational database. But it doesn't
stop here, because Bracmat supports recursive invocations of pattern
matching and other operations.

\subsection{Gentle introduction to pattern matching}

The following is an expression that tests whether a specific detail is
present in a list of nodes, a sum in this case:
\begin{ex}
{?} 20+a+b+c:?+b+?  _com[is there a term _bc[b] in the sum _bc[(20+a+b+c)]?]
_oct{!} 20+a+b+c
_oct    S   0,00 sec
\end{ex}

This is what happened. The match operator \verb|:| has a left hand
side which is the subject of the pattern, which is right hand side of
the match operator. If the match operation is to succeed, the pattern
must be similar to the subject. This is the case here, because the
question marks are similar to anything (like the Joker in some card
plays) and the \verb|b| is similar to itself. By the way, when a pattern
match operation succeeds, the resulting expression is the subject. The
second example shows a pattern match operation that fails:
\begin{ex}
{?} 20+a+b+c:?+q+?  _com[is there a term _bc[q] in the sum _bc[(20+a+b+c)]?]
_oct[]    F
\end{ex}
The \verb|q| in the pattern is not similar to anything in the subject
\verb|20+a+b+c| and thus the pattern match operation must fail.

The following examples are quite similar to the introductory example,
merely replacing the \verb|+| operator by the \verb|*| and the blank
operators:
\begin{ex}
{?} 20*a*b*c:?*b*?  _com[is there a factor _bc[b] in the product _bc[(20*a*b*c)]?]
_oct{!} 20*a*b*c
_oct    S   0,00 sec
{?} 20 a b c:? b ?  _com[is there a word _bc[b] in the sentence _bc[(20 a b c)]?]
_oct{!} 20 a b c
_oct    S   0,00 sec
\end{ex}

In the following example, the pattern applies to the characters in the
string, rather than to nodes in a list of terms, factors or words. The
\verb|@| that is prefixed to the match expression indicates to the
match operator that this is not the normal match operation, but a
string match operation.
\begin{ex}
{?} @(20abc:? b ?)  _com[is there a character _bc[b] in the string _bc[20abc]?]
_oct{!} 20abc
_oct    S   0,00 sec
\end{ex}

The patterns in string match operations are similar to patterns in
normal match operations that have sentences (words separated by blank
operators) as the subject.

\subsection{Rewriting data using pattern matching}

An important application of pattern matching is rewriting data by
means of a number of rules. Each rule consists of a pattern and a
replacement expression. Often, the pattern explicitly specifies only
parts of the subject, so that the same rule will fire for a broad
class of subjects, all having the specified parts of the rule in
common. The remaining, unspecified, parts normally have to reappear
unscathed in the output of the transformation rule. To catch these
parts, patterns can contain any number of variables that bind to the
parts of the rule that are not completely fixed.

Suppose we have the sentence \texttt{My name is Ivan the terrible} and
we want to change \texttt{Ivan} to \texttt{Wanja}. The following
instructions can do that:
\begin{ex}
{?} My name is Ivan the terrible:?begin Ivan ?end
_oct{!} My name is Ivan the terrible
{?} !begin Wanja !end
_oct{!} My name is Wanja the terrible
\end{ex}

A question mark indicates that the symbol that it precedes is a
variable that accepts (part of) the subject as value. An exclamation
mark indicates that the following symbol is supposed to be a variable
and that the value of that variable must replace the variable.

The pattern \verb|?begin Ivan ?end| and the replacement
\verb|!begin Wanja !end| are not sensitive to what the rest of the
sentence looks like, so we can use the same pattern and replacement
expression to transform another sentence:
\begin{ex}
{?} Ivan goes to school:?begin Ivan ?end
_oct{!} Ivan goes to school
{?} !begin Wanja !end
_oct{!} Wanja goes to school
\end{ex}

To make a rewrite rule out of these two components, we can put them in
a function that we can feed any sentence and that returns a
transformed sentence, if the pattern matched the input. In addition,
the function below simply returns the input if the pattern didn't
match.
\begin{ex}
{?} ( ivanRule
    =   begin end
      .     !arg:?begin Ivan ?end
          & !begin Wanja !end
        | !arg
    )
_oct{!} ivanRule
{?} ivanRule$(She bought a bicycle for Ivan)
_oct{!} She bought a bicycle for Wanja
\end{ex}
% $

\subsection{Non-linear patterns}

Bracmat patterns not only can contain receiving variables (those that
are preceded by a question mark), but also giving variables (those
that are preceded by an exclamation mark). The same variable symbol
can even occur in both roles: as receiving and as giving, in any
order. If an occurrence of a variable is receiving and a later in the
pattern giving, than the pattern is said to be non-linear. Such
patterns can for example be used to find things that occur more than
once in the subject. For example, find two inventions of the same age
in a list of name/year pairs:
\begin{ex}
{?} (   (teabag.1904) (sonar.1906) (computer.1941)
        (triode.1906) (zeppelin.1900)
      : ? (?invention1.?year) ? (?invention2.!year) ?
    & !invention1 !invention2
    )
_oct{!} sonar triode
\end{ex}

\subsection{Pattern matching with recursive patterns}

Many real life problems can be solved by first solving a less complex
problem. If needed, this process can be done again and again, until we
end with a problem that we know how to solve. In such cases, Bracmat's
ability to handle recursive patterns can be of much help.

Here is a rather academic example that defines a grammar with
recursive patterns and that checks whether an input is valid,
according to this grammar.
\begin{ex}
{?} S=(|0 !S|1 !T);T=(0 !T|1 !S);  _com[regular grammar]
{?} 0 1 0 1 0:!S  _com[check whether subject contains an even number of 1's]
_oct{!} 0 1 0 1 0
{?} P=(|0 ?x 1 & !x:!P);  _com[context free grammar]
{?} 0 0 0 1 1 1:!P  _coma[check whether subject consist of a row of 0's]
                    _comc[followed by a row of 1's of the same length]
_oct{!} 0 0 0 1 1 1
\end{ex}

The following example could be the basis for a journey planner. We use
a recursive pattern to find out whether two continents are connected
over land.

{
\fontsize{10}{11}\selectfont
\begin{ex}
{?} connected=("South America"."North America") (Africa.Asia) (Asia.Europe);
{?} (reachable = a b f
    .     !arg:(?a.?b.?f)
        & !f:? ((!a.!b)|(!b.!a)) ?
      |   !f:?A ((!a.?c)|(?c.!a)) ?Z
        & reachable_dollar(!c.!b.!A !Z)
    );  _com[remove used fact from fact base]
{?} (   Antarctic Europe Australia Africa Asia "North America" "South America"
    :   ?
        %@?x  _com[pick a continent]
        ?
        ( %@?y  _com[pick another continent]
        & reachable$(!x.!y.!connected) _com[are they reachable?]
        & out$(!x "is reachable from" !y)
        & ~  _com[force backtracking to collect all answers]
        )
        ?
    ); _com[pattern using second order logic]
_oct[]Europe is reachable from Africa
_oct[]Europe is reachable from Asia
_oct[]Africa is reachable from Asia
_oct[]North America is reachable from South America
\end{ex}
}

\subsection{Pattern matching in strings}

\verb|@(|\emph{string} \verb|:| \emph{pattern}\verb|)|

Match \emph{string} with \emph{pattern}.

Pattern matching in a string of characters (a single atom) is like
pattern matching in a string of atoms. Use the \verb|@| to instruct
the program to look inside the atom and use space operators to combine
subpatterns. The space operator does not itself match any
characters. To match a space in an atom, use a space in an atom!

You cannot negate the result of string pattern matching by adding the
\verb|~| prefix.

\begin{ex}
{?} a b:(~@(? b:a %)) _com[succeeds, _bc[~@] means: ``not an atom'']
_oct{!} a b
_oct    S
\end{ex}
\begin{ex}
{?} ~@(a b:a ?)       _com[succeeds, _bc[~@] means: ``not a string match'']
_oct{!} a b
_oct    S
\end{ex}
\begin{ex}
{?} @(a b:a ?)        _coma[illegal, LHS of string match operator]
                      _comc[must be atomic]
_com[Bracmat exits]
\end{ex}
\begin{ex}
{?} ~@(a:b)           _com[fails, pattern matching]
_oct    F
\end{ex}
\begin{ex}
{?} 12/34:@(?x:#?a (~#%@:?y) #?b) _com[succeeds,]
        _coma[_bc[?x] matches the atom _bc[12/34], while _bc[#?a (~#%@:?y) #?b]]
        _comc[matches _bc[12/34] as a string]
_oct{!} 12/34
_oct    S
{?} !a
_oct{!} 12
_oct    S
{?} !b
_oct{!} 34
_oct    S
\end{ex}
\begin{ex}
{?} 12:~/@(?x:#%?a #%?b) _coma[succeeds, _bc~ negates _bc/, not _bc@,]
                         _comc[so we have a string match]
_oct{!} 12
_oct    S
{?} !x
_oct{!} 12
_oct    S
{?} !a
_oct{!} 1
_oct    S
{?} !b
_oct{!} 2
_oct    S
\end{ex}

\subsection{Matching a number in a string}

In a string match, the \verb|%| can be used to force characterwise
matching if the subject is a number and the pattern otherwise would
have been treated as a number. You have to take care with minuses: the
patterns \verb|%"-20/5"| and \verb|%-20/5| are different.
In \verb|%"-20/5"|, the \verb|%| is superfluous and the pattern
matches characterwise.  In \verb|%-20/5|, the pattern matches
\verb|20/5| and the minus is ignored!

\begin{ex}
{?} @(abcd40/10efgh:?a  20/5  ?z)   _com[succeeds, because 4 = 20/5 = 4]
_oct{!} abcd40/10efgh
_oct    S   0,00 sec
{?} !a !z
_oct{!} abcd 0/10efgh
_oct    S   0,00 sec
\end{ex}
\begin{ex}
{?} @(abcd52/13efgh:?a  20/5  ?z)   _com[succeeds, because 52/13 = 20/5 = 4]
_oct{!} abcd52/13efgh
_oct    S   0,00 sec
{?} !a !z
_oct{!} abcd efgh
_oct    S   0,00 sec
\end{ex}
\begin{ex}
{?} @(abcd40/10efgh:?a  %20/5  ?z)   _com[fails]
_oct    F
\end{ex}
\begin{ex}
{?} @(abcd-20/5efgh:?a %"-20/5" ?z)  _com[succeeds]
_oct{!} abcd-20/5efgh
_oct    S   0,00 sec
{?} !a !z
_oct{!} abcd efgh
_oct    S   0,00 sec
\end{ex}
\begin{ex}
{?} @(abcd-20/5efgh:?a  %-20/5  ?z)  _com[succeeds, _bc[a] = _bc[abcd-]]
_oct{!} abcd-20/5efgh
_oct    S   0,00 sec
{?} !a !z
_oct{!} abcd- efgh
_oct    S   0,00 sec
\end{ex}
\begin{ex}
{?} @(abcd-20/5efgh:?a  -20/5  ?z)   _com[succeeds, _bc[a] = _bc[abcd]]
_oct{!} abcd-20/5efgh
_oct    S   0,00 sec
{?} !a !z
_oct{!} abcd efgh
_oct    S   0,00 sec
\end{ex}

\subsection{Binary operators in pattern matching}

\bfun{\bi{subject} \bc{:} \bi{pattern}}

Match \emph{subject} with \emph{pattern}.

A match succeeds if \emph{subject} succeeds and \emph{pattern} is
successfully matched with \emph{subject}. The returned value is the
left operand, \emph{subject}.

Patterns may be built up from subpatterns and may also include
actions that are triggered if a subpattern successfully matches (part
of) the subject.

As with the evaluation of other binary operators, the left operand of
the \verb|:| operator is evaluated first. The other operand,
\emph{pattern}, is not evaluated, but in the process of pattern
matching (parts of) \emph{pattern} may be evaluated several
times. This is the case with function calls, atoms with a \verb|!|
prefix and all right hand sides of the \verb|&| operator. The use of
the involved binary operators
(\verb|$|, \verb|'| and \verb|&|) and prefixes (\verb|!| and
\verb|!!|) as ``meta operators'' does not restrict the range of
matchable expressions in a serious way, as these operators and
prefixes normally do not occur in evaluated subject expressions. The
same is true for some other operators (\verb|:|, \verb,|,, \verb|_|,
and \verb|=|). These operators, too, have a special meaning within
patterns. All other binary operators occurring in a pattern are
searched for in the subject expression as part of the pattern
matching.

Especially the \verb|&|, \verb,|, and \verb|:| operators are helpful
in formulating complex patterns with alternatives, conjunctions and
side effects in the form of actions. In the following examples,
\verb|!s| stands for the subject expression, the expressions in
parentheses are patterns and \verb|!p|, \verb|!pa|, \verb|!pb|,
etc. are subpatterns therein. \verb|!a|, \verb|!aa|, etc., stand for
an action (a part of the pattern that is conditionally evaluated).

\begin{v}
!s:(!p&!a)
\end{v}
If \verb|!p| matches successfully with \verb|!s|, then \verb|!a| is
evaluated. If \verb|!a| fails, the whole match fails. In more complex
patterns, only part of the match might fail, resulting in backtracking
and retry.

\begin{v}
!s:(!pa|!pb)
\end{v}
If pattern \verb|!pa| does not match with subject \verb|!s|, then
\verb|!pb| is tried.

\begin{v}
!s:(!pa:!pb)
\end{v}
If pattern \verb|!pa| matches with \verb|!s|, then pattern \verb|!pb|
is also tried.

The next example combines these operators in a grammar-like
expression:
\begin{v}
!s:( !pa         & !A  _com[if either _bc[!pa], or _bc[!pb] or both of _bc[!pc1] and _bc[!pc2]]
   | !pb         & !B  _com[fire, actions _bc[!A], _bc[!B] and _bc[!C], respectively,]
   | (!pc1:!pc2) & !C  _com[are triggered]
   )
\end{v}
Notice the grouping of the \verb|:|, \verb|&| and \verb,|,
operators:

\verb|(!s:!pa):!pb| and \verb|!s:(!pa:!pb)| have, incidentally, the
same effect, but the following expressions are very different:

\verb|(!s:!p)&!e| or \verb|!s:!p&!e| : If \verb|!s| matches with
\verb|!p|, \verb|!e| is returned.

\verb|!s:(!p&!a)| : If \verb|!s| matches with \verb|!p|, \verb|!a| is
evaluated, but the expression as a whole returns \verb|!s|.

\verb,(!s:!p)|!e, or \verb,!s:!p|!e, : If \verb|!s| matches with
\verb|!p|, \verb|!s| is returned. Otherwise, \verb|!e| is returned.

\verb,!s:(!pa|!pb), : If \verb|!s| matches with either \verb|!pa| or
\verb|!pb| (in that order), \verb|!s| is returned.

The possibility that \verb|!s| might fail further complicates the
above examples.

\subsection{Escaping operator in patterns}

Some operators can not be part of a pattern unless ``escaped,''
because these operators play an active role in pattern matching
instead of being passive part of a pattern. These operators are
\verb.= | & : ' $ _.

The normal role of these operators is ignored by the pattern matching
evaluator if they are escaped with a \verb|$| node with an empty LHS.

\begin{ex}
{?} (=foo'bar):(=$(foo'bar))
_oct{!} =foo'bar
{?} (=foo'bar):(=$(?f'?x)) & !f !x
_oct{!} foo bar
\end{ex}

The escape operator only affects the top node of the escape operator's
RHS. The LHS and RHS of the affected node are matched against the
subject in the normal way.

{\fontsize{11}{12}\selectfont
\begin{ex}
{?} vowel=.!sjt:(a|e|i|o|u|y)      _coma[function to be used in a pattern to check]
                                   _comc[that the subject is a single vowel]
{?} (=a_dollar123):(=_dollar((vowel')_dollar(#:?n))) _coma[only the _bc_d between _bc) and _bc( is escaped,]
                                   _comb[because that is the top node of]
                                   _comc[_bc[(vowel')$(#:?n)]]
                                   _coma[so the pattern expressions _bc[vowel'] and _bc[#:?n]]
                                   _comc[are evaluated as normal]
_oct{!} =a$123
{?} !n
_oct{!} 123                            _coma[this proves that the RHS of the top _bc$]
_oct                                   _comc[was evaluated]
{?} (=b$456):(=$((vowel')$(#:?m))) _coma[this fails, proving that the pattern]
                                   _comb[expression _bc[vowel'] doesn't recognise]
                                   _comb[the _bc[b] in the subject as a vowel;]
                                   _comb[no assignment to variable _bc[?m] takes]
                                   _comc[place]
{?} (=(vowel')$456) : (=$(($(vowel'))$(#:?m)))    _coma[this succeeds, because]
                                   _comb[the _bc' in the pattern expression _bc[$(vowel')]]
                                   _comb[is escaped; so the pattern _bc[$(vowel')]]
                                   _comc[matches the subject _bc[vowel']]
_oct{!} =(vowel')$456
{?} !m
_oct{!} 456
\end{ex}
}

The escape operator functions with all Bracmat operators, but the
operators \verb|.|, whitespace, \verb|+|, \verb|*|, \verb|^|,
\verb|\L| and \verb|\D| should not be escaped normally.

\section{The grammar of Bracmat}

Note: in long lists the vertical bar \verb,|, is left out.
{\fontsize{10}{11}\selectfont
\begin{v}[commandchars=\{\{\}]
<input>           ::= [<expression>] [; <input>]
<expression>      ::=   <whitespace> <expression> <whitespace>
                      | [<prefixes>] ( <expression> )
                      | <leaf>
                      | <expression> <binop> <expression>
<leaf>            ::= [<prefixes>] <atom-or-nil>
<atom-or-nil>     ::= <atom> | <nil>
<atom>            ::= "<string>" | <string>
<string>          ::= <character> [<string>]
<character>       ::= any printable character except \ and " | <spec>
<spec>            ::= \a \b \t \n \v \f \r \" \\
<nil>             ::= ""   (or nothing at all, such as in "()")
<binop>           ::= = . , | & : <whitespace> + * ^ \L \D ' $ _
<prefixes>        ::= <prefix> [<prefixes>]
<prefix>          ::= [ ~ / # < > % @ ` ? ! !!
<whitespace>      ::= spaces, tabs, new line and form feed characters
\end{v}
% $
}

Whitespace (operator/cosmetic measure) almost never leads to
confusion. It does in (some) cases where a \emph{nil} leaf without prefixes
is adjacent to the whitespace operator. For example:
\verb|get' out$now|. Bracmat interprets this as \verb|get'(out$now)|.
\verb|""| or \verb|()| fixes the problem: \verb|get'() out$now|. Quotation
marks are not part of the string they surround. They should be used if
necessary, e.g. \verb|in this case| or \verb|he{this is not a comment}re|.
Comments
can be written everywhere, except in the middle of a string in
quotation marks. Comments are enclosed in \verb|{}| and may be nested.

\section{Binary operators}

\subsection{Overview}

\newcommand{\caret}{\char`\^}

\bfun{\bc{= . , | \& :} whitespace \bc{+ * \caret{} \char`\\L \char`\\D ' \$ \char`\_}}

These are the 15 binary Bracmat operators. The higher in the list, the
lower in the order of operations. Use parentheses to overrule the
ordering of precedence and force an operator to a higher position in
the order of operations, as in:
\begin{ex}
{?} (a+b)*(a+c)+a^(-1*d^2+(d+1)*(d+-1))
_oct{!} a^-1+a^2+a*b+a*c+b*c
\end{ex}

\begin{description}
\item \texttt{=}

  assignment: \verb|(x=7) (square=.!arg^2)|

  object member definition:\\
  \verb|  (myobject=(place=Copenhagen) (setPlace=.!arg:?(its.place)))|

\item \texttt{.}

  fixed data structure: \verb|(Palme.Olof.Sweden)|

  object member referencing:\\
  \verb|  (myhash..insert)$(xxx.998743)|

\item \texttt{,}

  list with autostretch:\\
  \verb|  (ham,(bread,butter),jam):(ham,bread,butter,jam)|

\item \texttt{|}

  or else: \verb,get$myfile | out$"Cannot read myfile",

\item \texttt{\&}

  and then: \verb|out$"almost done" & Done|

\item \texttt{:}

  match subject with pattern:\\
  \verb|  Meeting at 4 in room 24:? ?#hour ? ?#room ?|

\item whitespace

  sentence, neutral element:\\
  \verb|  Oh well this can go on and on:?a Oh ?z & !a:|

\item \texttt{+}

  add, neutral term 0: \verb|(a+6+b+a+10)|,
  \verb|(a+b:?x+a+?y & !x:0)|

\item \texttt{*}

  multiply, neutral factor 1: \verb|(46546*647547564)|,
  \verb|(a*b:?x*a*?y & !x:1)|

\item \texttt{\^}

  raise to a power, neutral exponent 1: \verb|(9975^332)|,
  \verb|(45:?n^?exp & !exp:1)|

\item \texttt{\char`\\ L}

  take logarithm: \verb|10\L1050|

\item \texttt{\char`\\ D}

  differentiate: \verb|x\D(x^10)|

\item \texttt{'}

  function evaluation (does not evaluate RHS): \verb|str'(b+a):"b+a"|

  macro: \verb|()'(my name is ()$name)|

\item \texttt{\$}

  function evaluation (evaluates RHS): \verb|str$(b+a):"a+b"|

  variable in macro: \verb|()'(my name is ()$name)|

\item \texttt{\char`\_}

  dummy: \verb|!expr:?lhs_?rhs & (do$!lhs)_(do$!rhs)|
\end{description}

\subsubsection{The \texttt{=} operator}

This operator ensures that the right hand operator stays
unevaluated. It is mainly used in the definition of pieces of code
(e.g. functions). The code on the right is bound to the name on the
left.

\emph{atom} \verb|=| \emph{expression}

Each time when the value of \emph{atom} is asked for, a fresh copy of
\emph{expression} is made available. \emph{expression} itself is
unchangeable and can only be wiped out by removing the binding between
\emph{expression} and its name, \emph{atom}. This has, in turn, no
influence on the copies made earlier.

\begin{ex}
{?} a=2    _com[create binding]
_oct{!} a
_oct    S
{?} !a:?b  _com[bind copy to _bc[b]]
_oct{!} 2
_oct    S
{?} !b     _com[show _bc[b]'s value]
_oct{!} 2
_oct    S
{?} a=3    _com[remove _bc[a]'s binding to 2]
_oct{!} a
_oct    S
{?} !b     _com[show _bc[b]'s value]
_oct{!} 2
_oct    S
\end{ex}

There is a second way of using the \verb|=| operator, with a slightly
different syntax:

\emph{nil} \verb|=| \emph{expression}

The \verb|=| operator serves as a shock proof container for
\emph{expression}. The effect of evaluating this type of expression is
almost the same as that of the macro instruction
\verb|()'|\emph{expression}. Indeed, after evaluating a macro
instruction we have an expression with the \emph{nil} \verb|=|
\emph{expression} syntax.
\begin{ex}
{?} out_d(b+a)
_oct[]a+b
{?} out_d(=b+a)
_oct[]=b+a
{?} out_d('(b+a))
_oct=b+a
{?} c=3
{?} out_d(=b+a+_dollar[]c)
_oct=b+a+$c
{?} out_d('(b+a+_dollar[]c))
_oct=b+a+3
\end{ex}

\subsubsection{Differentiation}

\emph{variable} \verb|\D| \emph{expression}

Bracmat knows how to differentiate expressions in which no other
binary operators occur but \verb|+ * ^| and \verb|\L|.

Example:
\begin{ex}
{?} y\Dx\D(a^(x^2+y^2))
_oct{!} 4*a^(x^2+y^2)*x*y*e\La^2
{?} y\Dr
_oct{!} 0
\end{ex}

The last example gives zero, which in many applications isn't what we
want. Often, with \verb|y| we express the $y$-component of a vector
with length $r$, and $r$ consequently is a function of $y$ (and the
other components). We can solve this as follows:
\begin{ex}
{?} dep=(r.x) (r.y) (r.z) _com[_bc[dep] is a special variable]
{?} y\Dr
_oct{!} y\Dr
\end{ex}

Now the expression is just left unevaluated. Later, you can substitute
an expression for \verb|r| in terms of its components
\begin{ex}
{?} y\D(r^-1):?derivative
_oct{!} -1*r^-2*y\Dr
{?} sub_d(!derivative.r.(x^2+y^2+z^2)^1/2):?derivative
_oct{!} -1*y*(x^2+y^2+z^2)^-3/2
\end{ex}

And, if you like, you can simplify the result by putting \verb|r| back
in:
\begin{ex}
{?} sub_d(!derivative.x^2+y^2+z^2.r^2):?derivative
_oct{!} -1*r^-3*y
\end{ex}

\subsection{Assignment to variables}

There are two forms of assignment to a variable:

\begin{description}
\item \emph{variable} \verb|=| \emph{expression}

  \emph{expression} is not evaluated before assignment to
  \emph{variable}.

\item \emph{expression} \verb|:| \verb|?|\emph{variable}

  \emph{expression} is evaluated before assignment takes place.
\end{description}

The \verb|=| operator is used to bind (still) unevaluated expressions such as
patterns and functions to variables.

Assignment with the \verb|:| makes use of pattern matching with a
universally unifying pattern. This way of assignment is very powerful
and can even be used to assign unevaluated expressions, by preceding
the subject with an \verb|=| or an \verb|'| operator.

Example: define Lisp's car-function, first using \verb|=| and then
using \verb|:| to bind the function definition to the variable
\verb|car|.
\begin{ex}
{?} car=.!arg:(?%arg ?)&!arg          _com[one may freely reuse _bc[arg]!]
{?} (=(.!arg:(?%arg ?)&!arg)):(=?car) _com[another way to define _bc[car]]
{?} car_d(one two three)
_oct{!} one
{?} (four five six):(?`%first ?rem)   _com[_bc`: 0 of 1, _bc%: 1 or more, together 1]
{?} The first element is !first and the remainder is !rem
_oct{!} The first element is four and the remainder is five six
\end{ex}

\subsection{Binary operators in program flow}

\bfun{\emph{exprA} \bc{\&} \emph{exprB}}

(\emph{exprA} and then \emph{exprB}) \emph{exprB} is only evaluated if
\emph{exprA} succeeds,

\bfun{\emph{exprA} \bc{\char`\|} \emph{exprB}}

(\emph{exprA} or else \emph{exprB}) \emph{exprB} is only evaluated if
\emph{exprA} does not succeed.

In both cases \emph{exprA} is always evaluated and \emph{exprB}
conditionally. If \emph{exprB} is to be evaluated, \emph{exprA} and
the \verb|&| or \verb,|, operator have served their
purpose. Therefore, they are eliminated before \emph{exprB} is
evaluated. In this way, the program stack doesn't grow indefinitely
when recursive calls are made from the right hand side of any \verb|&|
or \verb,|, operator occurring in an expression. Even a conventional
sequence of instructions (where the success or failure of the
evaluations of each instruction do not matter) can make use of this
tail recursion optimisation. In that case one uses the pacifier (short
cut prefix) \verb|`|.
\begin{v}
(`!a & !b)     !b is always evaluated. (sequence)
(`!a | !b)     !b is not evaluated. (useless in this form)
\end{v}

The pacifier or shortcut prefix is inherited by higher levels, it
percolates towards operators that are closer to the root of the tree,
until it is subsumed in situations like the above ones.

\subsection{Algebraic operations}

\begin{description}
\item \emph{term} \verb|+| \emph{term}

  addition

\item \emph{factor} \verb|*| \emph{factor}

  multiplication

\item \emph{base} \verb|^| \emph{exponent}

  exponentiation

\item \emph{base} \verb|\L| \emph{expr}

  logarithm

\item \emph{variable} \verb|\D| \emph{expr}

  differentiation
\end{description}


Subtraction and division are treated as special forms of addition and
multiplication. Therefore there are no binary operators for
subtraction and division. (The minus sign \verb|-| and the slash
\verb|/| can be used in numbers, however.)

If one operand of an algebraic operator is evaluated then the other
one is normally evaluated as well, even if this may seem unnecessary
(multiplication by 0). This is done to ensure that all side effects
take place as intended. However, if an operand fails to evaluate then
the algebraic expression fails too and if the failing operand is the
left hand side of the expression, then the right hand side is not
evaluated. In this sense algebraic operators behave like the logical
\verb|&| operator.

Bracmat gives the user practically \emph{no} control over the format
of evaluated algebraic expressions, such as the order of terms or
factors. Bracmat tries to present algebraic objects in a unique
(canonical) form. This is in many cases an unattainable goal: the
forms
\begin{v}
(a+b)*(c+d)
\end{v}
and
\begin{v}
a*c+a*d+b*c+b*d
\end{v}
are both stable expressions. On the other hand,
\begin{v}
(a+b)*(c+d)+e
\end{v}
becomes
\begin{v}
e+a*c+a*d+b*c+b*d
\end{v}

Bracmat keeps completely factorised expressions as they are, because
factorization is an expensive operation. For the same reason, Bracmat
does not automatically factorise factorisable expressions. Another
domain of duality are expressions with logarithms.

Sums and products start with rational numbers, followed by \verb|pi|,
\verb|i| and \verb|e| (if present, that is). Then follow other terms and
factors. It is recommended not to assume anything about the ordering
of these terms and factors, as this may change in later versions of
the program.

\subsection{Function evaluation}

The binary operators
\verb|$| and \verb|'| are similar in most respects. In general, the
left operand evaluates to the name of a built-in or defined function,
whereas the right operand is an expression that is passed as an
argument to the function. The \verb|$| evaluates the right operand
before it is passed over, the \verb|'| doesn't. Parameter passing is
by value, although the implementation postpones and limits copying of
data as much as possible. In the code of the called function, the
passed argument is bound to a local variable that is always called
\verb|arg|.

Most often, the left operand of the \verb|$| and the \verb|'| operator
evaluates to an alphanumeric name. There are a few special function
names:
\begin{itemize}
\item No name at all. Here, the \verb|$| and the \verb|'| operator
  have decidedly different and complementary roles. (Forced evaluation
  of subexpressions in otherwise unevaluated expressions, such as
  patterns.)
\item An integral number. (Array indexing.)
\item Only prefixes. (Prefix pasting or influencing success and
  failure of non-atomic expressions.)
\end{itemize}

Function calls are even effective in patterns, as it is fair to assume
that the \verb|$| and \verb|'| operators seldom occur in subjects and so need
not to be matched (the same is, a fortiori, true for the \verb|&| and
\verb,|, operators). In patterns, the return value of a function is
part of the pattern. A function may be called several times during one
evaluation of a matching expression, due to backtracking and retrying.

\subsection{Macro evaluation}

The \verb|'| operator with empty LHS is the macro evaluator. The macro evaluator
returns the RHS unchanged, except where \verb|$| operators with empty LHS occur.

The expression to the RHS of such a \verb|$| operator must evaluate to the name of a
variable or to a definition. The whole \verb|$| expression is then replaced by the
value of the variable or the definition. (The following example illustrates
three ways how you can make sure that the LHS of the \verb|$| operator is empty.)
\begin{ex}
{?} x=un
{?} y=(member=deux)
{?} '(one ($x), two ""$(y.member), three ()$(=trois))
_oct{!} =one un,two deux,three trois
\end{ex}
% $

Here is an example that shows that the RHS of the \verb|$| operator can be an
expression that first needs to be evaluated:
\begin{ex}
{?} a=eins
{?} b=zwei
{?} dice=clk$
{?} '(Eins oder zwei? ()$(!dice:<1&a|b))
_oct{!} =Eins oder zwei? eins
    {...}
{?} '(Eins oder zwei? ()$(!dice:<1&a|b))
_oct{!} =Eins oder zwei? zwei
\end{ex}
% $

You can construct any Bracmat expression using macro evaluation. For example,
the function \verb|F|, below, transforms an expression with \verb|+| and \verb|*| operators to a
pattern, replacing any non-empty atom that is not a number to a pattern
variable that either is receiving or giving, depending on whether the atom
occurs for the first time or not, when reading the expression from the
beginning to the end.
\begin{ex}
{?} (F=
      seen f
    .   :?seen
      & ( f
        =   a b
          .   !arg:%?a+%?b&'($(f$!a)+$(f$!b))
            | !arg:%?a*%?b&'($(f$!a)*$(f$!b))
            |     !arg
                : (
                  | #
                  | e
                  | i
                  | pi
                  )
              & '$arg
            | !seen:? !arg ?&glf$('(!.$arg))
            | !arg !seen:?seen&glf$('(%?.$arg))
        )
      & f$!arg
    );
{?} F$(a*b+3*a*c)
_oct{!} =%?a*%?b+3*!a*%?c
\end{ex}
% $

Now we can use the pattern to match expressions with the same structure and
with the same operators
\begin{ex}
{?} x*y+3*x*z:!(F$(a*b+3*a*c))
\end{ex}
% $

The function F can only handle expressions containing \verb|+| and \verb|*| operators.
Now we will in a few steps amend F so that it can handle any operator. This is
done by using the dummy \verb|_| operator.

As a first step, we will have to protect the argument of F against evaluation,
because otherwise we will never be able to analyse expressions that evolve to
different expressions when evaluated. So, from now on we will use F with the
\verb|'| operator, like so.
\begin{ex}
{?} F'(a*b+3*a*c)
\end{ex}
% $

To simplify the first amendment, we will only handle expressions with the \verb|+|
operator. Later we will generalize to handling any operator.
\begin{ex}
{?} (F=
      seen f
    .   :?seen
      & ( f
        =   a b g
          .     !arg:(=%?a+%?b)
              & '($(f$('$a))+$(f$('$b)))
            |   !arg:(=?g)
              & (     !g
                    : (
                      | #
                      | e
                      | i
                      | pi
                      )
                  & !arg
                | !seen:? !g ?&glf$('(!.$g))
                | !g !seen:?seen&glf$('(%?.$g))
                )
        )
      & f$('$arg)
    );
{?} F'(a+b+pi+a)
_oct{!} =%?a+%?b+pi+!a
\end{ex}
% $

Now we replace the \verb|+| operator by the dummy operator \verb|_|. If we only do that,
then we will only see \verb|_| operators in the result. That is because in a macro
context, a \verb|_| operator is not evaluated to its current value. However, if the
RHS expression of a \verb|$| operator with empty LHS is headed by the \verb|_| operator,
then the \verb|_| operator is evaluated to its current value, analogous to what
happens if the RHS were the name of a variable. So we add an extra \verb|$| operator.

When the \verb|_| operator is evaluated to its current  value, the LHS and the RHS are
also evaluated.
\begin{ex}[commandchars=&\[\]]
{?} a^b:?_?
{?} LHS:?left
{?} '$(($left)_($(=RHS)))
\end{ex}
% $

Without evaluation of \verb|_| operator:
\begin{ex}[commandchars=&\[\]]
{?} '($left)_($(=RHS))
&oct{!} =LHS_RHS
\end{ex}
% $

With evaluation of \verb|_| operator:
\begin{ex}[commandchars=&\[\]]
{?} '$($left)_($(=RHS))
&oct{!} =LHS^RHS
\end{ex}
% $

Now we use this in the function \verb|F|:
\begin{ex}[commandchars=&\[\]]
{?} (F=
      seen f
    .   :?seen
      && ( f
        =   a b g
          .     !arg:(=%?a_%?b)
              && '$($(f$('$a)))_($(f$('$b)))
            |   !arg:(=?g)
              && (     !g
                    : (
                      | #
                      | e
                      | i
                      | pi
                      )
                  && !arg
                | !seen:? !g ?&&glf$('(!.$g))
                | !g !seen:?seen&&glf$('(%?.$g))
                )
        )
      && f$('$arg)
    );
{?} F'(a+b_k&&out$y&&$$(=.arg))
\end{ex}
% $

Finally, we ensure that atoms that already have a prefix are treated in the
same way as empty strings and numbers.
\begin{ex}[commandchars=&\[\]]
{?} (F=
      seen f
    .   :?seen
      && ( f
        =   a b g
          .     !arg:(=%?a_%?b)
              && '$($(f$('$a)))_($(f$('$b)))
            |   !arg:(=?g)
              && (   (   !g
                      : (
                        | #
                        | e
                        | i
                        | pi
                        )
                    | ~(glf$('(~`/#<>%@?!.$g)))
                    )
                  && !arg
                | !seen:? !g ?&&glf$('(!.$g))
                | !g !seen:?seen&&glf$('(%?.$g))
                )
        )
      && f$('$arg)
    );
{?} F'('(the hare&&$the tortoise))
&oct{!} ='(%?the %?hare&&$!the %?tortoise)
\end{ex}
% $

In the above example the argument of the \verb|F| function is returned in an
unevaluated state, though transformed to something else. The last input was a
macro expression, and the result is still a macro expression.

Now suppose that we want to produce the macro expression
\begin{v}
'(There are 23 elements in list ()$L)
\end{v}
by means of another macro expression that evaluated the number of elements to
23. Something like this:
\begin{ex}
{?} 23:?N
{?} '('(There are ()$N elements in list ()$L))
\end{ex}
% $

This generates the error "macro evaluation fails because rhs of \verb|$| operator is not bound to a value: \verb|$L|".
What is needed is to `escape' the \verb|$| operator in the subexpression \verb|()$L|, since we do not want \verb|()$L| to be
evaluated. This is done with and extra \verb|$| operator, similar to how a backslash is escaped in many
programming languages:
\begin{ex}
{?} 23:?N
{?} '('(There are ()$N elements in list ()$($L)))
_oct{!} ='(There are 23 elements in list ()$L)
\end{ex}
% $

More examples:
\begin{ex}
{?} '(b+a c)
_oct{!} =b+a c
{?} (x=value) & '(a ($x) z)
_oct{!} =a value z
{?} (object=(member=value)) & '(a ($(object.member)) z)
_oct{!} =a value z
{?} '(a ($(=value)) z)
_oct{!} =a value z
\end{ex}
% $

\subsection{Program transformation}

Bracmat code is data. Yet it is easier to transform the internal
representation of JSON or XML data than to transform a Bracmat
program. The reason is that for code introspection it is necessary to
turn off the expression evaluation that normally takes place in
patterns. This can be achieved by using macros. Here is an example
that reverses (\verb|rev$|) and lowercases (\verb|low$|) all leaves,
but keeps everything else the same: prefixes, operators---even those
that play special roles inside patterns, such as the \verb|!| prefix
and the \verb|_| operator.
\begin{ex}[commandchars=&\[\]]
{?} ( tr
    =   a b f
      .   flg$!arg:(=?f.?arg)
        &&   glf
          $ (
            ' ( $f
              .
                $ (   '$arg:(=?a_?b)
                    && '$($(tr$('$a)))_($(tr$('$b)))
                  | low$rev$!arg:?arg&&arg
                  )
              )
            )
    )
{?} tr$(=foo"STRing" ~!(sin$4/56) !and_?<UNDERSCORE)
&oct{!} (=oofgnirts ~!(nis$65/4) !dna_<?erocsrednu)
\end{ex}
% $

\subsection{The dummy operator \texttt{\char`\_}}

Bracmat has only one variable that binds to a binary operator, the
\verb|_| operator. Worse even, this variable is global. Nevertheless
this variable is most useful in definitions of certain types of
recursive functions (tree walkers).

The assignment of a new value to the \verb|_| variable can only take
place in a match operation. A \verb|_| in a pattern is always
receiving, whereas a \verb|_| outside a pattern is either giving or
left unchanged. Try this:
\begin{ex}[commandchars=&\[\]]
{?} a_b             &com[this has unpredictable results]
{?} x^y:?_? && a_b   &com[&bc_ gets bound to &bc^, thus &bc[a_b] evaluates to &bc[a^b]]
\end{ex}

A \verb|_| is evaluated by the expression evaluator, but also by the
macro evaluator. The latter is useful if the \verb|_| has matched an
operator that is very volatile, such as \verb|&| and \verb,|,.
\begin{ex}[commandchars=*\[\]]
{?} (=!a:!b&!c):(=?left_?right) *com[match the *bc&]
{?} '$_
*oct{!} =&                          *com[it worked, the *bc_ is replaced by a *bc&]
{?} get*d(str*d('*d_),MEM,VAP):"=" ?op & !op *com[freeze and slice]
*oct{!} &           *com[the operator is immobilised in a string]
\end{ex}
% $

The \verb|_| variable is always expanded BEFORE the left and right
hand side operands are evaluated. That explains why new assignments in
the operands do not result in unwanted side effects in the upper node
with the \verb|_|.

\subsection{Recursion and the \texttt{\char`\_} operator}

In Bracmat functions are allowed to call themselves. Often this
happens if a function's argument is split into a left subtree and
a right subtree and the function is called with each subtree in turn
as its argument. If the operator between the subtrees is unknown,
it is time consuming to try all patterns \verb|?+?|, \verb|?*?|,
\verb|?$?|, \verb|?'?| etc. The \verb|_| operator circumvents this
problem. It is a dummy operator that matches any other operator and
expands to the operator with which it matched last time. Thereby
preceding matches are forgotten: the \verb|_| operator is a global
variable.
\begin{ex}[commandchars=*\[\]]
{?} ( reverse
    =   l,r
      .     (!arg:?l_?r)              *com[if arg is a compound expression *ldots]
          & (reverse*d!r)_(reverse*d!l) *com[*ldots swap the reversed operands]
        | !arg                        *com[let atoms as they are]
    )
{?} reverse*d(Bill loves sweet Nancy. This is true)
*oct{!} true is This.Nancy sweet loves Bill
\end{ex}

\subsection{Some often used control structures}

Here are the nearest equivalents of some traditional control
structures.

\subsubsection*{Sequence}

\verb|a; b;|
\begin{v}
`!a&!b
!a !b
!a,!b
!a.!b
\end{v}

\subsubsection*{Repetition}

\verb|WHILE a DO b;|
\begin{v}
whl'(!a&`!b)
\end{v}
\verb|DO b WHILE a;|
\begin{v}
whl'(`!b&!a)
\end{v}
\verb|FOR i := m TO n DO b;|
\begin{v}
!m+-1:?i&whl'(1+!i:~>!n:?i&`!b);
\end{v}

\subsubsection*{Selection}

\verb|IF a THEN b ELSE c;|
\begin{v}
!a&`!b|!c;
\end{v}
\verb|v := IF a THEN b ELSE c;|
\begin{v}
(!a&`!b|`!c):?v _com[works even if _bc[!c] fails]
\end{v}

\subsubsection*{Branching}
\verb|CALL a;|
\begin{v}
!a;
\end{v}
\verb|CALL b(x,y,z);|
\begin{v}
b$(x,y,z);
\end{v}
\verb|v := b(x,y,z);|
\begin{v}
b$(x,y,z):?v;
\end{v}

\subsection{The nameless functions \texttt{\$}\emph{expression} and
  \texttt{'}\emph{expression}}

Sometimes a variable predictably will evaluate to the same value
repeatedly, for example in an inner loop or a pattern that repeatedly
backtracks. In such situations macro substitution can improve
performance by replacing the variable by its value in an early stage.

In Bracmat, a macro has the general form
\verb|'|\emph{expression}. When \verb|'|\emph{expression} is
evaluated, \emph{expression} is searched for subexpressions headed by
the operator
\verb|$|, with empty LHS. Such subexpressions are replaced, depending
on what is found on the RHS of the \verb|$| operator.

After macro substitution has taken place, what remains is an
expression of the form \verb|=|\emph{expression}. The \verb|=|
operator is a safeguard against evaluation of expression.

Macro substitution makes it possible to dynamically create unevaluated
code and bind it to a variable.
\begin{ex}
{?} '($out):?my-fun-var
{?} !my-fun-var$(Hello world)
{?} '($out):(=?my-fun-alias)
{?} my-fun-alias$(Hello world)
\end{ex}

Pattern matching can sometimes be made more efficient by using macro
substitution, but the resulting code is harder to understand:
\begin{ex}
{?} ( 0:?count
    &   41 3 5 7 6 23 12 11 19
     :   ?
          %?`A
          ?
          ( %?`B                          _com[each number pair [_bc[A,B]] _ldots]
          & !A+!B:?C                      _com[is added only once, giving _bc[C]]
          &   '(? ()$(!count+1:?count&C) ?)
            : (=?rem)                     _com[_bc[C]'s value is hard-coded into _bc[rem]]
          )
          !rem                            _com[which is the remaining pattern]
    & out$(after !count "trials:" !A "+" !B "=" !C )
    )
\end{ex}
after 16 trials: 5 + 7 = 12.

In the same way, function code can be pieced together before it is
ever executed.
\begin{ex}
{?} power=three
{?} ((!power : two & (=!arg^2)) | (=!arg^3)) : (=?abc)  _coma[if _bc[power] = _bc[two],]
    _comc[_bc[abc] is bound to _bc[!arg^2] (unevaluated); otherwise, _bc[abc] is bound to _bc[!arg^3]]
{?} '(.!arg + -1*$abc + 2) : (=?poly) _coma[_bc[poly] is the name of a new function]
    _comb[that will return a value that depends on the current value of _bc[arg]]
    _comc[and on the value of _bc[power] at the time when _bc[abc] got its binding]
{?} lst$poly  _com[show _bc[poly]'s definition]
{?} poly$4
_oct{!} -58
\end{ex}

The macro construct \verb|'|\emph{expr} is useful if an expression has
to be executed many times while parts of it remain constant, for
example in nested loops:

Without macro construct ($5\times 5$ multiplication table):
\begin{ex}
{?} 0:?m                      _com[initialise counter of outer loop]
{?} (outer = 1+!m : <6 : ?m   _com[code for outer loop]
           & put$\n           _com[start output on new line]
           & 0 : ?n           _com[initialise counter of inner loop]
           & `!inner          _com[execute inner loop]
           & !outer)
{?} (inner = 1+!n : <6 : ?n   _com[code for inner loop]
           & put$(!m X !n "=" !m*!n ", ")
                              _com[the same _bc[!m] is expanded 10 times]
           & !inner)          _com[loop]
{?} !outer
\end{ex}

With macro construct:
\begin{ex}
{?} 0:?m
{?} (outer = 1+!m : <6 : ?m
           & '( 1+!n : <6 : ?n
              & put$($m X !n "=" ()$m*!n ",")
                             _com[_bc[!m] is expanded only 2 times]
              & !inner
              ) : (=?inner)  _coma[at each pass through the outer loop]
                             _comc[the inner loop _bc[inner] is defined anew]
           & put$\n
           & 0 : ?n
           & `!inner
           & !outer)
{?} !outer
\end{ex}

\section{Objects}

With the \verb|=| and \verb|.| operators you can construct and
dereference conventional data structures and even objects with
methods. In an expression, each subexpression with a \verb|=| operator
in the top node and an atom in the LHS of the top node indicates a
field or object method that can be accessed and changed independently
of other fields and methods, i.e. without the need to dissect and
reassemble the whole expression. Such expressions are objects. An
object member (a field or method) is addressed by using the LHS of the
\verb|=| operator as the member's name, preceded by the object's
name. The name of the object and the name of the member must be
separated by a dot operator.

In the example below an object named \verb|John| is created with the
members \verb|length|, \verb|age| and \verb|name|. The \verb|name|
member has two submembers \verb|first| and \verb|family|:
\begin{ex}
{?} John = (length=180),(age=30),(name=(first=John) (family=Bull))
\end{ex}

There is no prescribed way in which the members should be glued
together to form an object. Here, the comma operator and blank
operator are used, but any operator except the \verb|=| operator can be
used to separate field names. John's length can be changed to 185 in
the following ways:
\begin{ex}
{?} John.length = 185
\end{ex}
or
\begin{ex}
{?} 185 : ?(John.length)
\end{ex}

The same object can be assigned to another variable, creating an
alias, but we have to take care not to evaluate \verb|John|, because
that would create or overwrite the variables \verb|length|, \verb|age|
and \verb|name|):
\begin{ex}
{?} !John:?alias
    _com[wrong, _bc[alias]=_bc[length,age,name]]
\end{ex}
\begin{ex}
{?} '$John : (=?alias)
   _com[right, _bc[alias]=_bc[(length=185),(age=30),(name=(first=John)(family=Bull))]]
\end{ex}

Bracmat replaces the expression \verb|'$John| by the value of John,
protected against evaluation by a \verb|=| operator. For that reason,
the pattern on the RHS of the match operator \verb|:| contains a
\verb|=| operator as well. Now we can change John's age by operating
on the variable \verb|alias|:
\begin{ex}
{?} alias.age = 31
\end{ex}

To see that the above expression indeed has the wanted (side-)effect,
we can inspect \verb|John|:
\begin{ex}
{?} lst_dollar[]John
_oct(John=
_oct  (length=180)
_oct, (age=30)
_oct, (name=(first=John) (family=Bull))
_oct);
\end{ex}

Alternatively, we can also just show the field \verb|age| in John:
\begin{ex}
{?} !(John.age)
_oct{!} 31
\end{ex}

It is also possible to create an alias for a subobject. Taking the
previous example, we could create an alias for the \verb|name| member:
\begin{ex}
{?} '_dollar(John.name):(=?nm)
\end{ex}
%
Now assign a new family name:
\begin{ex}
{?} Flinter:?(nm.family)
{?} lst_dollar[]John
_oct(John=
_oct  (length=180)
_oct, (age=30)
_oct, (name=(first=John) (family=Flinter)));
\end{ex}

Using an alias for a subobject can save some code and processing time
if the subobject is accessed many times. Without the alias for John's
name, we can change his family name in this way:
\begin{ex}
{?} Flinter:?(John.name.family)
\end{ex}

It is valid to have an empty name for a member:
\begin{ex}
{?} x=(header=blabla) (=(a=1) (b=2))
\end{ex}

Here, \verb|a| and \verb|b| are fields in a nameless subobject of
\verb|x|. We can ask for the value of \verb|b|:
\begin{ex}
{?} !(x..b)
_oct{!} 2
\end{ex}

To retrieve the whole subobject:
\begin{ex}
{?} '_dollar(x.):(=?subobject)
{?} lst_dollar[]subobject
_oct(subobject=
_oct(a=1) (b=2));
\end{ex}

An alias can also be created for part of an object:
\begin{ex}
{?} x=(a=) (b=) (c=) (d=)
{?} '_dollar[]x:(=(a=) ?alias (d=))
\end{ex}

Now \verb|alias| only shares the members \verb|x.b| and \verb|x.c|
with \verb|x|. The same result follows from
\begin{ex}
{?} '_dollar[]x:(=? ((b=) (c=):?alias) ?)
\end{ex}

Objects can be composed to form new objects containing the union of
the members of the contributing objects:
\begin{ex}
{?} x=(a=) (b=)
{?} '((p=) (_dollar[]x) (q=)):(=?r)
\end{ex}

Evaluation of an expression that contains \verb|= |operators can have
unexpected side effects, as the following example shows.

First suppose that \verb|x| (containing one record with one anonymous
field) is unevaluated (case A) and assigned to two other variables:
\begin{ex}
{?} x=(=)
{?} !x:?y
{?} !x:?z
\end{ex}

In this case, \verb|x|, \verb|y| and \verb|z| are different
objects. For example
\begin{ex}
{?} 2:?(y.)
\end{ex}
does not affect \verb|x| and \verb|z|. Do the assignment again, but this
time evaluating \verb|x| only once:
\begin{ex}
{?} !x:?y:?z
\end{ex}
Now \verb|y| and \verb|z| are the same object, but still different
from \verb|x|. A change made to \verb|y| affects \verb|z| but does not
affect \verb|x|.

Suppose that \verb|x| \emph{is} evaluated (case B):
\begin{ex}
{?} (=):?x
{?} !x:?y
{?} !x:?z
\end{ex}
Now \verb|x|, \verb|y| and \verb|z| are the same object.

Explanation: in (A) the value of \verb|x| is not evaluated, especially
the LHS of the \verb|=| operator. Therefore, a new \verb|=| node is
created each time \verb|x| is evaluated. In (B), the value of \verb|x|
\emph{is} evaluated, so no new copies of the \verb|=| node are made.

\section{Construction of data structures}

In Bracmat, linear lists can be made by separating the elements with
comma, plus sign, asterisk, space and dot. The first four operators
create linear structures (right descending lists), moving nodes as
necessary, whereas the dot operator creates any tree structure. In
addition, the plus sign and the asterisk (times) do not preserve the
order of the elements if they are not canonical order. Which operator
one should use in a given situation depends on the following
considerations:
\begin{itemize}
\item Space, comma, plus and asterisk offer automatic concatenation of
  lists, but are slower than the dot.
\item Space, plus and asterisk are useful if there is a need to search
  in a list, because these operators support backtracking, but they are
  slower than the comma.
\item The comma can be used in linear lists that are accessed
  recursively and in record-like structures, where the elements must
  have absolute positions. The dot can be used for the same purpose.
\item If a function has a fixed number of parameters, you should use
  dots to separate them.
\item If there is a need to sort elements alphabetically, use the plus
  operator.
\item Lists constructed with plus or asterisk behave like sets. Adding
  an element that already is present does not make the list any
  longer, but will instead increase a factor (plus) or exponent
  (asterisk).
\end{itemize}

Examples:
\begin{ex}
{?} x=a.b.c
{?} y=p.q
{?} !x.!y
_oct{!} (a.b.c).p.q
{?} x=a b c
{?} y=p q
{?} !x !y
_oct{!} a b c p q
{?} set=jan+piet+klaas
{?} !set
_oct{!} jan+klaas+piet
{?} !set+klaas
_oct{!} jan+2*klaas+piet
{?} rotate=car,cdr.!arg:(?car,?cdr) & (!cdr,!car)
{?} rotate_dollar(one,two,three,four)
_oct{!} two,three,four,one
{?} rotate_dollar((one,two),(three,four))
_oct{!} two,three,four,one
\end{ex}

By combining dots, commas and spaces, one may build any tree-like data
structure that, thanks to the backtracking mechanism on
space-separated lists, make the formulation of queries (goals) almost
as easy as in Prolog. This is an example of a simple database, in
which each row starts with a descriptor field, followed by a varying
number of similar fields.
\begin{ex}
{?} M=( (odd  ,1 3 5 7 9)
        (even ,0 2 4 6 8)
        (prime,2 3 5 7)
      )
\end{ex}
We choose the space operator to form the backbone of the lists of
numbers, because we want to access these numbers associatively, by
using the back-tracking mechanism.

Let us formulate a query that searches for all numbers that occur in
two or more categories (odd, even, prime). The findings are to be
printed to the screen.
\begin{ex}
{?} ( !M
    :   ?                           _com[skip 0 or more rows_ldots]
        (?c1,?row)                  _com[_ldots fetch (number type, number row)_ldots]
        ?                           _com[_ldots skip 0 or more rows_ldots]
        ( ?c2                       _com[_ldots fetch another number type,_ldots]
        ,   ?                       _com[_ldots skip 0 or more numbers_ldots]
            ( %?`el                 _com[_ldots fetch a number_ldots]
            & !row:? !el ?          _com[does number occur in earlier row?]
            & out_dollar(!el is both !c1 and !c2) _com[yes? show result]
            & ~                     _com[not satisfied yet: fail and backtrack]
            )
            ?                       _com[skip rest of numbers]
        )
        ?                           _com[skip rest of rows]
    )
\end{ex}

This prints
\begin{v}
3 is both odd and prime
5 is both odd and prime
7 is both odd and prime
2 is both even and prime
\end{v}
and finally fails when backtracking (induced by the \verb|~|) has
found all answers to the query.

Experimentation with the implementation of matrices in Bracmat has
revealed that lists (of lists (of lists\ldots)) lead to smaller and
faster programs than arrays, artificially made multidimensional by
playing with the index. A drawback of the list approach is its
unconventionality. Much time has to be spend in reformulating existing
algorithms based on indices. On the other hand, the list approach is
essentially insensitive to the dimensionality of the matrix at hand,
and may even be indifferent to the number of indices.

\subsection{Program flow}

Most binary operators are used in expressions that flow on their own
or flow not at all. In the first group are the arithmetic operators,
in the second is the dot operator. In between are the two other
structuring operators, comma and whitespace.

Branching to a function is done with the \verb|$| and \verb|'|
operators:

\verb|a$b| (or \verb|a'b|) evaluates function \verb|a| with argument
\verb|b|.

Branching without argument passing and local variables is done with
the unary operator (prefix) \verb|!| but often this prefix and its
cousin \verb|!!| are used for the purpose of variable expansion, it
just depends on whether a variable is bound to an unevaluated or to an
evaluated expression:
\begin{description}
\item \verb|!X|\par
  do subroutine \verb|X|
\item \verb|!X|\par
  expand \verb|X|
\item \verb|!!Y|\par
  expand expansion of \verb|Y| (two \verb|!|s is the maximum)
\end{description}

Conditional evaluation is decided by the success or failure of
subexpressions. Every (sub)expression has two kinds of value: a
visible value and a success(S)/failure(F)/ignore(I) value. Success and
failure are primarily decided by the low level functions in the
interpreter. The ignore value is generated if a failing expression is
back-quoted. The \verb|&| and \verb,|, operators are sensitive to the
S/F/I value of the left operand (where I counts as S). Often this left
operand is a matching expression.
\begin{description}
\item \verb|!a & !b|\par
  if \verb|!a| succeeds do \verb|!b|
\item \verb,!a | !b,\par
  if \verb|!a| fails do \verb|!b|
\item \verb|!subject : !pattern|\par
  try to prove that \verb|!pattern| describes \verb|!subject|
\end{description}

The back quote \verb|`| can be used to overrule the failure of a
subexpression. The tilde \verb|~| negates failure and success.
\begin{description}
\item \verb|`!p & !q|\par
  do \verb|!p| and then do \verb|!q|
\item \verb,!a:!p & `!b | !c,\par
  if \verb|!a| matches \verb|!p| do \verb|!b| else do \verb|!c|
\item \verb|~!a|\par
  succeeds if \verb|!a| fails and fails if \verb|!a| succeeds
\end{description}

\section{Prefixes}

\subsection{Prefixes and program flow}

Unlike other programming languages, Bracmat does not return the value
of a variable or object member if we type its name. In Bracmat,
variables and object members have to be told explicitly that we want
their value, not their name. This is achieved with the \verb|!| and
the \verb|!!| prefixes in front of the variable name or object member
name.
\begin{description}
\item \verb|!|\emph{atom}\par
  is replaced by the binding of \emph{atom}
\item \verb|!!|\emph{atom}\par
  is replaced by the binding of the binding (after evaluation) of
  \emph{atom}
\end{description}

Likewise \verb|!(|\emph{object-name}\verb|.|\emph{member-name}\verb|)|
is replaced by the binding of
\emph{object-name}\verb|.|\emph{member-name}.

Bindings can be evaluated or unevaluated. In the last case, the next
step after expansion is the evaluation of the binding, unless
expansion took place within a pattern.
\begin{ex}
{?} 2+3:?four     _com[bind _bc[5] to _bc[four]]
{?} !four         _com[evaluation has already taken place when _bc[four] is expanded]
_oct{!} 5
{?} 5=2+!four     _com[numbers are legal names; _bc[5] is bound to _bc2 + _bc[!four]]
{?} !5            _com[evaluation takes place immediately after expansion]
_oct{!} 7
{?} sum=%+%       _com[define pattern _bc[sum]]
{?} a+b+c:!sum    _com[is _bc[a+b+c] a sum? after expansion, _bc[%+%] is not evaluated]
_oct{!} a+b+c
_oct    S   0,00 sec
\end{ex}

The \verb|!!| prefix is not used as often as the single \verb|!|, but
comes in handy if you want to pass a variable by name instead of by
value.
\begin{ex}
{?} (check=one,two,criterion
      .     !arg:(?one,?criterion,?two)
          & !!criterion
          & TRUE
        | FALSE
    )
{?} is-greater-than = !one:>!two
{?} is-divisor-of = (div_dollar(!two,!one)*!one):!two
{?} check_dollar(3,is-greater-than,15)  _com[pass by name]
_oct{!} FALSE
_oct    S   0,00 sec
{?} check_dollar(3,is-divisor-of,15)
_oct{!} TRUE
_oct    S   0,00 sec
\end{ex}

Passing by name is used here to postpone the evaluation of the second
argument until it has arrived in the function \verb|check| and the
local variables \verb|one| and \verb|two| have been bound to the first
and the third arguments, respectively.

Postponement of evaluation can also be achieved with the \verb|=| and
the \verb|'| operators.
\begin{ex}
{?} (chack=one,two,criterion
      .    !arg:(?one,(=?criterion),?two)
         & !criterion
         & TRUE
       | FALSE
    )
{?} is-greater-than = =!one:>!two                  _com[an extra _bc=]
{?} is-divisor-of = '((div_dollar(!two,!one)*!one):!two) _com[an extra _bc']
{?} chack_dollar(3,!is-greater-than,15)                  _com[pass by value]
{?} chack_dollar(3,!is-divisor-of,15)
\end{ex}

\subsection{Prefixes and pattern matching}

In patterns, atoms and expressions within parentheses may be preceded
by prefixes that control the matching process.

Below, use the term ``trivial elements'' for elements that are either
neutral or zero. A list expression (an expression that links elements
with the space operator) has the empty string as neutral element. In
sums, \verb|0| (zero) is the neutral element. In products, \verb|1| is
the neutral element. So the empty string, \verb|0| and \verb|1| are
trivial elements in lists, sums and products, respectively. In
addition, \verb|0| is also a trivial element in products. Lists and
sums do not have ``zeros.''

\begin{description}
\item \verb|!| and \verb|!!|\par
  in front of an non-nil atom or an expression denoting a member of an
  object causes expansion of the atom or the member to its direct or
  indirect binding. This binding is matched with the subject.

\item \verb|`|\par
  causes backtracking if the pattern did not successfully unify with a
  non-trivial element of the subject-list. A list is an expression
  consisting of terms (\verb|+| operator), factors (\verb|*| operator)
  or words (whitespace operator). In non-sophisticated patterns,
  \verb|`| means simply: unify with at most one non-trivial
  element. Zero non-trivial elements are allowed, in which case
  unification takes place with an implicit trivial element: Bracmat
  sees 0's everywhere in a sum, 1's in a product and zero length words
  in a sentence.

\item \verb|?|\par
  unifies with anything. If \verb|?| is followed by a non-nil atom
  denoting a variable or an expression denoting a member of an object,
  then the matched part of the subject is captured by this variable or
  member. In other words, pattern matching can have assignment as a
  side-effect.

\item \verb|@|\par
  unifies only with atoms. Also, if prefixed to the \verb|:| operator,
  it indicates that the pattern applies to the characters inside the
  atom (string match).

\item \verb|%|\par
  causes the match to succeed only with one or more non-trivial
  elements of the subject-list. (Exception: in combination with
  \verb|[| prefix.)

\item \verb|<|\par
  unifies only with atoms that are less than the atom following the
  \verb|<| prefix.

\item \verb|>|\par
  unifies only with atoms that are greater than the atom following the
  \verb|>| prefix.

\item \verb|#|\par
  unifies only with rational numbers.

\item \verb|/|\par
  unifies only with non-integer rational numbers.

\item \verb|~|\par
  constrains the match to subjects that are not equal to the atom
  following the \verb|~| prefix.

\item \verb|[|\par
  Position prefix. Must be followed by an expression that evaluates to
  a number (for example \verb|[4| or \verb|[(!pos+3)|) or by a
  variable having a question mark as in \verb|[?pos|. In the first
  case, the pattern cannot succeed unless the element following the
  \verb|[| element is at the indicated position. The \verb|[| element
  itself does not occupy a position; it sits in front of the indicated
  position. The second form is for querying the current
  position. Position 0 is the start of the subject. Positive positions
  count from the beginning of the subject, negative positions from the
  end. Position -1 is the position following the last element. (When
  combined with \verb|%| the meaning is different.)
\end{description}

The above prefixes may be combined. The ordering in which they are
input by the user is irrelevant; Bracmat keeps prefixes in this order:
\begin{v}[commandchars=*\{\}]
[ ~ / # < > % @ ` ? ! !!
\end{v}

Repeating prefixes in front of the same atom does not convey a new
meaning to the pattern, except for the \verb|!| and the \verb|~|
prefixes. More than one \verb|!| is interpreted as the \verb|!!|
prefix. An odd number of \verb|~| is treated as a single \verb|~|, an
even number thereof is treated as none. A \verb|~| in front of other
prefixes negates the first of them. The most useful combinations are:
\begin{description}
\item \verb|?!|\par
  in front of an atom causes the atom to be expanded to its
  binding. This binding is treated as a variable name.

\item \verb|?!!|\par
  is like \verb|?!|, but expands two levels deep (with an evaluation
  of the first level expansion), instead of one.

\item \verb|<>|\par
  is like a solitary \verb|~|.

\item \verb|/<>5/6|\par
  unifies only with non-integer rational numbers unequal to $5/6$.

\item \verb|~<|\par
  means ``greater or equal'' (``not less.'')

\item \verb|~>|\par
  means ``less or equal.''

\item \verb|~<>|\par
  means ``not different,'' i.e. ``the same, in some sense.'' Strings
  are compared case insensitive. This applies to the full Unicode
  table, but defaults to ASCII and the upper 128 characters in the ISO
  8859-1 (Latin 1) character set if the characters are not UTF-8
  encoded. Subject and pattern can have different encodings and still
  match with success.

\item \verb|~#|\par
  does not unify with rational numbers.

\item \verb|~/|\par
  does not unify with non-integer rational numbers.

\item \verb|~/#|\par
  unifies only with integer numbers.

\item \verb|~/#<9|\par
  unifies only with integer numbers less than 9.

\item \verb|~/#<>0|\par
  unifies only with non-zero integer numbers.

\item \verb|~@|\par
  unifies only with non-atomic expressions.

\item \verb|~`|\par
  backtrack immediately.

\item \verb|[%|
  The current subject is stored in the variable \verb|sjt| and the
  expression carrying this prefix combination is evaluated. If the
  evaluation succeeds, the match succeeds and vice versa. The subject
  can be a neutral element of the subject list.
\end{description}


Many of these combinations can be combined further, e.g. \verb|~/#?!!|
accepts only an integer number and binds it to the indirect binding of
the atom following the prefixes.

If you want to match pattern \verb|!pat| one or more times (this is
often written as \verb|{pat}+|), use the complex pattern
\verb,(? !pat|`),. Likewise, if you want to match \verb|!pat| zero or
more times (\verb|{pat}*|), use \verb,(|? !pat|`),. These patterns
should not be the last subpattern or precede a subpattern that is
static and fixes the end point of the repeating sequence, because the
correct working of the repeating patterns depends on repeated
backtracking from following subpatterns. Bracmat may be optimized to
skip such backtracking and jump to the ``right'' end position if that is
fixed by the next subpattern. In the last resort, you can add a
pattern like \verb|()| or \verb|(&)| or \verb,(|), or \verb|(:)|,
which match with an empty list only (assuming that the connecting
nodes are spaces, otherwise use 0 in the case of a sum and 1 in the
case of a product). Such patterns don't fix the next position. Example:
\begin{ex}
{?} a a a c c:(? a|`) (|? b|`) (? c|`) (&) _com[_{_bc[a]_}+ _{_bc[b]_}* _{_bc[c]_}+]
\end{ex}

The following expression succeeds, because the subpattern doesn't
confront the substring \verb|aaak|.
\begin{ex}
{?} @(aaakamcccc:(? a|`) m (|? b|`) (? c|`)) (&)
\end{ex}

An empty string before the \verb|m| has the effect that Bracmat
doesn't optimize the backtracking process away.
\begin{ex}
{?} @(aaakamcccc:(? a|`) () m (|? b|`) (? c|`)) (&)
\end{ex}

\subsection{Minus sign}

The minus sign \verb|-| has only its normal arithmetic meaning when
used as an unary operator in front of a rational number or the
imaginary number \verb|i|.

If a product contains both a rational number and the number \verb|i|,
the \verb|i| takes precedence in accepting a minus sign:
\begin{v}
-7*i*a
\end{v}
is evaluated to \verb|7*-i*a|.

The advantage of having both \verb|i| and \verb|-i| becomes clear by
considering the following:
\begin{v}
(-1*i)^1/3
\end{v}
evaluates to \verb|(-i)^1/3|, which is written as \verb|-i^1/3|. As
expected, this is the complex conjugate of
\begin{v}
i^1/3.
\end{v}

If Bracmat did not have a separate representation for \verb|-i|, then
\begin{v}
(-1*i)^1/3
\end{v}
would evaluate to \verb|i|, (because \verb|i^3| is equal to
\verb|-i|),which means that Bracmat would not consider
\verb|(-1*i)^1/3| and \verb|i^1/3| as complex conjugates.

The transcendental numbers \verb|e| and \verb|pi| do not accept
arithmetic minus signs.

\section{String or atoms}

A string in Bracmat is the same as an ``atom.'' If you envisage a
Bracmat expression as a tree like structure, atoms or strings are to
be found in the leafs. In Bracmat terminology, an empty leaf is
syntactically represented by \emph{nil}. \emph{nil} is not an atom
proper, but an \emph{atom-or-nil}. So not every leaf contains an
atom. On the other hand, leafs may contain other things besides
\emph{atoms}, such as prefixes.

In Bracmat, atoms are less accessible than trees. Therefore there are
some ways to convert atoms to trees and back.
\begin{enumerate}
\item Conversion between an atom and its constituent characters:
  \begin{itemize}
  \item
    \verb|get$(|\emph{atom}\verb|,MEM,VAP)| puts every character in
    the literal \emph{atom} in its own leaf in a tree, which has space
    operators in every node.
  \item \verb|str$|\emph{tree} does more or less the inverse.
  \end{itemize}
\item Conversion between an atom and executable Bracmat code:
  \begin{itemize}
  \item
    \verb|get$(|\emph{atom}\verb|,MEM)| literally ``reads'' an atom as
    though it is a file with Bracmat expressions.
  \item \verb|lst$(|\emph{variable}\verb|,MEM)| ``writes'' the
    expression that is bound to \emph{variable} to an atom.
  \end{itemize}
\end{enumerate}

Atoms can be used as names for variables, functions, files, etc\ldots
Often they are used as literals, such as mathematical symbols or text.

Atoms consist of any number of non-zero bytes, up to the limits set by
the operating system and hardware. Atoms can be surrounded by
quotation marks, but are in many cases optional. You do need them if
you want parentheses, braces, semicolons, operators or prefixes to be
part of an atom. All UTF-8 encoded Unicode characters can be used in
strings. Some special characters have to be preceded by a backslash:
\begin{description}
\item  \verb|\a|\par
  attention (bell)
\item \verb|\b|\par
  backspace
\item \verb|\t|\par
  tab
\item \verb|\n|\par
  new line
\item \verb|\v|\par
  vertical tab
\item \verb|\f|\par
  form feed
\item \verb|\r|\par
  carriage return
\item \verb|\\|\par
  backslash
\item \verb|\"|\par
  double quote
\end{description}

If you precede a string with the prefix \verb|@|, then backslashes
are treated as normal
characters, e.g. \verb|sys$@"C:\dos\edit"|. Instead of the tab and new
line characters above, you may enter tabs and new lines by pressing
the tab and the return key, respectively.

Examples:
\begin{ex}
{?} this is a "tree" with\nsix leafs
{?} (this is a "tree" with
      seven leafs)
{?} "this" has 4 characters and "" (nil) none
{?} "this is an \"atom\" with 36 characters"
{?} "this string\nno verb"
{?} "this string
no verb either"
{?} "if zero equals one, someone divided by zero" = "1:0&get_dollar(\")y\",MEM)"
{?} get_dollar(!"if zero equals one, someone divided by zero",MEM)
\end{ex}

\section{Symbols}

\subsection{Literals}

In Bracmat, symbols have only literal meaning, unless we explicitly
state that we want a symbol to behave like a programming
variable. Contrary to most computer languages, Bracmat evaluates an
expression with literals not by expanding these literals to their
associated values (if they have any) and computing with these values
until a result is obtained, but by rearranging and transforming the
expression until a stable form is reached.
\begin{ex}
{?} a + a
_oct{!} 2*a
{?} i*i
_oct{!} -1
{?} e^(19/2*pi*i)
_oct{!} -i
\end{ex}

In Bracmat, the context of a symbol decides whether it is treated as a
variable or as a literal. So it is not necessary to kill a variable in
order to use its symbol as a literal, the two uses live peacefully
together.
\begin{ex}
{?} i=2       _com[variable _bc[i] is bound to the literal _bc[2]]
{?} !i^2      _com[the associated value of _bc[i] is squared]
_oct{!} 4
{?} i^2       _com[the literal _bc[i] (a special one, like _bc[pi] and _bc[e]) is squared]
_oct{!} -1
{?} 7 = prime _com[the variable _bc[7] is bound to the literal _bc[prime]]
{?} 7 is !7   _com[the symbol _bc[7] is used as both a literal and a variable]
_oct{!} 7 is prime
\end{ex}

\subsection{Variables}

Variables are represented by \emph{atoms}, but not all \emph{atoms}
are variables. The context of a symbol determines whether it is a
variable or not:
\begin{enumerate}
\item the left operand of the \verb|=| operator, unless this operand
  has zero length
\item the atom following the \verb|!| and \verb|!!| prefixes
\item within a pattern, a non-zero length atom following the \verb|?| prefix
\item the left operand of the \verb|$| and \verb|'| operators
\item the right operand of the \verb|$| operator in macro constructs
  (e.g. \verb|'(1+$a)|.)
\end{enumerate}

\section{The four evaluators}

In Bracmat, a binary operator may have four different effects,
depending on the context of the operator. For each of these contexts
there is one evaluator. Of these four evaluators, the macro evaluator
is relatively unimportant. The four evaluators are:
\begin{enumerate}
\item the expression evaluator, which takes care for the
  transformations of expressions,
\item the \emph{match evaluator}, which handles the unification of pattern
  expressions with subject expressions,
\item the \emph{macro evaluator}, which merely substitutes certain parts of
  an expression,
\item the \emph{archivist}, which doesn't do anything but keeping expressions
  alive.
\end{enumerate}

The expression evaluator is the first evaluator that a newly input
expression is confronted with. If necessary, it delegates tasks to one
of the other three evaluators. The match evaluator can only delegate
tasks to the expression evaluator and to the archivist. The macro
evaluator can only delegate tasks to the expression evaluator. The
archivist doesn't delegate any tasks to other evaluators.

The cross link is in most cases a binary operator. The exceptions to
this rule are in the context of the match evaluator: some
(combinations of) prefixes involve the expansion of a chain of
variable bindings and all but the last subexpansion demand the
expression evaluator. In the scheme below, you'll find the current
evaluator in the left column and the successor evaluators in the top
row. A cross link is represented by the relevant operator or
prefixes. If the change of evaluator only applies to the left (right)
operand of the cross link operator, the symbol ``l'' (``r'') is
used. If the transition depends on the left operand being \emph{nil},
the symbol ``n'' is used.
\begin{center}
  \begin{tabular}{lllll}
    \toprule
    & expression & match & macro & archivist \\
    \midrule
  expression & & \verb|:| & n\verb|'|r & \verb|=|r, \verb|'|r\\
  match & \verb|&|r, \verb|$|, \verb|'|l, \verb|?!|, \verb|!!| & & n\verb|'|r & \verb|=|r, \verb|'|r\\
  macro & \verb|$|r \\
    archivist \\
    \bottomrule
\end{tabular}
\end{center}

\section{Programming advice}

\subsection{Debugging}

If a program written in the Bracmat language doesn't work properly,
the same debugging protocol applies as with other programming
languages:
\begin{itemize}
\item Test extensively, above all with absurd and trivial input, in
  order to locate the pain in the many limbs of your program code.
\item Create watch points by inserting
  \verb|out$| instructions at sensible places (entry and exit points
  of functions, branches, before and after assignments.)
\item If you are in doubt whether Bracmat has interpreted your program
  in the way you intended, use
  \verb|lst$(|\emph{function-name}\verb|,|\emph{file-name}\verb|)| and
  inspect the code that is output into \emph{file-name}.
\item Errors that are easily made are:
  \begin{itemize}
  \item Forget that Bracmat may see neutral elements (0 terms, 1
    factors, zero length words) at places where this is not what you
    intend. Are all \verb|%|, \verb|`| and \verb|@| prefixes in place?
  \item Forget the grouping of operators. For example,
    \verb|a b c : ?%x ?%y| is
    grouped as \verb|(a b c):(?%x ?%y)|, but \verb|a,b,c : ?%x,?%y| is
    grouped as \verb|a,b,(c:?%x),?%y|. Remember that \verb|=| and
    \verb|.| have very
    low priorities, often making a pair of parentheses necessary.
  \item A misconceived idea about the Bracmat's backtracking
    mechanism. Unlike other languages with backtracking capabilities,
    Bracmat does not offer suspend/resume cycles. An expression
    embodying alternatives does not successively produce each
    alternative on every evaluation.
  \end{itemize}
\end{itemize}

\subsection{Using \texttt{out\dollar} as debugging aid}

The best aid in finding out what a program does, is using the
\verb|out$| function. The following code is part of a function that
computes $n!$.
\begin{v}
(loop = !k+1 : ?k          _com[increment _bc[k]]
             : <!n         _com[compare (old) _bc[k]+1 with _bc[n]; if not less, stop]
      & !fac*!k : ?fac     _com[multiply _bc[fac] by _bc[k]]
      & !loop)             _com[repeat until _bc[k] = _bc[n]]
\end{v}

Outside patterns \verb|out$| is most easily used. Inside patterns, if
you want to inspect a variable that has just been assigned a new
value, you use the \verb|&| operator to temporarily escape into the
non-pattern world. If you want to add extra text to the output,
remember that the argument to \verb|out$| is returned.
\begin{v}
(loop = out_dollar!k+1 : (?k & out_dollar(k is !k)) _com[show _bc[k] before and after increment]
                 : <!n                  _com[but before comparison with _bc[n]]
      & out_dollar("new fac is:" (!fac*!k:?fac)) _com[show _bc[fac] after computation]
      & out_dollar(still need !n+-1*!k loops) _com[you don't always need quotation marks]
      & !loop)
\end{v}

Now an example that is faulty. The purpose is to find two equal words
in a sentence with a non-linear pattern. This expression succeeds, but
finds nothing:
\begin{v}
(De kok snijdt recht en de meid snijdt scheef
    : (? ?a ? !a ?)
    & out_dollar(!a is occurring twice)
)
\end{v}

Check what is unified with \verb|? ?a|. To do so, put a variable after
the first \verb|?| and insert an output action after each subpattern.
\begin{v}
(De kok snijdt recht en de meid snijdt scheef
    : ((?x & out_d(x is !x))   _com[output _bc[x] after unification]
       (?a & out_d(a is !a))   _com[output _bc[a] after unification]
       ? !a ?)                _com[the remainder of the pattern]
    & out_dollar(!a is occurring twice)
)
\end{v}

The program would have to backtrack several times until \verb|?a| was
unified with \verb|snijdt|, but the match succeeds with \verb|?a|
unified with the omnipresent zero length word.  A \verb|%| sign avoids
this. A back quote \verb|`| helps speeding up, since it avoids
multi-word assignments and forces immediate backtracking.
\begin{v}
(De kok snijdt recht en de meid snijdt scheef
   : ((?x & out_dollar(x is !x))   _com[watch the number of words in _bc[?x] grow_ldots]
      (%`?a & out_dollar(a is !a)) _com[while _bc[?a] moves towards _bc[snijdt]]
      ? !a ?)                _com[there backtracking stops]
   & out_dollar(!a is occurring twice) _com[and the message is output]
)
\end{v}

\subsection{Using \texttt{dbg'} as debugging aid}

Some programming errors may be found with the built-in \verb|dbg|
function. The argument of the \verb|dbg| function is evaluated with an
internal debugging flag set. With this flag set, suspicious code is
warned against.

It is important that the argument is not evaluated before being passed
to the \verb|dbg| function.

\section{Functions}

\subsection{Definition of a function}

\subsubsection*{\normalfont\emph{function-name}\texttt{=}\emph{var1}
  [\texttt{,}\emph{var2}\texttt{,} \ldots]\texttt{.}\emph{function-body}}

\emph{var1}, \emph{var2}, etc. are explicitly declared local
variables. A function is called by
\emph{function-name}\verb|$|\emph{argument-expression} or
\emph{function-name}\texttt'\emph{argument-expression}, depending on
whether argument expression must be evaluated (\verb|$|) or not
(\verb|'|).

All Bracmat functions have arity one or two, that is, they accept one
or two arguments. The \emph{argument expression} to the right of the
\verb|$| or \verb|'| is always represented in the body of the function
by a local variable \verb|arg|.

The returned value of a function is simply the function body after it
has been evaluated.
\begin{ex}
{?} square=.!arg^2         _com[definition]
{?} square_d5               _com[call]
_oct{!} 25
{?} (swap = a,b            _com[declare local variables _bc[a] and _bc[b]]
        .   (!arg:(?a,?b)) _com[dissect _bc[arg] to find the real arguments]
          & (!b,!a))       _com[swap and return]
{?} swap_d(I think,I guess)
_oct{!} I guess,I think
\end{ex}

In a match context, a function call creates a second local variable,
\verb|sjt| (think SuJeT, SubJecT), the current subject. The value returned
from a function in a match context is interpreted as a pattern by the
match evaluator. However, if the function call fails, the pattern
match operation is not attempted and fails as well. The behaviour is
not defined if the returned value is negated.
\begin{ex}
{?} ( like
    =
      .   sim_dollar(!arg,!sjt):>9/10 & ?
        |   den_dollar(sim_dollar(!sjt,)):~<(den_dollar(sim_dollar(!arg,0)))
          & ~`
    )
{?} @( "Dogs and Cats are my enemies": ? like_dollar[]cat ?)
\end{ex}

Local variables in Bracmat are shallowly bound dynamically scoped
variables. This means that variables that are used in a function but
not locally declared in that function, are inherited from the
(function or global) context from which the function is called, which
in turn may inherit any undeclared variables from another calling
context. This scheme contrasts with most programming languages. It is
efficient, but the effect of forgetting to declare a local variable
can be unexpected behaviour of conceptually unrelated code.

It is possible to declare a function inside another function. Always
declare the name of an embedded function as a local variable.

\subsection{Lambda calculus, currying}

The lambda abstraction
\begin{v}
(_ensuremath[_lambda]x.x)y
\end{v}
translates to
\begin{v}
/('(x._dollar[]x))_dollar[]y
\end{v}

Bracmat's implementation of lambda calculus is a variant of Bracmat's
macro substitution.

The expression
\begin{v}
/('(x._dollar[]x))
\end{v}
evaluates to itself, not to something like
\begin{v}
/(=(x.foo))
\end{v}
(assuming that the variable \verb|x| had the value \verb|foo|).

In contrast, the same expression without the leading slash
\begin{v}
('(x._dollar[]x))
\end{v}
evaluates to
\begin{v}
=x.foo
\end{v}

The RHS of the \verb|$| operator must be an atom.

In an lambda abstraction
\begin{v}
/('(x._dollar[]x,_dollar[]y))
\end{v}
\verb|$x| is a bound variable and \verb|$y| is a free variable.

The expression \verb|$x| is only replaced by a value if \verb|x| is
the variable in the lambda abstraction or a lambda abstraction that
contains the lambda abstraction, as in
\begin{v}
/('(x.(/('(y.(_dollar[]x) (_dollar[]y)))_dollar[]aap)))_dollar[]noot
\end{v}
which evaluates to
\begin{v}
noot aap
\end{v}

No Bracmat variables come into play, not even \verb|arg|. Thus, in the
example above the value \verb|aap| is bound in \verb|($x)|, but never
assigned to a variable \verb|x|.

The expression
\begin{v}
/('(x.(/('(x.(_dollar[]x) (_dollar[]x)))_dollar[]aap)))_dollar[]noot
\end{v}
evaluates to
\begin{v}
aap aap
\end{v}

\subsection{Built-in functions}

\bfun{\bi{index}\bc{\dollar}\bi{array-name}}

Both \bi{array-name} and \bi{index} should evaluate to atoms. \bi{array-name}
may be preceded by prefixes, such as \bc{?} or \bc{!}. Indexing starts
at 0 and is done modulo(size-of-array). Negative values count from the
upper end of the array. The chosen index remains in force until a new
indexing function is evaluated.
\begin{v}[commandchars=_/;]
{?} tbl_d(array,4)              _com/declare _bc/array[0..3];;
{?} a-value : 2_d?array         _com/_bc/array[2]; := _bc/a-value;;
{?} array = another-value      _com/_bc/array[2]; := _bc/another-value;;
{?} !array : -1_d?array         _com/_bc/array[3]; := _bc/another-value;;
{?} 45 : 1_d?array              _com/_bc/array[1]; := _bc/45;;
{?} 2'!array : 3'!array        _coma/are _bc/array[2]; and _bc/array[3]; equal?;
                               _comc/notice use of _bc' instead of _bc_d;
\end{v}

\bfun{\bc{alc\d}\bi{number-of-bytes}}
\index{alc@\bc{alc}}

This function allocates memory and returns the starting address of the
allocated memory, but crashes the program if not enough memory can be
allocated. Access to memory that has been allocated in this way is by
means of \verb|pee$| and \verb|pok$|. Any allocated memory should at
some time be returned to the memory heap with the function
\verb|fre$|.

\bfun{\bc{arg\d} or \bc{arg\d}\bi{number}}
\index{arg@\bc{arg}}

If Bracmat is started with any arguments (argc $>$ 1) every argument is
evaluated from left to right, unless arguments are consumed by calls
to \verb|arg$|.

For example
\begin{v}
bracmat get_d[]myprog -i c:\documents\input.txt -o d:\html\index.html
\end{v}
would evaluate
\begin{v}
get_d[]myprog
-i
c:\documents\input.txt
-o
d:\html\index.html
\end{v}
in that order. Evaluating the last four arguments is not very
meaningful, however: the backslashes are interpreted as escapes, which
they are not. Moreover, the colon and the dot are interpreted as
operators. However, the bracmat program \verb|myprog| can call the
function \verb|arg$| four times and in that way empty the queue of
arguments. \verb|arg$| returns an atom containing an exact copy of the
next program argument. Using string matching the arguments can be
parsed, if necessary.

Precautions must be taken if the path or name of the bracmat program
contains characters that can be mistakenly interpreted, e.g. (in
Windows)
\begin{v}
bracmat "get_d@\"c:Program Files\yourprog.bra\""
\end{v}
In *N?X the apostrophes surrounding the first argument must be
replaced by quotes.

A second form is \verb|arg$|\emph{N}, where $0 \leq N <
{}$argc. \verb|arg$0| will normally return the command name
\verb|bracmat| or a path leading to \verb|bracmat|. Here is a simple
program \verb|myprog| that demonstrates the two ways of calling the
\verb|arg$| function
\begin{v}
{ myprog }

(test=
  0:?N
&   whl
  ' ( arg$:?argument
    & out$(The next argument is !argument)
    )
&   whl
  ' ( arg$!N:?argument
    & out$(Argument !N is !argument)
    & 1+!N:?N
    )
);

!test;
\end{v}
Now running bracmat with these arguments (example is Windows):
\begin{v}
bracmat get_d[]myprog -i c:\documents\input.txt -o d:\html\index.html
\end{v}
results in the following output being written to the terminal:
\begin{v}
The next argument is -i
The next argument is c:documentsinput.txt
The next argument is -o
The next argument is d:htmlindex.html
Argument 0 is bin\bracmat
Argument 1 is get_d[]myprog
Argument 2 is -i
Argument 3 is c:documentsinput.txt
Argument 4 is -o
Argument 5 is d:htmlindex.html
\end{v}

\bfun{\bc{asc\d}\bi{character}}
\index{asc@\bc{asc}}

\verb|asc$| returns the integer value that corresponds to the
character according to the current table used by the operating system
(e.g. an extended ASCII table.)
\begin{ex}
{?} asc_d"+" _com[return ASCII value of character _bc+]
_oct{!} 43
\end{ex}

\bfun{\bc{bez\d}}
\index{\bez@\bc{bez}}
\verb|bez$| returns two numbers separated by a dot operator. The first number is the
number of currently allocated binary nodes and leafs. The second number is the
maximum number of allocated binary nodes and leafs in this session, until now.
These numbers are not of much use, except for controlling that there are no
memory leaks. The function \verb|bez$| can be turned off by setting \verb|TELMAX| to zero
in bracmat.c before compilation.

In interactive mode, with \verb|TELMAX| set to one, Bracmat shows
(1) whether the evaluation was successful or not, (2) the amount of CPU time
and (3) the result of calling \verb|bez$| after each non-empty evaluation result.

\begin{ex}
{?} 2^10000+-1*3^100000*5^-10000
_oct{!} -13349714142304014694589143904897822922452485076062773553456279939841274146
_oct...2182755869676383936027544370832840538165786625768305384553968906402587890625
_oct   S   0,72 sec  (3990.13910)
\end{ex}

\bfun{\bc{chr\d}\bi{value}}
\index{\chr@\bc{chr}}

\verb|chr$| returns the character at location value in the current
table of characters used by the operating system (e.g. an extended
ASCII table.) \verb|chr$| fails if \bi{value} equals 0.
\begin{ex}
{?} chr$255 _coma[return the last character from the current table of characters]
            _comc[(assuming a machine with 8-bit characters)]
{?} ( tolower=.
        !arg:~<A:~>Z                  _com[if _bc[arg] is in the range _bc[A]-_bc[Z]]
      & chr$(asc$!arg+-1*asc$A+asc$a) _com[then return its lower case equivalent]
    | !arg                            _com[else return _bc[arg] unchanged]
    ) _coma[works only correctly if the ``distance'' between lower and upper case]
      _comc[versions is the same for all characters in the range _bc[A]-_bc[Z]]
{?} tolower$G
\end{ex}

\bfun{\bc{clk\d}}
\index{\clk@\bc{clk}}

\verb|clk$| returns the number of CPU seconds that that has been spend
on running the current session of Bracmat. The number is an unreduced
quotient of number of clock ticks and the number of clock ticks per
second.
\begin{ex}
{?} clk_d
_oct{!} 30375/1000
\end{ex}

\bfun{\bc{d2x\d}\bi{decimal-value}}
\index{d2x@\bc{d2x}}

\verb|d2x$| converts a decimal number between 0 and 4294967295
($2^{32}-1$) to an hexadecimal number consisting of characters
\verb|0|--\verb|9| and \verb|A|--\verb|F|. On 64-bit platforms the
upper bound is 18446744073709551615 ($2^{64}-1$). The function fails if
the argument is not an integer number or if the number is outside this
range.
\begin{ex}
{?} d2x_d(2^32+-1)
_oct{!} FFFFFFFF
\end{ex}

\bfun{\bc{dbg'}\bi{expression}}
\index{dlg@\bc{dbg}}

Create warnings in situations that probably are programming
errors. Currently, a warning is generated when a function definition
can not be found.
\begin{ex}
{?} dbg'(foo_d[]a)
{?} dbg'((myclass.yourfunc)_d[]X)
\end{ex}

\bfun{\bc{den\d}\bi{rational-number}}
\index{den@\bc{den}}

The denominator of \emph{rational-number} is returned. There is no
built-in numerator extractor function.
\begin{ex}
{?} den_d22/7
_oct{!} 7
{?} num = .!arg*den_d!arg _com[home-made numerator function]
{?} num_d22/7
_oct{!} 22
{?} den_d[]sim_d(,monkey)    _com[return length of word _bc[monkey]]
_oct{!} 6
\end{ex}

\bfun{\bc{div\d(}\bi{rational-number}\bc{,}\bi{rational-number}\bc{)}}
\index{div@\bc{div}}

\verb|div$| returns the (integral) quotient of its arguments.
\begin{ex}
{?} div_d(123/45,67/890)
_oct{!} 36
\end{ex}

\bfun{\bc{fil\d(}[[\bi{file-name}][\bc,\bi{option}[\bc,\bi{number}[\bc,\bi{value-to-output}]]]]\bc{)}}
\index{fil@\bc{fil}}

\verb|fil$| is a multi-purpose low level I/O function.
\begin{quote}
\begin{description}
\item \bc{fil\d(}[\bi{file-name}]\bc,\bi{mode}\bc)\par
  set file mode, open a file in a file mode
\item \bc{fil\d(}[\bi{file-name}]\bc,\bi{type}\bc,\bi{size}[\bc,\bi{number}]\bc)\par
  prepare for reading or writing fixed sized records
\item \bc{fil\d(}[\bi{file-name}]\bc,\bc{STR}[\bc,\bi{stop}]\bc)\par
  prepare for reading or writing variable sized record
\item \bc{fil\d(}\bi{file-name}\bc,\bc{TEL}\bc)\par
  tell position inside file
\item \bc{fil\d(}\bi{file-name}\bc,\bi{whence}\bc,\bi{offset}\bc)\par
  go to file position
\item \bc{fil\d(}[\bi{file-name}][\bc{,,}\bi{number}]\bc)\par
  read from file 
\item \bc{fil\d(}[\bi{file-name}]\bc{,,}\bi{number}\bc,\bi{value}\bc)\par
  write to file
\item \bc{fil\d(}[\bi{file-name}]\bc{,SET,-1}\bc)\par
  close a file
\end{description}
\end{quote}

\bfun{\bc{fil\d(}[\bi{file-name}]\bc,\bi{mode}\bc)}

Set file mode, open file in file mode.

Option \emph{mode} is one of the following:
\begin{quote}
\begin{description}
\item \bc{r}\par
  open text file for reading
\item \bc{w}\par
  create text file for writing, or truncate to zero length
\item \bc{a}\par
  append; open text file or create for writing at EOF
\item \bc{rb}\par
  open binary file for reading
\item \bc{wb}\par
  create binary file for writing, or truncate to zero length
\item \bc{ab}\par
  append; open binary file or create for writing at EOF
\item \bc{"r+"}\par
  open text file for update (reading and writing)
\item \bc{"w+"}\par
  create text file for update, or truncate to zero length
\item \bc{"a+"}\par
  append; open text file or create for update, writing at EOF
\item \bc{"r+b"} or \bc{"rb+"}\par
  open binary file for update (reading and writing)
\item \bc{"w+b"} or \bc{"wb+"}\par
  create binary file for update, or truncate to zero length
\item \bc{"a+b"} or \bc{"ab+"}\par
  append; open binary file or create for update, writing at EOF
\end{description}
\end{quote}

\bfun{\bc{fil\d(}[\bi{file-name}]\bc,\bi{type}\bc,\bi{size}[\bc,\bi{number}]\bc)}

Prepare for reading or writing fixed sized records.

Option \emph{type} is one of the following:
\begin{quote}
  \begin{description}
  \item \bc{CHR}\par
    character or string I/O
  \item \bc{DEC}\par  
    number I/O
  \end{description}
\end{quote}

Option \bi{size} must be a non-negative integer and determines the
number of bytes that are read or written as one chunk during a future
call to \verb|fil$|. If type is \verb|DEC|, only values 1, 2 and 4 are
valid, corresponding to 1, 2 and 4 byte sized integers,
respectively. Notice that 2 and 4 byte integers are not portable
between implementations with different byte order. The optional
\bi{number} tells how many read or write operations of size \bi{size}
have to be performed. If type is \verb|DEC|, the product of \bi{size}
and \bi{number} may not be greater than 4. If a number is read or
written in 2 or more chunks, the least significant bytes or 16 bit
words are read or written first (little-endian.)

\bfun{\bc{fil\d(}[\bi{file-name}]\bc,\bc{STR}[\bc,\bi{stop}]\bc)}

Prepare for reading or writing variable sized record.

Option \bi{stop} is a string of characters. If the read character or
the character to be written is equal to one of the characters in the
\bi{stop} string, reading or writing stops. The default is not to stop
until the end of the file (reading) or the end of the string
(writing.)

\bfun{\bc{fil\d(}\bi{file-name}\bc,\bc{TEL}\bc)}

Tell the position inside the file.

Returns the current value of the file position indicator.

\bfun{\bc{fil\d(}\bi{file-name}\bc,\bi{whence}\bc,\bi{offset}\bc)}

Go to file position.

Sets the current value of the file position indicator to an
\bi{offset} based on the value of \bi{whence}.

Option \bi{whence} is one of the following:
\begin{quote}
  \begin{description}
  \item \bc{SET}\par
    start of file
  \item \bc{CUR}\par
    current file position
  \item \bc{END}\par
    end of file (in some implementations, binary files may not handle
    \verb|END|)
  \end{description}
\end{quote}

For a text file, offset must be 0, or the value returned from a call
to \bc{fil\d(}\bi{file-name}\bc{,TEL)}, in which case \bi{whence} must
be \bc{SET}.

\bfun{\bc{fil\d(}[\bi{file-name}][\bc{,,}\bi{number}]\bc)}

Read from a file.

Reads (\bi{mode} permitting) \bi{number} chunks of \bi{size}
bytes. When reading variable sized records (\bc{STR}), \bc{fil\d}
returns a dot-separated list of two elements: the found stop character
and the read string (which does not contain the stop character.)
{\fontsize{11}{12}\selectfont
\begin{ex}
{?} fil$("mytext.txt","rb")      _com[open for reading in binary mode]
{?} fil$(,STR)                   _com[prepare for reading until the next 0-byte]
{?} fil$:(?line.?stop)           _com[read until the next 0-byte]
{?} fil$(,SET,-1)                _com[close the file]

{?} fil$("mytext.txt","rb")      _com[open for reading in binary mode]
{?} fil$(,STR,"\n \t\r")         _com[prepare for reading until the next whitespace]
{?} :?words                      _com[in a moment, accumulate all words in this variable]
{?} whl'(fil$:(?word.?stop)&!word !words:?words)&  _com[read all words]
{?} fil$(,SET,-1)                _com[close the file]
{?} !words                       _com[show all words, in reversed order]
\end{ex}
}

\bfun{\bc{fil\d(}[\bi{file-name}]\bc{,,}\bi{number}\bc,\bi{value}\bc)}

Write to a file.

Writes (\bi{mode} permitting) \bi{number} chunks of size bytes from
\bi{value}. If type is \bc{DEC}, $\bi{number} \times \bi{size}$ must
be 1, 2, 3 or 4. \bi{value} must be an integer value and is cast to a
binary number with at most
$\bi{number}\times\bi{size}\times8\bi{ bits}$. This number is stored
in $\bi{number} \times \bi{size}$ bytes, which in turn are output. If
number is greater than 1, the byte(s) with the least significant
digits are output first. In machines with little-endian byte-order,
only the product $\bi{number}\times\bi{size}$ matters. If \bi{type} is
\bc{CHR} and the length of \bi{value} is shorter than
$\bi{number}\times\bi{size}$, \bi{value} is padded with spaces (to the
right.) If type is \bc{STR}, \bi{number} must be the empty string.

\bfun{\bc{fil\d(}[\bi{file-name}]\bc{,SET,-1}\bc)}

Close a file.

An open file is closed by specifying an impossible file position.

\bfun{\bc{flg\d(=}\bi{expression}\bc)}
\index{flg@\bc{flg}}

\bc{flg} returns a copy of the expression without prefixes (``flags'')
and a new leaf with the prefixes of the original expression. These two
results are coupled with a dot operator, the prefixes to the left and
the expression without prefixes to the right. The result is protected
against evaluation by a \bc{=} operator.
\begin{ex}
{?} flg_d(=~#<>?%@a)
_oct{!} (=~#<>%@?).a
\end{ex}

Use macro evaluation if the expression to be split is the value of a
variable:
\begin{ex}
{?} X=~(%+%)
_oct{!} X
{?} flg$('$X):(=?prefixes.?expr)
_oct{!} =~.%+%
{?} glf$('($prefixes.%*%))
_oct{!} =~(%*%)
\end{ex}

\bfun{\bc{glf\d(=}\bi{prefixes}\bc.\bi{expression}\bc)}
\index{glf@\bc{glf}}

\bc{glf} returns a copy of \bi{expression} with \bi{prefixes} added to
its prefixes. If \bi{expression} has one or more prefixes also present
in \bi{prefixes}, then \bc{glf} fails. Therefore, \bc{glf} can be used
to test for the presence of one or more prefixes. The result is
protected against evaluation by a \bc= operator. The function \bc{glf} has an
effect that is the opposite of \bc{flg}.
\begin{ex}
{?} glf$flg$(=?a)
_oct{!} =?a
\end{ex}

Use macro evaluation if the expression to be split is the value of a
variable.
\begin{ex}
{?} X=?!x
_oct{!} X
{?} flg$('$X):(=?prefixes.?expr)
_oct{!} =?!.x
{?} glf$('($prefixes.z))
_oct{!} =?!z
\end{ex}

\bfun{\bc{fre\d}\bi{memory-address}}
\index{fre@\bc{fre}}

\verb|fre$| returns a chunk of memory to the memory pool (heap). The
only valid parameter is a return value of \verb|alc$|. Applying
\verb|fre$| to a chunk of memory that was never allocated or that has
been returned already results in undefined behaviour of the program.
\begin{ex}
{?} alc$1000:?p  _com[allocate chunk of 1000 bytes from the memory pool]
{?} fre$!p       _com[return this chunk to the memory pool]
\end{ex}

\bfun{\bc{get\d(}\bi{atom-or-nil}[\bc{,MEM}][\bc{,ECH}][\bc{,VAP}][\bc{,STR}][\bc{,TXT}$\vert$\bc{BIN}][\bc{,JSN}]$\vert$[[\bc{,X}]$\vert$[\bc{,HT}]\bc{,ML}[\bc{,TRM}]])}
\index{get@\bc{get}}

\verb|get$| reads and interprets characters in a string (internal
memory) or file (external memory or keyboard).

Options:
\begin{quote}
  \begin{description}    
  \item \bc{MEM}\par
    Present: The name of the first parameter is the source of the
    characters (MEMory.) Not present: A file with the name of the
    first parameter is the source.
  \item \bc{ECH}\par
    Present: The characters are echoed to the screen as they are
    read. Not present: No echo.
  \item \bc{VAP}\par
    Present: The (8-bit) characters are read as is. Extra spaces are
    inserted between the characters (VAPorised.) Not present: No extra
    spaces are added.
  \item \bc{STR}\par
    Present: The characters are read into one string. Not present: The
    characters are interpreted as parts of a Bracmat expression and
    evaluated after the whole expression has been read.
  \item \bc{TXT}\par
    Present: File is read in ``text'' mode (file mode \verb|r|.) Not present:
    File is read in binary mode (file mode \verb|rb|).
  \item \bc{BIN}\par
    Present: File is read in binary mode. Not present: File is still
    read in binary mode.
  \item \bc{JSN}\par
    Present: The input is parsed as JSON.
  \item \bc{ML}\par
    Present: The input is parsed as markup (SGML, XML or HTML). Any
    unrecognised entity reference is preceded by a DEL character
    (ASCII code 127 (decimal)). Any DEL character in the input is also
    preceded by a DEL character, similar to how the traditional escape
    character \verb|\| is itself represented by doubling it:
    \verb|\\|.
  \item \bc{HT} (together with \bc{ML})\par
    Present: HTML entities are translated to UTF-8 characters. Not
    present: Only XML entities are translated to UTF-8 characters.
  \item \bc{X} (together with \bc{ML})\par
    Present: Only XML entities are translated to UTF-8
    characters. Processing instructions are assumed to have the syntax
    \bc?\ldots\bc?. Not present: Processing instructions are assumed
    to have the syntax \bc?\ldots\ .
  \item \bc{TRM} (together with \bc{ML})\par
    Present: Heading and trailing whitespace is cut down to a single
    space in character data. Not present: All whitespace is
    kept. Input can be exactly reproduced when writing, except
    HTML entities.
  \end{description}
\end{quote}

The \bc{VAP} option is evaluated before the \bc{STR} option.

Applications:
\begin{v}
get'(matrix,ECH)
\end{v}
Read file \bc{matrix} and evaluate the expressions (delimited by
semicolons) therein. If the system finds a syntax error in a multiple
expression file, the \bc{ECH} option makes it easier to locate the
error.

\begin{v}
get'(matrix,STR):?intern
\end{v}
Read file \bc{matrix} into a string called \bc{intern}. If this file
contains Bracmat instructions, they hereafter exist in a sleeping
state in memory.

\begin{v}
get_d(!intern,MEM)
\end{v}
\bc{!intern} is, in this example, expanded to an atom with a very long
name, namely all of the text of file \bc{matrix}. The sleeping
expressions are evaluated one after the other, just as if
\verb|get'matrix| was evaluated.

\begin{v}
get'(,VAP):?space-list
\end{v}
Read characters from standard input (normally keyboard) until next
line feed character. Put each character into an atom. Put all atoms
into a linear list with space operators. Bind this list to the name
\bc{space-list}.

\begin{v}
get'(")y",MEM)
\end{v}
Read the sleeping expression \verb|)y| from memory. The lexical
scanner will find an unbalanced right parenthesis, which could mean
that this Bracmat session should stop. The \bc{y} confirms this
assumption and the program will come to an end immediately. If the
\bc{y} hadn't been present, Bracmat would ask
\verb|end session? (y/n)| after which the user has to choose. This
trick is useful in batch processing.

If the first parameter is \bi{nil} or \verb|stdin| and the \bc{MEM}
option is not used, input is coming from standard input. Take care that
you put filenames in double quotes if they contain any characters that
can be misunderstood, such as dots, (back)slashes or dollars.

\bfun{\bc{lst\d(}(\bc=\bi{expression}) or \bi{variable}*[\bc{,LIN}][\bc{,RAW}][\bc{,WYD}]\bc)}
\index{lst@\bc{lst}}

\verb|lst$| outputs all present bindings of one or more variables to
standard output. If a variable is local to a function and a variable
of the same name already exists in the context of another function
invocation or globally, all instances will be listed!

If a variable is listed to stdout, the listing starts with
\verb|(varname=| and ends with \verb|);|. The surrounding parentheses
are suppressed if a variable is listed to a file.

Expressions headed by the \bc= operator can be used instead of variable
names. In that case no semicolon is appended. The listing starts with
\bc{(=} and ends with \bc), followed by a newline.

With the \bc{RAW} option, only the expression right of the \bc=
operator is listed.

The \bc{LIN} option suppresses most newlines and all other unneeded
whitespace characters.

The \bc{WYD} option makes lines wider. That is especially useful if your code is
deeply nested. This option has no effect if the \bc{LIN} option is provided as well.

If the first parameter is the zero-length string, then all variables
with names starting with a character below ASCII 128 are shown. If a
variable has more than one binding (arrays/stacks) then the current
value is preceded by a \bc> sign. The second parameter is optional.

\begin{ex}
{?} lst_d[]help      _coma[shows this programme on screen,]
                  _comc[unless stdout has been redirected]
{?} lst_d(tay,LIN) _com[listing without indentations of function _bc[tay_d]]
\end{ex}

If \bc{LIN} is not present, output is very much indented, sometimes
making it more readable for humans. If \bc{LIN} is present, output is
as compact as possible.

\bfun{\bc{lst\d(}(\bc=\bi{expression}) or \bi{variable}*\bc{,MEM}[\bc{,LIN}][\bc{,RAW}][\bc{,WYD}]\bc)}

The difference with the preceding form is that output takes place to
memory. What is normally visible on screen is put in one atom, which
is the return value of the call to \bc{lst}. It has the opposite effect of
\verb|get$(|\bi{atom}\verb|,MEM)|. In theory one can save some memory by writing an expression
to a single leaf node, because each node in an expression has some memory
overhead. In practice the saving can be quite small or non-existent, because
Bracmat expressions often share part of their data structures with other
expressions.

Example:
\begin{ex}
{?} lst_d(fct,MEM):?sleeping-fct
{?} tbl_d(fct,0)   _com[remove function _bc[fct_d] from memory]
{?} _com[_ldots celebrate space-saving, until _bc[fct_d] is needed_ldots]
{?} get_d(!sleeping-fct,MEM)
\end{ex}

\bfun{\bc{lst\d(}(\bc=\bi{expression}) or \bi{variable}*\bc,\bi{file-name}\bc,\bc{NEW}$\vert$\bc{APP}[\bc{,LIN}][\bc{,TXT}][\bc{,BIN}][\bc{,WYD}]\bc)}

This time, output is sent to the named file instead of standard
output. The third argument is explained below. Code that has been
saved with \verb|lst$| can be reloaded with \verb|get$|.

\begin{ex}
{?} lst_d(,"all",NEW,LIN)
    _com[write all current code without indentations to file _bc[all]]
{?} lst_d(tay,taylor,NEW)
    _com[save function _bc[tay_d] to file _bc[taylor] in indented format]
\end{ex}

One of the options \verb|NEW| and \verb|APP| must be present:
\begin{quote}
  \begin{description}
  \item \bc{NEW}\par
    Tells the computer to open a new file or overwrite an old one.
  \item \bc{APP}\par
    Directs output to an existing file. If the file does not exist, it
    is created first.
  \end{description}
\end{quote}
Options \verb|TXT| and \verb|BIN| overrule the default file mode of
the functions \verb|put| and \verb|lst|.
\begin{quote}
  \begin{description}
  \item \bc{TXT}\par
    Tells Bracmat to write a file in text mode. This is the default
    file mode for \verb|put|. In Windows, each line feed character
    will be preceded by a carriage return. In Unix and Linux, text
    mode and binary mode are the same.
  \item \bc{BIN}\par
    Tells Bracmat to write a file in binary mode. This is the default
    file mode for \verb|lst|.
  \end{description}
\end{quote}

\bfun{\bc{map\d(}\bi{fnc}\bc.\bi{list}\bc)}
\index{map@\bc{map}}

\verb|map$| produces a list containing the results of applying
\bi{fnc} to each member in \bi{list}. \bi{fnc} can be the name of a
function, a function definition (``anonymous function'') or a lambda
abstraction. \bi{fnc} can also be the name of a built-in
function. (See the first example.) The members in \bi{list} must be
separated by the space operator.
\begin{ex}
{?} map_d(rev.aap noot mies)
_oct{!} paa toon seim
{?} map_d(/('(x._d[]x^2)).1 2 3 4)
_oct{!} 1 4 9 16
{?} map_d((=.!arg^2).1 2 3 4)
_oct{!} 1 4 9 16
{?} (square=.!arg^2)&map_d(square.1 2 3 4)
_oct{!} 1 4 9 16
{?} (  map
    _d[] ( (
        =   x
          .     !arg:?*?^%?x*?*?^!x*?
              & (!arg."same exponent" !x)
            | (!arg.)
        )
      . a*b^3*c^2 d*f^3*g^2*h*j^3 o*p
      )
    )
_oct{!} (a*b^3*c^2.)
_oct    (d*f^3*g^2*h*j^3.same exponent 3)
_oct    (o*p.)
\end{ex}

\bfun{\bc{mop\d(}\bi{fnc}.\bi{expression}.(=\bi{non-leaf expression}\bc))}
\index{mop@\bc{mop}}

\verb|mop$| traverses a list-like expression element by element and outputs a space
operator separated list. For that to work, \verb|mop$| needs an extra argument that
tells which operator to use. That argument is always headed by \verb|=|, the
right hand side of which is a non-leaf expression. The top operator of that
expression is used as the separating operator.
\begin{ex}
{?} mop_d((=.!arg).aap+noot+mies.(=+))
_oct{!} aap mies noot
{?} (x=2*a+i*b+e\Lc) & mop_d((=.!arg).!x.()'($x))
_oct{!} 2*a e\Lc c i*b
_oct{!}
\end{ex}

It is possible to have a list with space operators as separating operator:

\begin{ex}
{?} mop'((=.!arg).a b c.(=x y))
_oct{!} a b c
\end{ex}

Another way to do this is to use the \verb|map$| function

\begin{ex}
{?} map'((=.!arg).a b c)
{!} a b c
\end{ex}

\bfun{\bc{mem\d}[\bc{EXT}]}

\index{mem@\bc{mem}}

\verb|mem$| produces a list of all currently existing variables,
except those beginning with a character above ASCII 126. The
\verb|EXT| option adds information about the number of occurrences
(array or stack size-1) of those variables which have more than one
occurrence and shows which of them is currently in focus (index into
array: 0 .. size-1). The predefined function \verb|cat$| makes use of
\verb|mem$|.
\begin{ex}
{?} mem$
{?} mem$EXT
\end{ex}

\bfun{\bc{mod\d(}\bi{number}\bc,\bi{divisor}\bc)}
\index{mod@\bc{mod}}

\verb|mod$| divides \bi{number} by \bi{divisor}. The remainder is returned.
\begin{ex}
{?} mod_d(22,7)
_oct{!} 1
\end{ex}

\bfun{\bc{new\d}\bi{object} or \bc{new\d(}\bi{object}\bc,\bi{args}\bc)}
\index{new@\bc{new}}

\verb|new$| creates a shallow copy of an \bi{object} and calls the
method \verb|new| of the new object, if there is one. With the second
form, \bi{args} is passed to the method \verb|new|.

Example:
\begin{ex}
{?} (patient=
    (name=(first=John),(last=Bull)) _com[name is a copy, first and last are not]
  , (age=20)
  , (new
    =
      .   out$"hello world"
        & new$(its.name):(=?(its.name)) _com[create fresh copies of first and last]
        &   !arg
          : (?(its.name.first).?(its.name.last).?(its.age))
  ))
{?} new$(patient,(Albert.Keinstein.42)):?x
{?} new$(patient.name):(?Name)
{?} Alice:?(Name..first)
{?} new$(('$patient),(Albert.Keinstein.42)):?y {x and y are identical !}
{?} new$(=(a=1),(b=2)):?ab {"die" is called when ab is reassigned}
{?} 3:?(ab..a)
{?} new$(=(a=1),(b=2),(new=.),(die=.)):(=?cd) {"die" is called at once!}
{?} 3:?(cd.a)
\end{ex}

When an object was created with the \verb|new$| function, an internal
flag is set in the object telling the system that the \verb|die|
method must be called just before deletion of the object. The
\verb|die| method, like the \verb|new| method, is optional and should
be used to do clean-up.

\bfun{\bc{pee\d(}\bi{address}[\bc,\bi{size}]\bc)}
\index{pee@\bc{pee}}

Depending on \bi{size}, a 1, 2 or 4 byte sized integer allocated at
\bi{address} is returned.

2 and 4 byte integers may only start at addresses that are multiples
of 2 and 4, respectively. \bi{address} is lowered to the nearest allowable
value, if needed. Notice that multi-byte integers are stored
differently in little-endian (iAPx86, VAX, ARM) and big-endian
(MC680x0) machines. Many operating systems abort programs that try to
access non-existent or protected memory areas.

\begin{ex}
{?} chr$pee$34567  _com[return value at address 34567 (1 byte) as a character]
{?} pee$(34567,2)  _com[return value at address 34566 (2 bytes)]
{?} pee$(34567,4)  _com[return value at address 34564 (4 bytes)]
\end{ex}

\bfun{\bc{pok\d(}\bi{address}\bc,\bi{value}[\bc,\bi{size}]\bc)}
\index{pok@\bc{pok}}

Depending on \bi{size}, a 1, 2 or 4 byte sized integer is stored at
address.

2 and 4 byte integers may only start at addresses that are multiples
of 2 and 4, respectively. \bi{address} is lowered to the nearest
allowable value, if needed. Notice that multi-byte integers are stored
differently in little-endian (iAPx86, VAX, ARM) and big-endian
(MC680x0) machines. Many operating systems abort programs that try to
access non-existent or protected memory areas.

\begin{ex}
{?} pok_d(34567,asc_d[]K) _coma[store the internal value of the character _bc[K] at]
                      _comc[memory location 34567 (as 1 byte)]
{?} pok_d(34567,-1,4)  _coma[store 2^32-1 at memory location 34564]
                      _comc[assuming 1-complement arithmetic]
\end{ex}

\bfun{\bc{put\d(}\bi{expression}[\bc{,LIN}][\bc{,WYD}]\bc)}
\index{put@\bc{put}}

Sends \bi{expression} to standard output. The cursor is positioned
after the last output character. The predefined function
\verb|out$| does the same as \verb|put$|, with the exception that it
positions the cursor on the beginning of the next line.

\begin{ex}
{?} put_d("b+a" is after evaluation b+a)
\end{ex}

\bfun{\bc{put\d(}\bi{expression}\bc{,MEM}[\bc{,LIN}][\bc{,WYD}]\bc)}

\bi{expression} is stringified and placed into an atom, which is the
return value of the call. This use of
\verb|put$| is similar to the \verb|str$| function, but whereas
\verb|str$| suppresses the space operator, \verb|put$| transfers every
character, including space operators, to the atom.

\bfun{\bc{put\d(}\bi{expression}\bc,\bi{file-name}\bc{,NEW}$\vert$\bc{APP}[\bc{,LIN}][\bc{,WYD}]\bc)}

Write \bi{expression} to the named file.

\begin{ex}
{?} put_d(tay_d(e^x,x,10),"e.out",APP)
\end{ex}

\bfun{\bc{ren\d(}\bi{oldname}\bc,\bi{newname}\bc)}
\index{ren@\bc{ren}}

Renames a file or directory or moves a file. The \verb|ren$| function
succeeds unless a syntactic error was made. If there is an error at
the operating system level, one of the following codes is returned:
\begin{quote}
  \begin{description}
  \item \bc{EACCES}\par
    File or directory specified by \bi{newname} already exists or
    could not be created (invalid path); or \bi{oldname} is a
    directory and \bi{newname} specifies a different path.
  \item \bc{ENOENT}\par
    File or path specified by \bi{oldname} not found.
  \item \bc{EINVAL}\par
    Name contains invalid characters.
  \end{description}
\end{quote}

If the command succeeds at the operating system level, the value 0 is
returned.

\bfun{\bc{rmv\d}\bi{file-name}}
\index{rmv@\bc{rmv}}

Removes a file. The \verb|rmv$| function succeeds, unless a syntactic
error was made. If there is an error at the operating system level,
one of the following codes is returned:
\begin{quote}
  \begin{description}
  \item \bc{EACCES}\par
    Indicates that the path specifies a read-only file or that the
    file is open.
  \item \bc{ENOENT}\par
    Indicates that the filename or path was not found or that the path
    specifies a directory.
  \item \bc{EINVAL}\par
    Name contains invalid characters.
  \end{description}
\end{quote}

If the command succeeds at the operating system level, the value 0 is
returned.

\bfun{\bc{rev\d}\bi{atom}}
\index{rev@\bc{rev}}

Reverses the order of bytes in an atom. This function can be useful in
case of a string match that asks for the last occurrence of a pattern.

The \verb|rev$| function succeeds on all atoms and fails on all other
expressions.

\bfun{\bc{sim\d(}\bi{atom-or-nil}\bc,\bi{atom-or-nil}\bc)}
\index{sim@\bc{sim}}

\verb|sim$| uses the Ratcliff/Obershelp pattern matching algorithm in
establishing a measure of the similarity between its two (atomic)
arguments. The returned value is an unsimplified fraction. The
denominator is the sum of the numbers of characters in both
arguments. The numerator is the total number of characters that have
been matched successfully. Matching is case-insensitive. This applies
to the full Unicode table, but defaults to ASCII and the upper 128
characters in the ISO 8859-1 (Latin 1) character set if the characters
are not UTF-8 encoded.

\begin{ex}
{?} sim_d(colour,Color)
_oct{!} 10/11
{?} den_d[]sim_d(,"this is an easy way to find this string's length")
_oct{!} 48
{?} div_d(sim_d("similarity rounded","and in procents")+1/200,1/100)
_oct{!} 30
\end{ex}

\bfun{\bc{str\d}\bi{expression}}
\index{str@\bc{str}}

\verb|str$| writes \bi{expression} into one single atom. All atoms,
prefixes and operators, with the exception of the space operator, are
copied to the output string. Main use: pasting of two or more atoms.

\bfun{\bc{swi\d(}\bi{interrupt-number}\bc.\bi{input-value}\bc,[\bi{input-value}\bc,\ldots]\bc)}
\index{swi@\bc{swi}}

This function is the most operating-system-dependent function in
Bracmat. Currently, it is implemented for RISC-OS (Archimedes) and
16-bit MS-DOS versions of Bracmat. All arguments must be integer
values. The list of input values (registers r0 and upwards) need not
be complete. Missing values are assumed to be zero. Blocks of memory
should be passed by allocating memory with \verb|alc$| and passing the
returned value. The returned value has the form

\bc(\bi{error-code}\bc.\bi{output-value}\bc,\bi{output-value}\bc,\ldots\bc)

An error code of 0 means that no error is reported. In the MS-DOS
version, the input registers are AX, BX, CX, DX, BP, SI, DI, DS, ES
and FLAGS, respectively.
\begin{ex}
{?} {RISC-OS only}
{?} putstr=(loop,c,buf,ret.        _com[goal: copy argument to memoryblock]
      alc$(den$sim$(!arg,)+1):?buf:?ret _com[allocate block for string to fit]
    & get$(!arg,MEM,VAP):?arg      _com[argument _ensuremath[_rightarrow] single characters]
    & (loop = !arg:%?c ?arg & pok$(!buf.asc$!c.1) & !buf+1:?buf & !loop)
    & ~!loop                       _com[poke each character into memory block]
    & pok$(!buf.0.1)               _com[poke string-delimiting zero]
    & !ret)                        _com[return pointer to block]
{?} putstr$"OS__EvaluateExpression":?inbuf _com[create pointer to string]
{?} 57:?"OS__SWINumberFromString"   _com[from manual]
{?} swi$(!"OS__SWINumberFromString".0,!inbuf):(?error.?nummer,?) _coma[find]
     _comc[interrupt number corresponding with the string _bc[OS__EvaluateExpression]]
{?} fre$!inbuf _com[deallocate block containing copy of input string]

{?} {MS-DOS only}
{?} gotoxy = (VIDEO,setCursorPosition,videoPage0.
{?}   16:?VIDEO                 _com[interrupt number 10H]
{?} & 2*256:?setCursorPosition  _com[AH]
{?} & 0*256:?videoPage0         _com[BH]
{?} & !arg:(?x,?y)              _com[DL and DH]
{?} & swi$(!VIDEO.!setCursorPosition,!videoPage0,0,!x+256*!y)
{?} )
{?} gotoxy$(0,0) & put_d(top left corner)
\end{ex}

\bfun{\bc{sys\d}\bi{command-line-command}}
\index{sys@\bc{sys}}

In most environments,
\verb|sys$| passes its argument to the command line interpreter.
Therefore, \verb|sys$| has a functionality that very much depends on
the operating system in which Bracmat runs. One has to take care for
memory limitations and the possibility that \verb|sys$| may never
return. Possible uses are for example:
\begin{itemize}
\item instructions to the video display unit for cursor movement or graphics
\item running another program, such as an editor
\item manipulation of files (directory listing, copying, etc.)
\end{itemize}

The functions \verb|put$(|\bi{expression}\verb|,MEM)| or
\verb|str$|\bi{expression} may be used for constructing an argument
for \verb|sys$|:
\begin{ex}
{?} file = bracmat.c
{?} !file:((?stem.?)|?stem) _com[remove file extension and put result in _bc[stem]]
{?} sys$str$("copy " !file " " !stem.bak)
\end{ex}

The \verb|sys$| function succeeds, unless a syntactic error was
made. If there is an error at the operating system level, one of the
following codes is returned:
\begin{quote}
  \begin{description}
  \item \bc{E2BIG}\par
    Argument list (which is system-dependent) is too big.
  \item \bc{ENOENT}\par
    Command interpreter cannot be found.
  \item \bc{ENOEXEC}\par
    Command interpreter file has invalid format and is not executable.
  \item \bc{ENOMEM}\par
    Not enough memory is available to execute command; or available
    memory has been corrupted; or invalid block exists, indicating
    that process making call was not allocated properly.
  \end{description}
\end{quote}

If the command succeeds at the operating system level, the value 0 is
returned.

\bfun{\bc{tbl\d(}\bi{variable}\bc,\bi{array-size}\bc)}
\index{tbl@\bc{tbl}}

The named variable is (re-)sized to an array with \bi{array size}
elements. Resizing always affects the elements with the highest
indexes first: shrinking means that the last elements are lost,
expanding creates new zero-valued elements at the end.

If \bi{array-size} equals zero, the named \bi{variable} ceases to
exist in memory. This is the only way in Bracmat to get rid of global
variables.

Stacks and arrays are exactly the same thing in Bracmat. Therefore, it
is not possible to declare arrays locally.

Bracmat never accesses arrays as a whole; there is always just one
element that is in focus. By issuing an instruction of the form
\bi{index}{\bc\d}\bi{array-name} or \bi{index}{\bc\d}\bi{array-name}
you can explicitly tell Bracmat to put focus on some element. Bracmat
does this automatically in the case of pushing and popping local
variables onto and from a stack.
\begin{ex}
{?} tbl_d(bigarray,16000)
{?} lst_d[]bigarray          _com[this may take a long time to execute]
{?} tbl_d(bigarray,0)      _com[remove bigarray]
{?} lst_d[]bigarray
\end{ex}

\bfun{\bc{ugc\d(}\bi{atom-or-nil}\bc)} 
\index{ugc@\bc{ugc}}

\verb|ugc$| determines the Unicode General Category of a character.

\begin{tabular}{lll}
	Lu & Uppercase Letter      & an uppercase letter                               \\
	Ll & Lowercase Letter      & a lowercase letter                                \\
	Lt & Titlecase Letter      & a digraphic character, with first part uppercase  \\
	LC & Cased Letter          & Lu | Ll | Lt                                      \\
	Lm & Modifier Letter       & a modifier letter                                 \\
	Lo & Other Letter          & other letters, including syllables and ideographs \\
	L  & Letter                & Lu | Ll | Lt | Lm | Lo                            \\
	Mn & Nonspacing Mark       & a nonspacing combining mark (zero advance width)  \\
	Mc & Spacing Mark          & a spacing combining mark (positive advance width) \\
	Me & Enclosing Mark        & an enclosing combining mark                       \\
	M  & Mark                  & Mn | Mc | Me                                      \\
	Nd & Decimal Number        & a decimal digit                                   \\
	Nl & Letter Number         & a letterlike numeric character                    \\
	No & Other Number          & a numeric character of other type                 \\
	N  & Number                & Nd | Nl | No                                      \\
	Pc & Connector Punctuation & a connecting punctuation mark, like a tie         \\
	Pd & Dash Punctuation      & a dash or hyphen punctuation mark                 \\
	Ps & Open Punctuation      & an opening punctuation mark (of a pair)           \\
	Pe & Close Punctuation     & a closing punctuation mark (of a pair)            \\
	Pi & Initial Punctuation   & an initial quotation mark                         \\
	Pf & Final Punctuation     & a final quotation mark                            \\
	Po & Other Punctuation     & a punctuation mark of other type                  \\
	P  & Punctuation           & Pc | Pd | Ps | Pe | Pi | Pf | Po                  \\
	Sm & Math Symbol           & a symbol of mathematical use                      \\
	Sc & Currency Symbol       & a currency sign                                   \\
	Sk & Modifier Symbol       & a non-letterlike modifier symbol                  \\
	So & Other Symbol          & a symbol of other type                            \\
	S  & Symbol                & Sm | Sc | Sk | So                                 \\
	Zs & Space Separator       & a space character (of various non-zero widths)    \\
	Zl & Line Separator        & U+2028 LINE SEPARATOR only                        \\
	Zp & Paragraph Separator   & U+2029 PARAGRAPH SEPARATOR only                   \\
	Z  & Separator             & Zs | Zl | Zp                                      \\
	Cc & Control               & a C0 or C1 control code                           \\
	Cf & Format                & a format control character                        \\
	Cs & Surrogate             & a surrogate code point                            \\
	Co & Private Use           & a private-use character                           \\
	Cn & Unassigned            & a reserved unassigned code point or a noncharacter\\
	C  & Other                 & Cc | Cf | Cs | Co | Cn                            \\
\end{tabular}

\bfun{\bc{vap\d(}\bi{fnc}\bc.\bi{string}\bc) or \bc{vap\d(}\bi{fnc}\bc.\bi{string}\bc.\bi{separator}\bc)}
\index{vap@\bc{vap}}

The version without specified separator splits the string in a list of
characters and applies \verb|fnc$| to each character. \verb|vap$|
checks whether the string is valid UTF-8 before splitting the
string. If not, it splits the string in 8-byte characters, even if
some substrings could be interpreted as valid UTF-8.

The version with a specified separator splits the string at each
occurrence of the separator. The separator can be any non-zero length
string. The separator does not become part of the output. This version
is especially useful for reading CSV files and tab-separated
files. Note that, if the last character of the input string is a
separator, the last call to
\verb|fnc$| is with a zero-length string. This will often happen if a
newline character terminates every line in the input string and the
newline character is specified as a separator.

\bfun{\bc{whl'(}\bi{expression}\bc)}
\index{whl@\bc{whl}}

\verb|whl'| implements a \verb|while| \bi{expression} loop. The
expression is repeatedly evaluated until it fails. \verb|whl'| always
succeeds. Notice that \verb|whl'| is faster than loops using tail
recursion.

\bfun{\bc{x2d\d}\bi{hexadecimal value}}
\index{x2d@\bc{x2d}}

\verb|x2d$| converts an hexadecimal number between 0 and FFFFFFFF to a
decimal number. On 64-bit platforms the upper bound is
FFFFFFFFFFFFFFFF. The function fails if the argument is not a string
with a length between 1 and 8 only containing the characters
\verb|0|--\verb|9|, \verb|a|--\verb|f| and \verb|A|--\verb|F|.
\begin{ex}
{?} x2d_d[]ffffffff
_oct{!} 4294967295
\end{ex}

\subsection{Predefined functions}

Besides hard-coded built-in functions, Bracmat offers a number of
soft-coded functions which behave as user defined functions in all
respects. They are redefinable and removable, for example. Some
functions are called by the interpreter itself and should never be
changed by the user. Such functions have names that start with an
8-bit character with the high-bit set. Bracmat has been drilled to
leave these names out when the user asks for a list of variable names
(\verb|lst$| or \verb|mem$|), so you will not notice their
existence.

\bfun{\bc{abs\d}\bi{expression} and \bc{sgn\d}\bi{expression}}
\index{abs@\bc{abs}}
\index{sgn@\bc{sgn}}

\verb|sgn$| determines the sign of the numerical factor of
expression. If the sign is \verb|-|, then \verb|sgn| returns
\verb|-1|. In all other cases the returned value is \verb|1|.

\bc{abs\d}\bi{expression} is defined as
\bc{sgn\d}\bi{expression}\bc*\bi{expression}.
\begin{ex}
{?} sgn$(-1*i)
{?} abs$(-7*a)
\end{ex}

\bfun{\bc{cat\d(}[\bi{include-list}][\bc,[\bi{exclude-list}][\bc{,EXT}]]\bc)}
\index{cat@\bc{cat}}

\verb|cat$| is like the built-in function \verb|mem$|, but offers the
possibility to exclude names that are not in the first parameter
and/or to exclude names that are in the second parameter. The optional
third parameter adds information about array size and current index
value, e.g. (arg,5,5). If the first parameter is missing, this is
taken to mean that \emph{no} names are excluded (unless by virtue of the
second parameter.) You can use \verb|cat$| to save the state of the
variable space for later use, e.g. removing all variables that have
been created since.
\begin{ex}
{?} cat_d(,,EXT):?save-state  _com[_bc[mem_d[]EXT] is also OK]
{?} newvar1=12345            _com[create new variables]
{?} tbl_d(newvar2,100)
{?} cat_d(,!save-state,EXT)   _com[show the newcomers]
\end{ex}

\bfun{\bc{cos\d}\bi{expression} and \bc{sin\d}\bi{expression}}
\index{cos@\bc{cos}}
\index{sin@\bc{sin}}

These functions produce $\cos(\bi{expression})$ and
$\sin(\bi{expression})$, expressed in powers of $e$. In this way,
expressions with goniometric functions can be differentiated and,
sometimes, simplified.

\bfun{\bc{fct\d}\bi{expression}}
\index{fct@\bc{fct}}

\verb|fct$| uses some heuristics in trying to factorise
\bi{expression}.
\begin{ex}
{?} 1+(2*a^3+6/7*t)*(3*x+4*y+z^-1)+-1:?sum
{?} fct\d!sum
_oct{!} 6/7*z^-1*(1+3*x*z+4*y*z)*(t+7/3*a^3)
\end{ex}

\bfun{\bc{flt\d(}\bi{rational-number}\bc,\bi{number-of-decimals}\bc)}
\index{flt@\bc{flt}}

\verb|flt$| converts a rational number to a floating point
presentation. The result is stored in an atom. This function is meant
for output, Bracmat does not use floating point numbers itself.
\begin{ex}
{?} flt_d(123/456,78)
{?} flt_d(sub_d(tay_d(sin_d[]x,x,40).x.11/7),12)
\end{ex}

\bfun{\bc{jsn\d}\bi{expression}}
\index{jsn@\bc{jsn}}

\verb|jsn$| serializes expression to JSON format.

Suppose \verb|mars.json| contains
\begin{v}[commandchars=\\()]
{ "planet": "Mars",
  "moons": ["Deimos", "Phobos"],
  "Eccentricity": 0.0934 }
\end{v}

Read \verb|mars.json| into variable \verb|mars|:
\begin{ex}
{?} get_d("mars.json",JSN):?mars
_oct{!}     (Eccentricity.934/10000)
_oct      + (moons.,(.Deimos) (.Phobos))
_oct      + (planet..Mars)
_oct    ,
\end{ex}
\begin{ex}
{?} !mars:(?name-value-pairs,)
_oct{!}     (Eccentricity.934/10000)
_oct      + (moons.,(.Deimos) (.Phobos))
_oct      + (planet..Mars)
_oct    ,
\end{ex}


Now add the fact that Mars' gravity, compared to the Earth's, is about
$3711/9807$:


\begin{ex}
{?} !name-value-pairs+(ratio.3711/9807):?name-value-pairs
_oct{!}   (Eccentricity.934/10000)
_oct    + (moons.,(.Deimos) (.Phobos))
_oct    + (planet..Mars)
_oct    + (ratio.3711/9807)
\end{ex}
\begin{ex}
{?} (!name-value-pairs,):?mars
_oct{!}     (Eccentricity.934/10000)
_oct      + (moons.,(.Deimos) (.Phobos))
_oct      + (planet..Mars)
_oct      + (ratio.3711/9807)
_oct    ,
\end{ex}


Finally, serialize the new data to JSON
\begin{ex}[commandchars=\\()]
{?} jsn\d!mars
\oct{!} {"Eccentricity":0.0934,"moons":["Deimos","Phobos"],
\oct     "planet":"Mars","ratio":3.78403181401040073417E-1}
\end{ex}

Numbers are, if possible, represented in exact fixed decimal
notation. If rounding is inevitable, numbers are represented in
floating point notation with 21 digits. Numbers that have been read
from JSON input are always considered to be unrounded, and therefore
represented in fixed decimal notation upon writing to JSON.

Objects have their elements sorted.

No attempt is made to make the result look pretty using indentation.

\bi{Mapping between JSON and Bracmat expressions}

A JSON object is represented as a sum of dotted pairs as the LHS (left
hand side) of a comma operator, while the RHS must be empty. The
original ordering of members may be lost, as the sum operator sorts
its terms. In each dotted pair, the LHS represents the object member's
key while the RHS represents the object member's value. An empty
object is represented as \verb|(0,)|.

A JSON array is a space separated list as the RHS of a comma operator
with an empty string as LHS.

A string is mapped to the atomic RHS of a dot operator, leaving the
LHS empty.

\bc{true}, \bc{false} and \bc{null} map onto themselves.

\bfun{\bc{let\d(}(\bi{atom-or-nil})}
\index{let@\bc{let}}

\verb|let$| checks whether a single character is a letter. This function uses the Unicode definitions of letters as found in Unicode.txt. On success, the single character is returned. The function fails if the argument is not a single character that is a letter.

\bfun{\bc{MLencoding\d}\bi{internal-expression-of-XML-or-HTML-data}}
\index{MLencoding@\bc{MLencoding}}

This function parses the data for indicators of the used character
encoding.

\bfun{\bc{nestML\d}\bi{internal-expression-of-XML-or-HTML-data}}
\index{nestML@\bc{nestML}}

After reading XML or HTML data, all text and tags are in a flat
list. The function \verb|nestML| attempts to match opening and closing
tags and creates a tree structure. This works best for XML data.

\bfun{\bc{out\d}\bi{expression}}
\index{out@\bc{out}}

Uses the built-in function
\verb|put$| to output expression to the output stream (usually the
screen.) Output is ended with a new line. Normally, \verb|out$|
returns its argument.
\verb|out$| is a good debugging tool, but \verb|put$| is slightly
safer, as it handles failing arguments in the correct way, contrary to
\verb|out$|.
\begin{ex}
{?} put$a & put$b
_oct[]ab{!} b
{?} out$a & out$b
_oct[]a
_oct[]b
_oct{!} b
\end{ex}

\bfun{\bc{sub\d(}\bi{expression}\bc.\bi{pattern}\bc.\bi{replacement}\bc)}
\index{sub@\bc{sub}}

Substitution function. Argument 1: subject. Argument 2: pattern.
Argument 3: replacement for subexpressions in subject matched by
pattern.

\bfun{\bc{tay\d(}\bi{expression}\bc,\bi{variable}\bc,\bi{number-of-terms}\bc)}
\index{tay@\bc{tay}}

A Taylor expansion is applied to \bi{expression}. The second argument is
the independent variable. The third argument denotes the number of
terms, including vanishing terms.
\begin{ex}
{?} tay$((cos$x)^-1,x,20)
\end{ex}

\bfun{\bc{toML\d}\bi{internal-expression-of-XML-or-HTML-data}}
\index{toML@\bc{toML}}

This function creates a string containing XML or HTML formatted data
from an internal representation of those data. \verb|toML| works both
with nested and unnested data. All necessary character conversions are
made in \verb|PCDATA| and attributes.

\bfun{\bc{chu\d}\bi{value}}
\index{chu@\bc{chu}}

\verb|chu$| returns the UTF-8 character at Unicode code point
\bi{value}. \verb|chu$| fails if \bi{value} equals 0 or less or if
\bi{value} exceeds 2147483647 (7FFFFFFF). According to the UTF-8 standard
values above 1114111 (10FFFF) are illegal.

\bfun{\bc{low\d(}\bi{atom-or-nil}\bc)}
\index{low@\bc{low}}

\verb|low$| converts a string to all-lowercase. The characters
\verb|A|--\verb|Z| are converted to \verb|a|--\verb|z|. Other
characters are handled as UTF-8 encoded Unicode characters, but
default to ISO 8859-1 (Latin 1) if the argument is not valid UTF-8.

\bfun{\bc{upp\d(}\bi{atom-or-nil}\bc)}
\index{upp@\bc{upp}}

\verb|upp$| converts a string to all-uppercase. The characters
\verb|a|--\verb|z| are converted to \verb|A|--\verb|Z|. Other
characters are handled as UTF-8 encoded Unicode characters, but
default to ISO 8859-1 (Latin 1) if the argument is not valid UTF-8.

\bfun{\bc{utf\d}\bi{UTF-8-character}}
\index{utf@\bc{utf}}

\verb|utf$| returns the Unicode code point of the UTF-8 character. The
function fails if the string is too short or too long, or if the
sequence is an invalid UTF-8 string.

It is safe to use \verb|utf$| in a pattern:
\verb|@(!txt:(?%c & utf$!c) ?)| If the value of \bc{txt} starts with
an valid UTF-8 sequence, Bracmat backtracks until the value of \bc{c}
matches the UTF-8 sequence. If \bc{txt} starts with a sequence that is
not UTF-8, Bracmat stops backtracking when that fact has been
established.

\section{Methods}
\index{method}
A method is function that is a member of an object. A method definition is not
different from a function definition, but the ways in which methods and a
functions are called are. While a function call only requires the name of the
function, a method call requires the name or definition of an object and the
name of the method, separated by a dot operator. In the body of a method it is
usually necessary to refer to other members of the same object - that is one of
the primary objectives of using objects. Such self-references start with \verb|its|,
which is analogous to \verb|this| in C++. Here is an example of an object that
represents a rectangle with an \verb|x-size| and a \verb|y-size| for the lengths of two
orthogonal sides. Apart from these two data members, the object also has a
member function \verb|area$| that returns the product of the \verb|x-size| and the
\verb|y-size|, and another member function that computes the length of the diagonal.
\begin{ex}
{?} (rect=
    (x-size=5)
    (y-size=12)
    (area=.!(its.x-size)*!(its.y-size))
    (diagonal=.(!(its.x-size)^2+!(its.y-size)^2)^1/2)
    );
{?} (rect.area)$
_oct{!} 60
{?} (rect.diagonal)$
_oct{!} 13
\end{ex}

\section{Hash tables}

If you need to manage a large data set it may be a good idea to use a
hash table instead of a list. Storing, retrieving and deleting are
costly processes in lists, but cheap in hash tables. Handling hash
tables in Bracmat is very simple. You create a hash table as follows
\begin{ex}
{?} new_d[]hash:?myhash
\end{ex}

Hereafter, \verb|myhash| refers to a hash table and is treated in the
same way as a user defined object. Bracmat keeps the load factor
between 50 and 100, rehashing as necessary.

If you know the hash table is going to be much bigger than about 100
bins, you can suggest the size of the table to Bracmat, but this is
not necessary:
\begin{ex}
{?} new_d(hash,1000000):?mybiggerhash
\end{ex}
This tells Bracmat to start off with a million bins.

The following methods are defined for hash tables:
\begin{quote}
  \begin{description}
  \item \bc{find}\par
    find all values for a given key
  \item \bc{insert}\par
    insert a value for a key
  \item \bc{remove}\par
    remove a key and all its values
  \item \bc{New}\par
    creates a hash table, cannot be called programmatically
  \item \bc{Die}\par
    cleans up a hash table, cannot be called programmatically
  \item \bc{ISO}\par
    make all key access case-insensitive
  \item \bc{casesensitive}\par
    make all key access case sensitive (default)
  \item \bc{forall}\par
    apply a function to all key-value pairs
  \end{description}
\end{quote}

\bfun{\bc{(myhash..find)\d{}key\bc:(?Key.?Value) ?OtherKeyValuePairs}}

Returns a blank-separated list of key-value pairs, all with the same
key.

\bfun{\bc{(myhash..insert)\d(Key.Value)}}

Inserts the key \bc{Key} with the value \bc{Value}. Multiple values
for the same key are possible and the same value can be inserted more
than once for the same key.

\bfun{\bc{(myhash..remove)\d{}key:?KeyValuePairs}}

Removes the key with all its values and returns a blank-separated list
of key-value pairs.

\bfun{\bc{New}}

This is a method of the hash class that is called by the system when
it evaluates \verb|new$hash|. It cannot be called from user code.

\bfun{\bc{Die}}

This method is called when a hash object is deleted. It is not
directly called from user code. (Compare with a C++ destructor.) You
can add your own clean up code by writing a \verb|die| method and
adding it to a hash object once it is created.

Example:
\begin{ex}
{?} new_d[]hash:?myhash;               _com[create a hash table _bc[myhash] ]
{?} ((
    =   ( Insert                    _coma[add a method _bc[Insert] to _bc[myhash] that]
                                    _comc[only allows one value per key]
        =   K,V
          .     !arg:(?K.?V)
              & (Its..find)_d!K:(?.?v)
              &   out
                _d ( str
                  _d ( "Key "
                      !K
                      " already present"
                      ( !V:!v&" with same"
                      | ", but with different"
                      )
                      " value "
                      !v
                    )
                  )
            | (Its..insert)_d!arg
        )
        (die=.out_d"Who ordered th") _coma[this method is called just before]
                                    _comc[the object is deleted]
    )
  : (=?(myhash.)))
  
{?} (myhash..Insert)_d(X.12);        _com[insert the value 12 for key _bc[X]]
{?} (myhash..Insert)_d(X.1 2);       _com[try to do it one more time]
{?} (myhash..Insert)_d(X.10 );       _coma[try to insert another value]
                                    _comc[for the same key]
{?} (myhash..insert)_d(Z.1);         _com[use the built-in insert method]
{?} (myhash..insert)_d(Z.1);         _com[insert same value again]
{?} (myhash..insert)_d(Z.2);         _com[also insert a different value]
{?} (myhash..find)_d[]X;               _coma[show all key-value pairs of _bc[X]]
                                    _comc[(only 1)]
{?} (myhash..find)_d[]Z;               _com[show all key-value pairs of _bc[Z.(3)]]
{?} (myhash..remove)_d[]Z:?values;
{?} :?myhash;                       _com[get rid of the hash table] 
\end{ex}

\bfun{\bc{(myhash..ISO)\d}}

Make all key access case-insensitive. This applies to the full Unicode
table, but defaults to ASCII and the upper 128 characters in the
ISO 8859-1 (Latin 1) character set if the characters are not UTF-8
encoded.

\bfun{\bc{(myhash..casesensitive)\d}}

Make all key access case sensitive. This the default.

\bfun{\bc{(myhash..forall)\d{}Function}}

Apply the function to all key-value pairs. The function can be
specified by its name or by its function body. The \bc{forall} method
finishes when all elements are traversed or before that if the
function fails. The behaviour of \bc{forall} is undefined if the hash table
is changed or deleted during the traversal, although this can be done
safely. For example, some members may be missed and others may be processed
more than once.

Example:
\begin{ex}
{?} new_d[]hash:?myhash;          _com[create a hash table _bc[myhash]]
{?} (myhash..insert)_d(X.12);   _com[insert the value 12 for key _bc[X]]
{?} (myhash..insert)_d(Z.1);    _com[use the built-in _bc[insert] method]
{?} ( (myhash..forall)         _com[output all key-value pairs]
    _d (
      =   Key,Value,loop
        .   ( loop
            =   !arg:(?Key.?Value) ?arg
              & out_d(str_d("Key=" !Key  " Value=" !Value))
              & !loop
            )
          & ~!loop
      )
    )
\end{ex}


\section{Character set}

Bracmat supports UTF-8 as well as ISO 8859-1 encoded source code. In
most cases it does not matter how characters are encoded, because
Bracmat merely sees sequences of non-zero bytes. Only a few functions
explicitly handle UTF-8 encoded characters. When lower- or uppercasing
text, Bracmat assumes that the argument is UTF-8 encoded, but
graciously falls back to regarding the argument as ISO 8859-1 encoded
if parsing the argument as UTF-8 fails. UTF-16 and UTF-32 is not
supported, because those encodings make use of zero-bytes.

\section{Predefined variables}
\index{predefined variables}
There are three variables that are predefined, but that in no way are preserved
by Bracmat.
\begin{ex}
{?} !w
\end{ex}
This returns article 11 of the GNU General Public License, Version 2.
\begin{ex}
{?} !c
\end{ex}
This returns article 12 of the GNU General Public License, Version 2.</p>
\begin{ex}
{?} !v
\end{ex}
This returns the current version number and build date of Bracmat.

\section{Acknowledgements}
G\'{e}rard Milmeister is the creator of the initial LaTeX version of this document. He has meticulously tried out all examples and reported the inconsistencies that he found. He also noticed that a few subjects were nowhere described. Following his advice, I have added the missing sections and improved some existing sections. Gérard also corrected spelling errors and improved wording in some places. 

\printindex

\end{document}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
